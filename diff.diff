diff --git a/diff.diff b/diff.diff
index 2188e92..e69de29 100644
--- a/diff.diff
+++ b/diff.diff
@@ -1,11520 +0,0 @@
-diff --git a/.DS_Store b/.DS_Store
-new file mode 100644
-index 0000000..157cc52
-Binary files /dev/null and b/.DS_Store differ
-diff --git a/.gitignore b/.gitignore
-index 77b96f7..676fd59 100644
---- a/.gitignore
-+++ b/.gitignore
-@@ -1,4 +1,5 @@
- #maven and IntelliJ
- target/
- *.iml
--dependency-reduced-pom.xml
-\ No newline at end of file
-+dependency-reduced-pom.xml
-+.idea/
-\ No newline at end of file
-diff --git a/config.yml b/config.yml
-index 4a321d0..21fae0a 100644
---- a/config.yml
-+++ b/config.yml
-@@ -1,17 +1,17 @@
- webstats:
--    enable: true
--    action: "www.somescript.com/dothis.php"
--    secret: "abcdef12345"
--    position: 0
-+  enable: true
-+  action: "www.somescript.com/dothis.php"
-+  secret: "abcdef12345"
-+  position: 0
- settings:
--    maps_repo: "~/path/to/maps"
--    voteTime: 26
--    cycleTime: 30
--    startTime: 30
-+  maps_repo: "/home/founders/repo/maps"
-+  voteTime: 30
-+  cycleTime: 30
-+  startTime: 30
- database:
--    enabled: true
--    username: "user"
--    password: "pass"
--    database: "war"
--    hostname: "localhost"
--    port: 3306
-\ No newline at end of file
-+  enabled: true
-+  username: "jj"
-+  password: "S^yL?dX5@a9L"
-+  database: "mira"
-+  hostname: "core.mira.sbs"
-+  port: 5432
-\ No newline at end of file
-diff --git a/diff.diff b/diff.diff
-new file mode 100644
-index 0000000..e69de29
-diff --git a/messages.yml b/messages.yml
-index 246b15e..700522d 100644
---- a/messages.yml
-+++ b/messages.yml
-@@ -1,19 +1,27 @@
- prelogin:
--    error: "&cAn error occurred logging you in.\nPlease try again later."
-+  error: "&cAn error occurred logging you in.\nPlease try again later."
- killstreaks:
--    status: "You are running a killstreak of {0}."
--    onfire: "{0} is on fire!"
-+  status: "You are running a killstreak of {0}."
-+  onfire: "{0} is on fire!"
- votes:
--    starting: "A vote is now being held.\nHover over a Gamemode for more information:"
--    next: "The next match was {0} {1} at {2}!"
-+  starting: "A vote is now being held.\nHover over a Gamemode for more information:"
-+  next: "The next match was {0} {1} at {2}!"
- votifier:
--    self: "You voted and received a revive. Thank you!"
--    others: "{0} &fvoted and received a free revive! (/vote)"
-+  self: "You voted and received a revive. Thank you!"
-+  others: "{0} &fvoted and received a free revive! (/vote)"
- guard:
--    building: "You cannot build on this map."
--    border: "Build inside the map border!"
--    highest: "You cannot build any higher."
-+  building: "You cannot build on this map."
-+  border: "Build inside the map border!"
-+  highest: "You cannot build any higher."
- match:
--    teams:
--        full: "All teams are full. Please try joining later."
--        join: "You have joined the {0}!"
-\ No newline at end of file
-+  teams:
-+    full: "All teams are full. Please try joining later."
-+    join: "You have joined the {0}!"
-+command:
-+  validation:
-+    error:
-+      generic: "&c{0}. ;-;"
-+      permission: "&cyou do not have permission. ;-;"
-+      usage: "&c{0}.\n&cusage: {1}. ^_^"
-+      number:
-+        format: "&cplease provide a valid numerical value. :/"
-\ No newline at end of file
-diff --git a/plugin.yml b/plugin.yml
-index e9a3ea4..b151d76 100644
---- a/plugin.yml
-+++ b/plugin.yml
-@@ -1,5 +1,5 @@
--name: War
--main: au.edu.swin.war.Main
--author: [ILavaYou]
-+name: pvp.mira.sbs
-+main: sbs.mira.pvp.Main
-+author: [Kawi]
- depend: [Skytopia]
- version: 1.1
-\ No newline at end of file
-diff --git a/pom.xml b/pom.xml
-index db84f09..f0b6c54 100644
---- a/pom.xml
-+++ b/pom.xml
-@@ -1,106 +1,100 @@
- <?xml version="1.0" encoding="UTF-8"?>
- <project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://maven.apache.org/POM/4.0.0"
-          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
--    <modelVersion>4.0.0</modelVersion>
--    <groupId>au.edu.swin.war</groupId>
--    <artifactId>War</artifactId>
--    <version>1.1-SNAPSHOT</version>
--    <description>The implementation of War to fulfil HDT3.1 requirements.</description>
-+  <modelVersion>4.0.0</modelVersion>
-+  <groupId>sbs.mira</groupId>
-+  <artifactId>pvp.mira.sbs</artifactId>
-+  <version>0.0.1-infdev</version>
-+  <description>custom minecraft pvp with soul.</description>
- 
--    <packaging>jar</packaging>
-+  <packaging>jar</packaging>
- 
--    <properties>
--        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
--        <main.class>au.edu.swin.war.Main</main.class>
--    </properties>
-+  <properties>
-+    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
-+    <main.class>sbs.mira.pvp.MiraPvpPlugin</main.class>
-+  </properties>
- 
--    <build>
--        <finalName>${project.name}</finalName>
--        <sourceDirectory>${basedir}/src</sourceDirectory>
--        <resources>
--            <resource>
--                <targetPath>.</targetPath>
--                <filtering>true</filtering>
--                <directory>${basedir}/</directory>
-+  <build>
-+    <finalName>${project.name}</finalName>
-+    <sourceDirectory>${basedir}/src</sourceDirectory>
-+    <resources>
-+      <resource>
-+        <targetPath>.</targetPath>
-+        <filtering>true</filtering>
-+        <directory>${basedir}/</directory>
-+        <includes>
-+          <include>plugin.yml</include>
-+          <include>config.yml</include>
-+          <include>messages.yml</include>
-+        </includes>
-+      </resource>
-+    </resources>
-+    <plugins>
-+      <plugin>
-+        <groupId>org.apache.maven.plugins</groupId>
-+        <artifactId>maven-compiler-plugin</artifactId>
-+        <version>2.3.2</version>
-+        <configuration>
-+          <source>24</source>
-+          <target>24</target>
-+        </configuration>
-+      </plugin>
-+      <plugin>
-+        <groupId>org.apache.maven.plugins</groupId>
-+        <artifactId>maven-shade-plugin</artifactId>
-+        <version>2.2</version>
-+        <executions>
-+          <execution>
-+            <phase>package</phase>
-+            <goals>
-+              <goal>shade</goal>
-+            </goals>
-+            <configuration>
-+              <artifactSet>
-                 <includes>
--                    <include>plugin.yml</include>
--                    <include>config.yml</include>
--                    <include>messages.yml</include>
-+                  <include>com.sk89q:command-framework-bukkit</include>
-                 </includes>
--            </resource>
--        </resources>
--        <plugins>
--            <plugin>
--                <groupId>org.apache.maven.plugins</groupId>
--                <artifactId>maven-compiler-plugin</artifactId>
--                <version>2.3.2</version>
--                <configuration>
--                    <source>1.8</source>
--                    <target>1.8</target>
--                </configuration>
--            </plugin>
--            <plugin>
--                <!-- Shade plugin: Used to include sk89q's command framework/war framework into the jar -->
--                <groupId>org.apache.maven.plugins</groupId>
--                <artifactId>maven-shade-plugin</artifactId>
--                <version>2.2</version>
--                <executions>
--                    <execution>
--                        <phase>package</phase>
--                        <goals>
--                            <goal>shade</goal>
--                        </goals>
--                        <configuration>
--                            <artifactSet>
--                                <includes>
--                                    <include>com.sk89q:command-framework-bukkit</include>
--                                    <include>au.edu.swin.war:Framework</include>
--                                </includes>
--                            </artifactSet>
--                        </configuration>
--                    </execution>
--                </executions>
--            </plugin>
--        </plugins>
--    </build>
--    <repositories>
--        <repository>
--            <id>spigot-repo</id>
--            <url>https://hub.spigotmc.org/nexus/content/groups/public/</url>
--        </repository>
--    </repositories>
--    <dependencies>
--        <dependency>
--            <groupId>au.edu.swin.war</groupId>
--            <artifactId>Framework</artifactId>
--            <version>1.0-SNAPSHOT</version>
--        </dependency>
--        <dependency>
--            <groupId>org.spigotmc</groupId>
--            <artifactId>spigot-api</artifactId>
--            <version>1.12.2-R0.1-SNAPSHOT</version>
--        </dependency>
--        <dependency>
--            <groupId>org.bukkit</groupId>
--            <artifactId>craftbukkit</artifactId>
--            <version>1.12.2-R0.1-SNAPSHOT</version>
--        </dependency>
--        <dependency>
--            <groupId>com.sk89q</groupId>
--            <artifactId>command-framework-bukkit</artifactId>
--            <version>1.9-SNAPSHOT</version>
--        </dependency>
--        <dependency>
--            <groupId>com.vexsoftware</groupId>
--            <artifactId>nuvotifier-universal</artifactId>
--            <version>2.3.1</version>
--            <systemPath>${project.basedir}/resources/votifier.jar</systemPath>
--            <scope>system</scope>
--        </dependency>
--    </dependencies>
-+              </artifactSet>
-+            </configuration>
-+          </execution>
-+        </executions>
-+      </plugin>
-+    </plugins>
-+  </build>
-+  <repositories>
-+    <repository>
-+      <id>spigot-repo</id>
-+      <url>https://hub.spigotmc.org/nexus/content/repositories/snapshots/</url>
-+    </repository>
-+  </repositories>
-+  <dependencies>
-+    <dependency>
-+      <groupId>org.spigotmc</groupId>
-+      <artifactId>spigot</artifactId>
-+      <version>1.21.8-R0.1-SNAPSHOT</version>
-+      <scope>provided</scope>
-+    </dependency>
-+    <dependency>
-+      <groupId>org.bukkit</groupId>
-+      <artifactId>craftbukkit</artifactId>
-+      <version>1.21.8-R0.1-SNAPSHOT</version>
-+      <scope>provided</scope>
-+    </dependency>
-+    <dependency>
-+      <groupId>com.sk89q</groupId>
-+      <artifactId>command-framework-bukkit</artifactId>
-+      <version>1.9-SNAPSHOT</version>
-+    </dependency>
-+    <dependency>
-+      <groupId>org.jetbrains</groupId>
-+      <artifactId>annotations</artifactId>
-+      <version>RELEASE</version>
-+      <scope>compile</scope>
-+    </dependency>
-+  </dependencies>
- 
--    <issueManagement>
--        <system>GitHub</system>
--        <url>https://github.com/outspier/War</url>
--    </issueManagement>
-+  <issueManagement>
-+    <system>GitHub</system>
-+    <url>https://github.com/mira-sbs/pvp.mira.sbs</url>
-+  </issueManagement>
- </project>
-\ No newline at end of file
-diff --git a/src/au/edu/swin/war/Main.java b/src/au/edu/swin/war/Main.java
-deleted file mode 100644
-index edf8866..0000000
---- a/src/au/edu/swin/war/Main.java
-+++ /dev/null
-@@ -1,61 +0,0 @@
--package au.edu.swin.war;
--
--import au.edu.swin.war.framework.WarPlugin;
--import au.edu.swin.war.framework.util.WarManager;
--import au.edu.swin.war.util.Manager;
--import au.edu.swin.war.util.Match;
--import au.edu.swin.war.util.modules.CommandUtility;
--import au.edu.swin.war.util.modules.StatsCommandUtility;
--import org.bukkit.Bukkit;
--import org.bukkit.entity.Player;
--
--/**
-- * An extension to WarPlugin.
-- * Acts as Main class and Spigot link.
-- *
-- * @author s101601828 @ Swin.
-- * @version 1.1
-- * @see WarPlugin
-- * <p>
-- * Created by Josh on 20/04/2017.
-- * @since 1.0
-- */
--public class Main extends WarPlugin {
--
--    private transient Manager supercontroller; // Running instance of Manager.
--
--    /**
--     * Required method by WarPlugin.
--     * Acts as the program's "Main()".
--     */
--    public void onEnable() {
--        log("War program has awoken!");
--        this.getServer().getMessenger().registerOutgoingPluginChannel(this, "BungeeCord");
--        // The Manager handles most of the module initialisations.
--        supercontroller = new Manager(this);
--        registerCommandClass(CommandUtility.class); // Register the command class containing the @Commands.
--        registerCommandClass(StatsCommandUtility.class); // Register statistics modules.
--        registerCommands(); // Finalise the registration of  all the classes we chose.
--        ((Match) main().match()).firstMatch(); // Start the special first round procedure to kick off the cycle.
--    }
--
--    /**
--     * Requires method by WarPlugin.
--     * Called when this program is shut down.
--     */
--    public void onDisable() {
--        for (Player online : Bukkit.getOnlinePlayers())
--            online.kickPlayer(getServer().getShutdownMessage());
--        main().world().restoreMap(main().match().getRawRoundID() + ""); // Delete the current match world on shutdown.
--    }
--
--    /**
--     * Required method by WarPlugin.
--     * Returns running instance of the Manager.
--     *
--     * @return The Manager.
--     */
--    public WarManager main() {
--        return supercontroller;
--    }
--}
-diff --git a/src/au/edu/swin/war/WarPlayerPlus.java b/src/au/edu/swin/war/WarPlayerPlus.java
-deleted file mode 100644
-index 151e9c8..0000000
---- a/src/au/edu/swin/war/WarPlayerPlus.java
-+++ /dev/null
-@@ -1,69 +0,0 @@
--package au.edu.swin.war;
--
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.stats.WarStats;
--import au.edu.swin.war.util.Manager;
--import org.bukkit.ChatColor;
--import org.bukkit.entity.Player;
--
--/**
-- * An extension to WarPlayer that contains non-framework fields.
-- * Mostly used for statistics tracking.
-- *
-- * @author ILavaYou
-- * @version 1.0
-- * @since 1.1
-- */
--public final class WarPlayerPlus extends WarPlayer {
--
--    private final WarStats stats; // Stats object.
--
--    /**
--     * Constructor for WarPlayer class.
--     *
--     * @param player  The Spigot instance of the Player's entity.
--     * @param manager Instance of the supercontroller.
--     */
--    public WarPlayerPlus(Player player, Manager manager, WarStats stats) {
--        super(player, manager);
--        this.stats = stats;
--    }
--
--    /**
--     * Returns this player's statistics record.
--     *
--     * @return Statistics for this player.
--     */
--    public WarStats stats() {
--        return stats;
--    }
--
--    /**
--     * Updates this player's display name.
--     * This should be called whenever their
--     * team changes or rank changes.
--     */
--    public void update() {
--        String prefix = "";
--        if (manager.plugin().hasPermission(getPlayer(), "war.admin"))
--            // Admins do not have any other prefixes, except map builder.
--            prefix = ChatColor.GOLD + "@";
--        else {
--            if (manager.plugin().hasPermission(getPlayer(), "war.mod"))
--                // Give mod prefixes priority too.
--                prefix = ChatColor.DARK_PURPLE + "@";
--
--            if (manager.plugin().hasPermission(getPlayer(), "war.donatorplus"))
--                // DonatorPlus takes priority over Donator.
--                prefix = ChatColor.YELLOW + "#" + prefix;
--            else if (manager.plugin().hasPermission(getPlayer(), "war.donator"))
--                // Otherwise do donator if they only have that.
--                prefix = ChatColor.GREEN + "#" + prefix;
--        }
--        if (manager.cache().getCurrentMap().isCreator(getPlayer().getUniqueId()))
--            prefix = ChatColor.DARK_RED + "#" + prefix;
--
--        ChatColor teamColor = isPlaying() ? getCurrentTeam().getTeamColor() : ChatColor.LIGHT_PURPLE;
--        getPlayer().setDisplayName(prefix + teamColor + getName() + ChatColor.WHITE);
--    }
--}
-diff --git a/src/au/edu/swin/war/game/modes/CTF.java b/src/au/edu/swin/war/game/modes/CTF.java
-deleted file mode 100644
-index a6ab2d8..0000000
---- a/src/au/edu/swin/war/game/modes/CTF.java
-+++ /dev/null
-@@ -1,409 +0,0 @@
--package au.edu.swin.war.game.modes;
--
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.stored.SerializedLocation;
--import au.edu.swin.war.framework.util.WarManager;
--import au.edu.swin.war.game.Gamemode;
--import au.edu.swin.war.util.Manager;
--import au.edu.swin.war.util.WoolColor;
--import org.bukkit.*;
--import org.bukkit.block.Block;
--import org.bukkit.entity.Player;
--import org.bukkit.event.EventHandler;
--import org.bukkit.event.block.Action;
--import org.bukkit.event.block.BlockBreakEvent;
--import org.bukkit.event.entity.EntityPickupItemEvent;
--import org.bukkit.event.player.PlayerInteractEvent;
--import org.bukkit.scoreboard.DisplaySlot;
--import org.bukkit.scoreboard.Objective;
--
--import java.util.ArrayList;
--import java.util.HashMap;
--import java.util.Iterator;
--
--/**
-- * An extension to gamemode to implement CTF.
-- * Capture The Flag objectives have been defined
-- * in my design brief, so I will assume you
-- * know what you are expecting to look at here.
-- *
-- * @author s101601828 @ Swin.
-- * @version 1.0
-- * @see WarManager
-- * <p>
-- * Created by Josh on 24/04/2017.
-- * @since 1.0
-- */
--public class CTF extends Gamemode {
--
--    private HashMap<String, CTFInfo> info; // Key/vaslue set of CTF Info for each team.
--    private HashMap<String, String> capture; // Key/value set of who's holding who's flag.
--    private boolean instantBreak; // Whether or not flags break on punching them or not.
--    private int interval = 1; // Interval at which fireworks shoot from the flags.
--
--    public void reset() {
--        if (capture != null)
--            capture.clear();
--        capture = null;
--        if (info != null)
--            info.clear();
--        info = null;
--        instantBreak = false;
--    }
--
--    public void initialize() {
--        interval = 1; // Reset the interval if applicable.
--        info = new HashMap<>();
--        capture = new HashMap<>();
--
--        for (WarTeam team : getTeams()) // Create CTFInfo for each participating team.
--            info.put(team.getTeamName(), new CTFInfo(team));
--
--        autoAssign();
--        restoreFlags(); // Un-bedrock the flags.
--
--        // Assign objective to scoreboard for this gamemode.
--        Objective obj = s().registerNewObjective("gm", "dummy");
--        obj.setDisplaySlot(DisplaySlot.SIDEBAR); // Display it in sidebar. Pretty.
--        updateScoreboard(); // Update the scoreboard to put all the default values on it.
--
--        for (Player online : Bukkit.getOnlinePlayers())
--            online.setScoreboard(s()); // Everyone online needs to see this scoreboard.
--    }
--
--    public void tick() {
--        // This is all called every second.
--        interval--;
--        if (interval == 0) {
--            // Do fireworks every 4 seconds.
--            interval = 4;
--            doFireworks();
--        }
--        // If the amount of time elapsed is 2.5 minutes times the amount of captures required to win,
--        if (getTimeElapsed() > (150 * (Integer) map().attr().get("captureRequirement")) && !instantBreak) {
--            // Enable "instant break".
--            instantBreak = true;
--            Bukkit.broadcastMessage("This match is taking too long, Instant Break is now enabled!");
--            logEvent("Instant break was enabled!");
--        }
--    }
--
--    public void onKill(WarPlayer killed, WarPlayer killer) {
--        dropFlag(killed);
--    }
--
--    public void onDeath(WarPlayer dead) {
--        dropFlag(dead);
--    }
--
--    /**
--     * If the player is holding a flag and they die,
--     * drop the flag, restore it, and broadcast it.
--     * <p>
--     * This is called from both classes since they are
--     * functionally identical except one has a killer.
--     *
--     * @param killed The player who died.
--     */
--    private void dropFlag(WarPlayer killed) {
--        for (CTFInfo inf : info.values()) {
--            if (inf.getHolder() != null)
--                if (inf.getHolder().equals(killed.getName())) {
--                    capture.remove(killed.getName()); // Remove their flagholder status.
--                    Bukkit.broadcastMessage(killed.getDisplayName() + " dropped " + inf.getTeam().getDisplayName() + "'s flag!"); // Broadcast the change.
--                    logEvent(killed.getDisplayName() + " dropped " + inf.getTeam().getDisplayName() + "'s flag!"); // Log the change.
--                    for (Player target : Bukkit.getOnlinePlayers())
--                        target.playSound(target.getLocation(), Sound.ENTITY_IRONGOLEM_HURT, 1F, 1F); // Play a sound effect.
--                    inf.setHolder(null); // Set the holder to null.
--                    restoreFlags(); // Restore the flag.
--                    updateScoreboard(); // Update the scoreboard.
--                }
--        }
--    }
--
--    public void decideWinner() {
--        int highest = -1; // Highest is lower than zero since teams start off as zero.
--        ArrayList<WarTeam> winners = new ArrayList<>(); // Keep a temporary list of winners.
--
--        for (WarTeam team : getTeams()) {
--            // For each team, check their kills.
--            int count = info.get(team.getTeamName()).getCaptures();
--            if (count == highest)
--                // If they're equal to the current highest points, add them to the list of winners.
--                winners.add(team);
--            else if (count > highest) {
--                // If they're above the current highest points,
--                // Set the new highst points,
--                highest = count;
--                // Clear the current list of winners as they have less points than this team,
--                winners.clear();
--                // Then add this team to the list of winners.
--                winners.add(team);
--            }
--        }
--        broadcastWinner(winners, "captures", highest);
--    }
--
--    public void onLeave(WarPlayer left) {
--        dropFlag(left); // Call this because people who aren't in the match can't hold the flag.
--    }
--
--    /**
--     * Spawns fireworks at each flag or flag holder location.
--     */
--    private void doFireworks() {
--        for (CTFInfo inf : info.values())
--            if (inf.getHolder() == null) // Spawn at flag.
--                ((Manager) main).entity().spawnFirework(inf.getFlag().clone().add(0.5, 1, 0.5), inf.getTeam().getTeamColor());
--            else // Spawn at holder.
--                ((Manager) main).entity().spawnFirework(Bukkit.getPlayer(inf.getHolder()).getLocation(), inf.getTeam().getTeamColor());
--    }
--
--    /**
--     * Restores any flags to their pedestals if
--     * they are currently not being held.
--     */
--    private void restoreFlags() {
--        for (CTFInfo inf : info.values())
--            if (inf.getHolder() == null) { // If this flag isn't being held...
--                Block flag = inf.flag.getBlock(); // Get the flag's block.
--                flag.setType(Material.WOOL); // Set it to wool.
--                flag.setData(WoolColor.fromChatColor(inf.target.getTeamColor()).getColor()); // Color the wool.
--            }
--    }
--
--    public void updateScoreboard() {
--        // Get the "objective" on the scoreboard, where data goes.
--        Objective obj = s().getObjective(DisplaySlot.SIDEBAR);
--
--        // The title of the scoreboard, which displays the map and gamemode playing this match.
--        String dp = map().getMapName() + " (" + getName() + ")";
--        if (dp.length() > 32) dp = dp.substring(0, 32); // Titles cannot be longer than 32 characters.
--        obj.setDisplayName(dp); // Set the title of the scoreboard.
--        obj.setDisplaySlot(DisplaySlot.SIDEBAR); // Ensure it is on the sidebar.
--
--        // Format it pretty for the players.
--        obj.getScore(" ").setScore(info.size() + 2); // Top spacer.
--        obj.getScore("  Captures").setScore(info.size() + 1); // 'Points' denoter.
--
--        int rqmt = (int) map().attr().get("captureRequirement"); // The amount of captures required to win.
--        Iterator<WarTeam> iterator = getTeams().iterator(); // An iterator to iterate through the teams.
--        for (int i = 0; i < info.size(); i++) { // Loop through each CTFInfo in the array.
--            CTFInfo inf = info.get(iterator.next().getTeamName());
--            if (inf.getHolder() == null) {
--                // Are they holding the flag?
--                // If so, reset all other states the scoreboard can be in.
--                // Then, write the state the scoreboard is in.
--                obj.getScore(inf.getTeam().getTeamColor() + "    █ " + inf.getCaptures() + ChatColor.GRAY + "/" + rqmt).setScore(i + 1);
--                s().resetScores(inf.getTeam().getTeamColor() + "    ▓ " + inf.getCaptures() + ChatColor.GRAY + "/" + rqmt);
--                s().resetScores(inf.getTeam().getTeamColor() + "    █ " + (inf.getCaptures() - 1) + ChatColor.GRAY + "/" + rqmt);
--                s().resetScores(inf.getTeam().getTeamColor() + "    ▓ " + (inf.getCaptures() - 1) + ChatColor.GRAY + "/" + rqmt);
--            } else {
--                // If someone is holding this flag, display it as stolen on the scoreboard.
--                // Reset the non-stolen state on the scoreboard.
--                obj.getScore(inf.getTeam().getTeamColor() + "    ▓ " + inf.getCaptures() + ChatColor.GRAY + "/" + rqmt).setScore(i + 1);
--                s().resetScores(inf.getTeam().getTeamColor() + "    █ " + inf.getCaptures() + ChatColor.GRAY + "/" + rqmt);
--            }
--        }
--        obj.getScore("  ").setScore(0); // Bottom spacer.
--    }
--
--
--    public String getOffensive() {
--        return "Steal the other enemy's flag and capture it by punching your flag!";
--    }
--
--    public String getDefensive() {
--        return "Stop the enemy from taking your flag!";
--    }
--
--    public String getFullName() {
--        return "Capture The Flag";
--    }
--
--    public String getName() {
--        return "CTF";
--    }
--
--    public String getGrammar() {
--        return "a";
--    }
--
--    /**
--     * Check if a win has been attained after a capture.
--     * If there is a win, onEnd should be called.
--     *
--     * @return Whether or not any team has won.
--     */
--    private boolean checkWin() {
--        for (CTFInfo inf : info.values())
--            if (inf.getCaptures() >= (Integer) map().attr().get("captureRequirement"))
--                return true;
--        return false;
--    }
--
--    @EventHandler
--    public void onBreak(BlockBreakEvent event) {
--        if (event.getBlock().getType() == Material.BEDROCK) return;
--        WarPlayer wp = main.getWarPlayer(event.getPlayer());
--        if (checkBreak(wp, event.getBlock()))
--            event.setCancelled(true); // Depending on the value the function returns, cancel the block breaking.
--    }
--
--    @EventHandler
--    public void onPunch(PlayerInteractEvent event) {
--        if (event.getClickedBlock() == null) return;
--        WarPlayer wp = main.getWarPlayer(event.getPlayer().getUniqueId());
--        if (capture.containsKey(wp.getName()))
--            for (CTFInfo inf : info.values()) { // For every team's flag...
--                if (inf.flag.equals(event.getClickedBlock().getLocation())) { // Did they click a flag?
--                    if (inf.target.getTeamName().equals(wp.getCurrentTeam().getTeamName())) { // Is it their team's flag?
--                        if (inf.getHolder() == null) {
--
--                            for (Player target : Bukkit.getOnlinePlayers())
--                                target.playSound(target.getLocation(), Sound.ENTITY_PLAYER_LEVELUP, 1F, 1F); // Play a sound effect.
--                            capture.remove(wp.getName()); // They are no longer holding the flag if they captured it.
--                            inf.addCapture(); // Increment their capture count.
--                            for (CTFInfo inf2 : info.values()) // Loop through every team's flag again...
--                                if (inf2.getHolder() != null) // Is someone holding their flag?
--                                    if (inf2.getHolder().equals(wp.getName())) { // Was it their flag that just got captured?
--                                        // If no one is holding their flag, capture it!
--                                        Bukkit.broadcastMessage(wp.getDisplayName() + " captured " + inf2.getTeam().getDisplayName() + "'s flag!");
--                                        logEvent(wp.getDisplayName() + " captured " + inf2.getTeam().getDisplayName() + "'s flag"); // Log the capture.
--                                        inf2.setHolder(null); // No one is holding their flag anymore as it got captured.
--                                        break;
--                                    }
--                            restoreFlags(); // Restore the flags.
--                            updateScoreboard(); // Update the scoreboard.
--                            if (checkWin()) { // Was this a winning capture?
--                                onEnd();
--                                break;
--                            }
--                        } else
--                            main.warn(wp.getPlayer(), inf.getHolder() + " is holding your team's flag. You cannot capture!");
--                    }
--                }
--            }
--        else if (instantBreak) {
--            if (event.getAction() == Action.LEFT_CLICK_BLOCK) {
--                checkBreak(wp, event.getClickedBlock());
--            }
--        }
--    }
--
--    /**
--     * Checks if a block broken was a flag.
--     * This also applies to instant capture mode.
--     *
--     * @param wp     The player who broke a block.
--     * @param broken The block broken.
--     * @return Whether the event needs to be cancelled or not.
--     */
--    private boolean checkBreak(WarPlayer wp, Block broken) {
--        if (!wp.isPlaying()) return false;
--        for (CTFInfo inf : info.values()) { // For every team's flag..
--            if (inf.flag.equals(broken.getLocation())) { // Did they break a flag?
--                if (capture.containsKey(wp.getName())) {
--                    // Are they already holding a flag?
--                    main.warn(wp.getPlayer(), "You can't steal more than one flag at once!");
--                    return true;
--                }
--                if (wp.getCurrentTeam().getTeamName().equals(inf.target.getTeamName())) {
--                    // Are they trying to steal their own flag?
--                    main.warn(wp.getPlayer(), "You can't steal your own flag! Defend it!");
--                    return true;
--                }
--                // Otherwise,
--                inf.setHolder(wp.getName()); // Set the holder as this player.
--
--                capture.put(wp.getName(), inf.target.getTeamColor() + inf.target.getTeamName()); // Register the player as a flag holder.
--                info.get(wp.getCurrentTeam().getTeamName()).addAttempt(); // Record the steal as an attempt.
--
--                Bukkit.broadcastMessage(wp.getDisplayName() + " has stolen " + inf.getTeam().getDisplayName() + "'s flag!"); // Broadcast it!
--                logEvent(wp.getDisplayName() + " has stolen " + inf.getTeam().getDisplayName() + "'s flag"); // Log the steal.
--
--                for (Player target : Bukkit.getOnlinePlayers())
--                    target.playSound(target.getLocation(), Sound.ENTITY_ARROW_HIT, 1F, 1F); // Play a sound effect.
--                broken.setType(Material.BEDROCK); // Turn it to bedrock so it can't be broken.
--                updateScoreboard(); // Update the scoreboard.
--                return true;
--            }
--        }
--        return false;
--    }
--
--    @EventHandler
--    public void onPickup(EntityPickupItemEvent event) {
--        if (event.getItem().getItemStack().getType() == Material.WOOL) {
--            // Don't allow wool to be picked up.
--            event.setCancelled(true);
--            event.getItem().remove();
--        }
--    }
--
--    @Override
--    public HashMap<String, Object> getExtraTeamData(WarTeam team) {
--        HashMap<String, Object> extra = new HashMap<>();
--        extra.put("Flag Captures", info.get(team.getTeamName()).getCaptures());
--        extra.put("Flag Steals", info.get(team.getTeamName()).getAttempts());
--        return extra;
--    }
--
--    /**
--     * Private record to hold a list of CTF information for a team.
--     * This class holds:
--     * -> The team associated with it.
--     * -> The location of their flag.
--     * -> The holder of their flag, if any.
--     * -> The amount of captures they've made.
--     * -> The amount of flag steals they've made.
--     */
--    private class CTFInfo {
--        final WarTeam target;
--        final Location flag;
--        String holder;
--        int captures;
--        int attempts;
--
--        CTFInfo(WarTeam target) {
--            this.target = target;
--            flag = ((HashMap<String, SerializedLocation>) map().attr().get("flags")).get(target.getTeamName()).toLocation(main.match().getCurrentWorld(), false);
--            holder = null;
--            captures = 0;
--            attempts = 0;
--        }
--
--        void addCapture() {
--            captures++;
--        }
--
--        int getCaptures() {
--            return captures;
--        }
--
--        void addAttempt() {
--            attempts++;
--        }
--
--        int getAttempts() {
--            return attempts;
--        }
--
--        WarTeam getTeam() {
--            return target;
--        }
--
--        String getHolder() {
--            return holder;
--        }
--
--        void setHolder(String holder) {
--            this.holder = holder;
--        }
--
--        Location getFlag() {
--            return flag;
--        }
--    }
--}
-\ No newline at end of file
-diff --git a/src/au/edu/swin/war/game/modes/DDM.java b/src/au/edu/swin/war/game/modes/DDM.java
-deleted file mode 100644
-index eea6c4d..0000000
---- a/src/au/edu/swin/war/game/modes/DDM.java
-+++ /dev/null
-@@ -1,254 +0,0 @@
--package au.edu.swin.war.game.modes;
--
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.stored.Activatable;
--import au.edu.swin.war.framework.util.WarManager;
--import au.edu.swin.war.game.Gamemode;
--import org.bukkit.Bukkit;
--import org.bukkit.GameMode;
--import org.bukkit.Location;
--import org.bukkit.Sound;
--import org.bukkit.entity.Player;
--import org.bukkit.event.EventHandler;
--import org.bukkit.event.HandlerList;
--import org.bukkit.event.Listener;
--import org.bukkit.event.player.PlayerMoveEvent;
--import org.bukkit.scoreboard.DisplaySlot;
--import org.bukkit.scoreboard.Objective;
--
--import java.util.ArrayList;
--import java.util.HashMap;
--import java.util.Iterator;
--import java.util.Random;
--
--/**
-- * An extension to gamemode to implement DDM.
-- * District Death Match objectives have been defined
-- * in my design brief, so I will assume you
-- * know what you are expecting to look at here.
-- *
-- * @author s101601828 @ Swin.
-- * @version 1.0
-- * @see WarManager
-- * <p>
-- * Created by Josh on 26/04/2017.
-- * @since 1.0
-- */
--public class DDM extends Gamemode {
--
--    private HashMap<String, Integer> scores; // Keeps the team's scores.
--
--    public void reset() {
--        if (scores != null)
--            scores.clear();
--        scores = null;
--    }
--
--    public void initialize() {
--        scores = new HashMap<>(); // Initialize key/value set for scores.
--
--        for (WarTeam team : getTeams()) // For every team, assign their scores to 3 x the amount of players online.
--            scores.put(team.getTeamName(), Bukkit.getOnlinePlayers().size() * 3);
--
--        autoAssign();
--
--        // Assign objective to scoreboard for this gamemode.
--        Objective obj = s().registerNewObjective("gm", "dummy");
--        obj.setDisplaySlot(DisplaySlot.SIDEBAR); // Display it in sidebar. Pretty.
--        updateScoreboard(); // Update the scoreboard to put all the default values on it.
--
--        for (Player online : Bukkit.getOnlinePlayers())
--            online.setScoreboard(s()); // Everyone online needs to see this scoreboard.
--    }
--
--    public void tick() {
--        //Nothing needed here.
--    }
--
--    public void onKill(WarPlayer killed, WarPlayer killer) {
--    }
--
--    public void onDeath(WarPlayer killed) {
--    }
--
--    public void onLeave(WarPlayer left) {
--        //Nothing happens when a player leaves on DDM.
--    }
--
--    public String getOffensive() {
--        return "Run into the enemy's \"territory\" to score a lot of points!";
--    }
--
--    public String getDefensive() {
--        return "Stop the enemy from getting into your \"territory\"!";
--    }
--
--    public String getFullName() {
--        return "District Death Match";
--    }
--
--    public String getName() {
--        return "DDM";
--    }
--
--    public String getGrammar() {
--        return "a";
--    }
--
--    public void decideWinner() {
--        int lowest = 999; // Lowest is higher than 80 x 3 since teams start off as 3 x the amount of players.
--        ArrayList<WarTeam> winners = new ArrayList<>(); // Keep a temporary list of winners.
--
--        for (WarTeam team : getTeams()) {
--            // For each team, check their scores.
--            int count = scores.get(team.getTeamName());
--            if (count == lowest)
--                // If they're equal to the current lowest points, add them to the list of winners.
--                winners.add(team);
--            else if (count < lowest) {
--                // If they're below the current lowest points,
--                // lowezt the new lowest points,
--                lowest = count;
--                // Clear the current list of winners as they have more points than this team,
--                winners.clear();
--                // Then add this team to the list of winners.
--                winners.add(team);
--            }
--        }
--        broadcastWinner(winners, "run-ins remaining", lowest);
--    }
--
--    public void updateScoreboard() {
--        // Get the "objective" on the scoreboard, where data goes.
--        Objective obj = s().getObjective(DisplaySlot.SIDEBAR);
--
--        // The title of the scoreboard, which displays the map and gamemode playing this match.
--        String dp = map().getMapName() + " (" + getName() + ")";
--        if (dp.length() > 32) dp = dp.substring(0, 32); // Titles cannot be longer than 32 characters.
--        obj.setDisplayName(dp); // Set the title of the scoreboard.
--        obj.setDisplaySlot(DisplaySlot.SIDEBAR); // Ensure it is on the sidebar.
--
--        // Format it pretty for the players.
--        obj.getScore(" ").setScore(scores.size() + 2); // Top spacer.
--        obj.getScore("  Run-ins Remaining").setScore(scores.size() + 1); // 'Points' denoter.
--
--        Iterator<WarTeam> iterator = getTeams().iterator(); // An iterator to iterate through the teams.
--        for (int i = 0; i < getTeams().size(); i++) { // Only iterate the number of teams needed.
--            // For each team, display their their points colored respectively.
--            WarTeam target = iterator.next(); // Get the next team to be iterated.
--            // Set the new score value.
--            obj.getScore(target.getTeamColor() + "    " + scores.get(target.getTeamName())).setScore(i + 1);
--            // Remove the old value from the board since it is not needed.
--            s().resetScores(target.getTeamColor() + "    " + (scores.get(target.getTeamName()) + 1));
--        }
--        obj.getScore("  ").setScore(0); // Bottom spacer.
--    }
--
--    @Override
--    protected HashMap<String, Object> getExtraTeamData(WarTeam team) {
--        HashMap<String, Object> extra = new HashMap<>();
--        extra.put("Remaining Score", scores.get(team.getTeamName()));
--        return extra;
--    }
--
--    /**
--     * A territory is a cuboid, in which if an
--     * opposing player runs into, scores a lot
--     * of points for their team on DDM. Alongside
--     * killing enemy players, they must also
--     * protect their territory from being entered.
--     */
--    public static class Territory implements Listener, Activatable {
--        final int x1;
--        final int y1;
--        final int z1;
--        final int x2;
--        final int y2;
--        final int z2;
--        final String belongsTo;
--        final WarManager main;
--
--        public Territory(int x1, int y1, int z1, int x2, int y2, int z2, WarTeam belongsTo, WarManager main) {
--            // Defines the bottom-left and top-right regions of this cuboid.
--            this.x1 = Math.min(x1, x2);
--            this.y1 = Math.min(y1, y2);
--            this.z1 = Math.min(z1, z2);
--            this.x2 = Math.max(x1, x2);
--            this.y2 = Math.max(y1, y2);
--            this.z2 = Math.max(z1, z2);
--            this.belongsTo = belongsTo.getDisplayName(); // Who does this territory belong to?
--            this.main = main;
--        }
--
--        /**
--         * Awaken this Territory Cuboid for the match.
--         */
--        public void activate() {
--            if (!main.match().getCurrentMode().getFullName().equals("District Death Match"))
--                // Don't enable if DDM isn't being played.
--                return;
--
--            main.plugin().getServer().getPluginManager().registerEvents(this, main.plugin());
--        }
--
--        /**
--         * Put this Territory Cuboid to sleep until it is needed again.
--         */
--        public void deactivate() {
--            HandlerList.unregisterAll(this);
--        }
--
--        /**
--         * Checks if a location is inside the cuboid.
--         * This is used to check if a player has entered
--         * this territory and needs to be acted upon.
--         *
--         * @param loc The location to compare.
--         * @return Are they inside the territory?
--         */
--        boolean isInside(Location loc) {
--            return loc.getBlockX() >= x1 && loc.getBlockX() <= x2 && loc.getBlockY() >= y1 && loc.getBlockY() <= y2 && loc.getBlockZ() >= z1 && loc.getBlockZ() <= z2;
--        }
--
--        @EventHandler
--        public void nmv(PlayerMoveEvent event) {
--            if (isInside(event.getTo()) && !event.getPlayer().isDead()) { // Are they inside the territory?t
--                if (!event.getPlayer().getGameMode().equals(GameMode.SURVIVAL)) return; // Are they in survival mode?
--                WarPlayer wp = main.getWarPlayer(event.getPlayer()); // Get their WarPlayer implement.
--                if (wp.getCurrentTeam() == null) return; // Cancel if they aren't on any team.
--
--                WarTeam target = wp.getCurrentTeam(); // Get their current team otherwise!
--                if (!target.getDisplayName().equals(belongsTo)) { // Is this not their own territory?
--                    DDM ddm = (DDM) main.cache().getGamemode("District Death Match"); // Get the running instance of DDM again.
--                    for (WarPlayer wp2 : main.getWarPlayers().values()) { // Loop through each player.
--                        if (wp2.getCurrentTeam() == null) continue; // Ignore if they're not on a team.
--                        if (!wp2.getCurrentTeam().getTeamName().equals(target.getTeamName())) // Play a bad sound effect.
--                            wp2.getPlayer().playSound(wp2.getPlayer().getLocation(), Sound.ENTITY_GHAST_SCREAM, 1F, 1F);
--                        else // Play a good sound effect!
--                            wp2.getPlayer().playSound(wp2.getPlayer().getLocation(), Sound.ENTITY_PLAYER_LEVELUP, 1F, 1F);
--                    }
--
--                    // Broadcast that they got in.
--                    Bukkit.broadcastMessage(wp.getDisplayName() + " scored a point");
--                    ddm.logEvent(wp.getDisplayName() + " scored a point");
--
--                    // Record their current captures remaining, and decrement it.
--                    int capsToGo = ddm.scores.get(target.getTeamName());
--                    ddm.scores.put(target.getTeamName(), capsToGo - 1);
--
--                    ddm.updateScoreboard(); // Update the scoreboard.
--                    if (capsToGo == 1) // Is this their last capture?
--                        ddm.onEnd(); // End the match.
--                    else // Other teleport the player back to a random spawn.
--                        event.setTo(ddm.map().getTeamSpawns(target.getTeamName()).get(new Random().nextInt(ddm
--                                .map().getTeamSpawns(target.getTeamName()).size())).toLocation(main.match().getCurrentWorld(), true));
--                } else {
--                    main.warn(event.getPlayer(), "You're supposed to stop the enemy from getting into here!");
--                    event.setTo(event.getFrom());
--                }
--            }
--        }
--
--    }
--}
-\ No newline at end of file
-diff --git a/src/au/edu/swin/war/game/modes/FFA.java b/src/au/edu/swin/war/game/modes/FFA.java
-deleted file mode 100644
-index 96bf7b7..0000000
---- a/src/au/edu/swin/war/game/modes/FFA.java
-+++ /dev/null
-@@ -1,191 +0,0 @@
--package au.edu.swin.war.game.modes;
--
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.util.WarManager;
--import au.edu.swin.war.game.Gamemode;
--import org.bukkit.Bukkit;
--import org.bukkit.ChatColor;
--import org.bukkit.entity.Player;
--import org.bukkit.scoreboard.DisplaySlot;
--import org.bukkit.scoreboard.Objective;
--
--import java.util.ArrayList;
--import java.util.HashMap;
--import java.util.Map;
--import java.util.UUID;
--
--/**
-- * An extension to gamemode to implement FFA.
-- * Free For All objectives have been defined
-- * in my design brief, so I will assume you
-- * know what you are expecting to look at here.
-- *
-- * @author s101601828 @ Swin.
-- * @version 1.0
-- * @see WarManager
-- * <p>
-- * Created by Josh on 26/04/2017.
-- * @since 1.0
-- */
--public class FFA extends Gamemode {
--
--    private HashMap<UUID, Integer> kills;
--    private int leadKills;
--    private UUID leader;
--
--    public void reset() {
--        kills.clear();
--        kills = null;
--    }
--
--    public void initialize() {
--        kills = new HashMap<>();
--
--        for (WarTeam team : getTeams()) // Since this is FFA, allow friendly fire.
--            team.getBukkitTeam().setAllowFriendlyFire(true);
--
--        leadKills = 0; // Set the leader's kills to 0.
--
--        autoAssign();
--
--        // Assign objective to scoreboard for this gamemode.
--        Objective obj = s().registerNewObjective("gm", "dummy");
--        obj.setDisplaySlot(DisplaySlot.SIDEBAR); // Display it in sidebar. Pretty.
--        updateScoreboard(); // Update the scoreboard to put all the default values on it.
--
--        for (Player online : Bukkit.getOnlinePlayers())
--            online.setScoreboard(s()); // Everyone online needs to see this scoreboard.
--    }
--
--    public void tick() {
--        //Nothing needed here.
--    }
--
--    public void onKill(WarPlayer killed, WarPlayer killer) {
--        if (kills.containsKey(killer.getPlayer().getUniqueId()))
--            kills.put(killer.getPlayer().getUniqueId(), kills.get(killer.getPlayer().getUniqueId()) + 1); // Increment their amount of kills.
--        else
--            kills.put(killer.getPlayer().getUniqueId(), 1); // Otherwise give them a starter count of 1.
--        int cKills = kills.get(killer.getPlayer().getUniqueId());
--        if (cKills > leadKills) {
--            leadKills = cKills; // This is now the highest amount of kills.
--            if (!killer.getPlayer().getUniqueId().equals(leader)) { // Is this not the same leader?
--                leader = killer.getPlayer().getUniqueId(); // New leader!
--                // Broadcast and log that a new leader has taken over.
--                Bukkit.broadcastMessage(killer.getDisplayName() + " is now the leader");
--                logEvent(killer.getDisplayName() + " is now the leader");
--            }
--        }
--        killer.sendMessage("You now have " + cKills + "/" + getFFAKills() + " kills");
--        updateScoreboard();
--        checkWin(killer.getPlayer().getUniqueId());
--    }
--
--    public void onDeath(WarPlayer dead) {
--        // Nothing happens when a player dies independent of a killer on FFA.
--    }
--
--    public void decideWinner() {
--        int highest = -1; // Highest is lower than zero since teams start off as zero.
--        ArrayList<String> winners = new ArrayList<>(); // Keep a temporary list of winners.
--
--        for (Map.Entry<UUID, Integer> entry : kills.entrySet()) {
--            WarPlayer found = main.getWarPlayer(entry.getKey()); // Get their WarPlayer implement.
--            if (found == null) continue; // If they're not online, they aren't counted here.
--            // For each player, check their kills.
--            int count = entry.getValue();
--            if (count == highest)
--                // If they're equal to the current highest points, add them to the list of winners.
--                winners.add(found.getDisplayName());
--            else if (count > highest) {
--                // If they're above the current highest points,
--                // Set the new highst points,
--                highest = count;
--                // Clear the current list of winners as they have less points than this player,
--                winners.clear();
--                // Then add this player to the list of winners.
--                winners.add(found.getDisplayName());
--            }
--        }
--
--        // Is there more than one winner?
--        if (winners.size() > 1) {
--            Bukkit.broadcastMessage("It's a " + winners.size() + "-way tie! " + main.strings().sentenceFormat(winners) + " tied!");
--            tempWinner = main.strings().sentenceFormat(winners);
--        } else if (winners.size() == 1) {
--            String winner = winners.get(0); // Get the singleton winner!
--            Bukkit.broadcastMessage(winner + ChatColor.WHITE + " is the winner with " + highest + " points!");
--            tempWinner = main.strings().sentenceFormat(winners);
--        }
--    }
--
--    public String getOffensive() {
--        return "Kill players to score points for yourself!";
--    }
--
--    public String getDefensive() {
--        return "Don't let other players kill you!";
--    }
--
--    public String getFullName() {
--        return "Free For All";
--    }
--
--    public String getName() {
--        return "FFA";
--    }
--
--    public String getGrammar() {
--        return "an";
--    }
--
--    public void onLeave(WarPlayer left) {
--        //Nothing happens when a player leaves on FFA.
--    }
--
--    public void updateScoreboard() {
--        // Get the "objective" on the scoreboard, where data goes.
--        Objective obj = s().getObjective(DisplaySlot.SIDEBAR);
--
--        // The title of the scoreboard, which displays the map and gamemode playing this match.
--        String dp = map().getMapName() + " (" + getName() + ")";
--        if (dp.length() > 32) dp = dp.substring(0, 32); // Titles cannot be longer than 32 characters.
--        obj.setDisplayName(dp); // Set the title of the scoreboard.
--        obj.setDisplaySlot(DisplaySlot.SIDEBAR); // Ensure it is on the sidebar.
--
--        obj.getScore(" ").setScore(3); // Top spacer.
--        obj.getScore("  Leader's Kills").setScore(2); // A label!
--        obj.getScore("    " + leadKills + "/" + getFFAKills()).setScore(1); // The leader's kills.
--        obj.getScore("  ").setScore(0); // Bottom spacer.
--        s().resetScores("    " + (leadKills - 1) + "/" + getFFAKills()); // Reset old score.
--
--    }
--
--    /**
--     * If the player reaches the kill cap, this
--     * procedure will automatically end the round.
--     *
--     * @param player Player to check.
--     */
--    private void checkWin(UUID player) {
--        if (kills.get(player) >= getFFAKills())
--            onEnd();
--    }
--
--    /**
--     * Returns the map's defined score cap for FFA.
--     * By default, this score cap is set to 20.
--     *
--     * @return FFA score cap.
--     */
--    private Integer getFFAKills() {
--        return (Integer) map().attr().get("ffaKills");
--    }
--
--    @Override
--    public HashMap<String, Object> getExtraTeamData(WarTeam team) {
--        // FFAs do not contain any additional team data to display.
--        return new HashMap<>();
--    }
--}
-diff --git a/src/au/edu/swin/war/game/modes/KoTH.java b/src/au/edu/swin/war/game/modes/KoTH.java
-deleted file mode 100644
-index da38218..0000000
---- a/src/au/edu/swin/war/game/modes/KoTH.java
-+++ /dev/null
-@@ -1,245 +0,0 @@
--package au.edu.swin.war.game.modes;
--
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.stored.SerializedLocation;
--import au.edu.swin.war.framework.util.WarManager;
--import au.edu.swin.war.game.Gamemode;
--import au.edu.swin.war.util.Manager;
--import au.edu.swin.war.util.WoolColor;
--import org.bukkit.*;
--import org.bukkit.entity.Player;
--import org.bukkit.event.EventHandler;
--import org.bukkit.event.block.BlockBreakEvent;
--import org.bukkit.event.entity.EntityExplodeEvent;
--import org.bukkit.event.player.PlayerPickupItemEvent;
--import org.bukkit.scoreboard.DisplaySlot;
--import org.bukkit.scoreboard.Objective;
--
--import java.util.ArrayList;
--import java.util.HashMap;
--import java.util.Iterator;
--
--/**
-- * An extension to gamemode to implement KoTH.
-- * King of The Hill objectives have been defined
-- * in my design brief, so I will assume you
-- * know what you are expecting to look at here.
-- *
-- * @author s101601828 @ Swin.
-- * @version 1.0
-- * @see WarManager
-- * <p>
-- * Created by Josh on 23/04/2017.
-- * @since 1.0
-- */
--public class KoTH extends Gamemode {
--
--    private WarTeam holder; // The current team holding the flag. Null if there is no team.
--    private HashMap<String, Integer> captureTime; // The capture time remaining for each team.
--    private HashMap<String, Integer> captures; // The amount of captures made by each team.
--    private Location flag; // The block location of the flag.
--    private int interval; // Interval at which fireworks shoot from the flag.
--
--    public void reset() {
--        flag = null;
--        holder = null;
--        if (captureTime != null)
--            captureTime.clear();
--        captureTime = null;
--    }
--
--    public void initialize() {
--        interval = 1; // Reset the interval if applicable.
--        captureTime = new HashMap<>();
--        captures = new HashMap<>();
--        flag = ((SerializedLocation) map().attr().get("kothFlag")).toLocation(main.match().getCurrentWorld(), false);
--
--        for (WarTeam team : getTeams()) { // Give every participating team default values.
--            captureTime.put(team.getTeamName(), (Integer) map().attr().get("captureTime"));
--            captures.put(team.getTeamName(), 0);
--        }
--
--        // Defines the block at which the flag is located.
--        main.match().getCurrentWorld().getBlockAt(flag).setType(Material.WOOL);
--
--        autoAssign();
--
--        // Assign objective to scoreboard for this gamemode.
--        Objective obj = s().registerNewObjective("gm", "dummy");
--        obj.setDisplaySlot(DisplaySlot.SIDEBAR); // Display it in sidebar. Pretty.
--        updateScoreboard(); // Update the scoreboard to put all the default values on it.
--
--        for (Player online : Bukkit.getOnlinePlayers())
--            online.setScoreboard(s()); // Everyone online needs to see this scoreboard.
--    }
--
--    public void tick() {
--        // This is all called every second.
--        if (holder != null) {
--            int holdTime = captureTime.get(holder.getTeamName()); // Get the team's current hold time.
--            captureTime.put(holder.getTeamName(), holdTime - 1); // Subtract by 1 and push back into key/value set.
--            updateScoreboard(); // Update the scoreboard!
--            holdTime--; // Subtract the holdTime field we just made.
--            if (holdTime == 5) {
--                logEvent(holder.getDisplayName() + " will win in 5 seconds!"); // Log event.
--                Bukkit.broadcastMessage(holder.getDisplayName() + " will win in 5 seconds!"); // They're gonna win!
--            } else if (holdTime == 0) {
--                // They won.
--                onEnd();
--                return;
--            }
--        }
--        interval--;
--        if (interval == 0) {
--            // Do a firework every 4 seconds.
--            interval = 4;
--            doFireworks();
--        }
--    }
--
--    public void onKill(WarPlayer killed, WarPlayer killer) {
--        // Unneeded in this gamemode.
--    }
--
--    public void onLeave(WarPlayer left) {
--        // Unneeded in this gamemode.
--    }
--
--    public void onDeath(WarPlayer killed) {
--        // Unneeded in this gamemode.
--    }
--
--    public void decideWinner() {
--        int lowest = 999; // Lowest is higher than the initial time.
--        ArrayList<WarTeam> winners = new ArrayList<>(); // Keep a temporary list of winners.
--
--        for (WarTeam team : getTeams()) {
--            // For each team, check their capture time.
--            int time = captureTime.get(team.getTeamName());
--            if (time == lowest)
--                // If they're equal to the current lowest time, add them to the list of winners.
--                winners.add(team);
--            else if (time < lowest) {
--                // If they're above the current lowest time,
--                // Set the new lowest time,
--                lowest = time;
--                // Clear the current list of winners as they have more time than this team,
--                winners.clear();
--                // Then add this team to the list of winners.
--                winners.add(team);
--            }
--        }
--        broadcastWinner(winners, "seconds remaining", lowest);
--    }
--
--    /**
--     * KoTH-specific procedure to spawn a firework at the flag.
--     * If no one is holding it, spawn a white firework.
--     * If a team is holding it, spawn a holding-team-colored firework.
--     */
--    private void doFireworks() {
--        if (holder == null) // Spawn white.
--            ((Manager) main).entity().spawnFirework(flag.clone().add(0.5, 1, 0.5), ChatColor.WHITE);
--        else // Spawn team-colored.
--            ((Manager) main).entity().spawnFirework(flag.clone().add(0.5, 1, 0.5), holder.getTeamColor());
--    }
--
--    public void updateScoreboard() {
--        // Get the "objective" on the scoreboard, where data goes.
--        Objective obj = s().getObjective(DisplaySlot.SIDEBAR);
--
--        // The title of the scoreboard, which displays the map and gamemode playing this match.
--        String dp = map().getMapName() + " (" + getName() + ")";
--        if (dp.length() > 32) dp = dp.substring(0, 32); // Titles cannot be longer than 32 characters.
--        obj.setDisplayName(dp); // Set the title of the scoreboard.
--        obj.setDisplaySlot(DisplaySlot.SIDEBAR); // Ensure it is on the sidebar.
--
--        // Format it pretty for the players.
--        obj.getScore(" ").setScore(captureTime.size() + 2); // Top spacer.
--        obj.getScore("  Time Remaining").setScore(captureTime.size() + 1); // 'Points' denoter.
--
--        Iterator<WarTeam> iterator = getTeams().iterator(); // An iterator to iterate through the teams.
--        for (int i = 0; i < captureTime.size(); i++) { // Only iterate the number of teams needed.
--            // For each team, display their their times colored respectively.
--            WarTeam target = iterator.next(); // Get the next team to be iterated.
--            // Set the new score value.
--            obj.getScore(target.getTeamColor() + "    " + main.strings().getDigitalTime(captureTime.get(target.getTeamName()))).setScore(i + 1);
--            // Remove the old value from the board since it is not needed.
--            s().resetScores(target.getTeamColor() + "    " + main.strings().getDigitalTime(captureTime.get(target.getTeamName()) + 1));
--        }
--        obj.getScore("  ").setScore(0); // Bottom spacer.
--    }
--
--    public String getOffensive() {
--        return "Break the wool in the middle of the map to control the flag!";
--    }
--
--    public String getDefensive() {
--        return "Stop the enemy from controlling the flag if you have control!";
--    }
--
--    public String getFullName() {
--        return "King of The Hill";
--    }
--
--    public String getName() {
--        return "KoTH";
--    }
--
--    public String getGrammar() {
--        return "a";
--    }
--
--    @EventHandler
--    public void onBreak(BlockBreakEvent event) {
--        WarPlayer wp = main.getWarPlayer(event.getPlayer()); // Get their WarPlayer implement.
--        if (event.getBlock().getLocation().equals(flag)) { // Did they berak the flag?
--            event.setCancelled(true); // Cancel the breaking of the flag.
--            WarTeam target = wp.getCurrentTeam(); // Get their team.
--            if (target == null) return; // Was it a spectator?
--            if (holder == target) // Are they already in control of the flag?
--                wp.getPlayer().sendMessage("You already have control of the flag!");
--            else {
--                Bukkit.broadcastMessage(wp.getDisplayName() + " took the flag for " + target.getDisplayName() + "!");
--                // Log first capture and additional captures!
--                if (holder == null)
--                    logEvent(wp.getDisplayName() + " captured the flag first!");
--                else
--                    logEvent(wp.getDisplayName() + " captured the flag for " + target.getDisplayName());
--                holder = target; // Broadcast the taking of the flag and reflect the change.
--
--                for (Player online : Bukkit.getOnlinePlayers())
--                    online.playSound(online.getLocation(), Sound.ENTITY_ENDERDRAGON_HURT, 1F, 1F); // Play a sound effect.
--                updateScoreboard(); // Update the scoreboard.
--                captures.put(target.getTeamName(), captures.get(target.getTeamName()) + 1); // Increment captures.
--
--                // Update the wool.
--                event.getBlock().getLocation().getBlock().setType(Material.WOOL);
--                event.getBlock().getLocation().getBlock().setData(WoolColor.fromChatColor(target.getTeamColor()).getColor());
--            }
--        }
--    }
--
--    @EventHandler
--    public void onExplode(EntityExplodeEvent event) {
--        // Don't allow the flag to be exploded.
--        event.blockList().remove(flag.getBlock());
--    }
--
--    @EventHandler
--    public void onPickup(PlayerPickupItemEvent event) {
--        if (event.getItem().getItemStack().getType() == Material.WOOL) {
--            event.setCancelled(true);
--            event.getItem().remove();
--        }
--    }
--
--    @Override
--    public HashMap<String, Object> getExtraTeamData(WarTeam team) {
--        HashMap<String, Object> extra = new HashMap<>();
--        extra.put("Capture Time", main.strings().getDigitalTime(captureTime.get(team.getTeamName())));
--        extra.put("Flag Captures", captures.get(team.getTeamName()));
--        return extra;
--    }
--}
-\ No newline at end of file
-diff --git a/src/au/edu/swin/war/game/modes/LMS.java b/src/au/edu/swin/war/game/modes/LMS.java
-deleted file mode 100644
-index dfc3a58..0000000
---- a/src/au/edu/swin/war/game/modes/LMS.java
-+++ /dev/null
-@@ -1,211 +0,0 @@
--package au.edu.swin.war.game.modes;
--
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.util.WarManager;
--import au.edu.swin.war.game.Gamemode;
--import org.bukkit.Bukkit;
--import org.bukkit.entity.Player;
--import org.bukkit.event.EventHandler;
--import org.bukkit.event.player.PlayerToggleSneakEvent;
--import org.bukkit.scoreboard.DisplaySlot;
--import org.bukkit.scoreboard.Objective;
--
--import java.util.ArrayList;
--import java.util.HashMap;
--import java.util.UUID;
--
--/**
-- * An extension to gamemode to implement LMS.
-- * Last Man Standing objectives have been defined
-- * in my design brief, so I will assume you
-- * know what you are expecting to look at here.
-- *
-- * @author s101601828 @ Swin.
-- * @version 1.0
-- * @see WarManager
-- * <p>
-- * Created by Josh on 26/04/2017.
-- * @since 1.0
-- */
--public class LMS extends Gamemode {
--
--    private ArrayList<UUID> participated; // Keep a list of people who participated.
--    private ArrayList<UUID> alive; // Who is currently alive in the match?
--
--    public void reset() {
--        if (participated != null)
--            while (participated.size() > 0) {
--                WarPlayer wp = main.getWarPlayer(participated.get(0));
--                if (wp != null)
--                    wp.setJoined(true); // Re-set this player as joined, since they participated.
--                participated.remove(participated.get(0)); // We can remove this player from the list now.
--            }
--        participated = null; // Remove instance of this list.
--
--        // Clear and reset the list of alive players.
--        if (alive != null)
--            alive.clear();
--        alive = null;
--    }
--
--    public void initialize() {
--        // Initialize array lists first!
--        alive = new ArrayList<>();
--        participated = new ArrayList<>();
--
--        if (getJoined() < 2) {
--            // LMS requires 2 players at the least to play.
--            Bukkit.broadcastMessage("There needs to be 2 or more participating players!");
--            logEvent("Match cancelled as there was not enough players");
--            onEnd();
--            return;
--        }
--
--        for (WarTeam team : getTeams()) // Since this is LMS, allow friendly fire.
--            team.getBukkitTeam().setAllowFriendlyFire(true);
--
--        autoAssign();
--
--        // Mark playing players are participated.
--        for (WarPlayer check : main.getWarPlayers().values())
--            if (check.isPlaying()) {
--                alive.add(check.getPlayer().getUniqueId());
--                participated.add(check.getPlayer().getUniqueId());
--            }
--
--        permaDeath = true; // Set permanent death to true for the duration of the match.
--
--        // Assign objective to scoreboard for this gamemode.
--        Objective obj = s().registerNewObjective("gm", "dummy");
--        obj.setDisplaySlot(DisplaySlot.SIDEBAR); // Display it in sidebar. Pretty.
--        updateScoreboard(); // Update the scoreboard to put all the default values on it.
--
--        for (Player online : Bukkit.getOnlinePlayers())
--            online.setScoreboard(s()); // Everyone online needs to see this scoreboard.
--    }
--
--    public void tick() {
--        //Nothing needed here.
--    }
--
--    public void onKill(WarPlayer killed, WarPlayer killer) {
--        dead(killed);
--    }
--
--    public void onDeath(WarPlayer dead) {
--        dead(dead);
--    }
--
--    /**
--     * Common code is shared by onKill and onDeath,
--     * both call to this procedure to prevent duplication.
--     *
--     * @param dead The player who died.
--     */
--    private void dead(WarPlayer dead) {
--        // Remove their state as 'alive'.
--        alive.remove(dead.getPlayer().getUniqueId());
--
--        // Update scoreboard
--        updateScoreboard();
--
--        // Kick them out of the match as this is permanent death.
--        dead.setJoined(false);
--        entryHandle(dead);
--
--        checkWin();
--    }
--
--    public void decideWinner() {
--        if (alive.size() == 1) {
--            WarPlayer winner = main.getWarPlayer(alive.get(0)); // Get the only player in the array.
--            if (winner != null) {
--                tempWinner = winner.getDisplayName();
--                Bukkit.broadcastMessage(winner.getDisplayName() + " is the last man standing!");
--                return;
--            }
--        }
--        Bukkit.broadcastMessage("There was no winner this match!");
--        tempWinner = "No one";
--    }
--
--    public String getOffensive() {
--        return "Kill other players!";
--    }
--
--    public String getDefensive() {
--        return "Don't get yourself killed!";
--    }
--
--    public String getFullName() {
--        return "Last Man Standing";
--    }
--
--    public String getName() {
--        return "LMS";
--    }
--
--    public String getGrammar() {
--        return "an";
--    }
--
--    public void onLeave(WarPlayer left) {
--        // If they died, we should not re-remove them as this is pointless.
--        // They are forced to leave if they die.
--        if (!alive.contains(left.getPlayer().getUniqueId())) return;
--
--        alive.remove(left.getPlayer().getUniqueId()); // They left, so they're no longer alive.
--
--        // Do the usual stuff!
--        updateScoreboard();
--        checkWin();
--    }
--
--    public void updateScoreboard() {
--        // Get the "objective" on the scoreboard, where data goes.
--        Objective obj = s().getObjective(DisplaySlot.SIDEBAR);
--
--        // The title of the scoreboard, which displays the map and gamemode playing this match.
--        String dp = map().getMapName() + " (" + getName() + ")";
--        if (dp.length() > 32) dp = dp.substring(0, 32); // Titles cannot be longer than 32 characters.
--        obj.setDisplayName(dp); // Set the title of the scoreboard.
--        obj.setDisplaySlot(DisplaySlot.SIDEBAR); // Ensure it is on the sidebar.
--
--        obj.getScore(" ").setScore(3); // Top spacer.
--        obj.getScore("  Still Standing").setScore(2); // A label!
--        obj.getScore("    " + alive.size() + "/" + participated.size()).setScore(1); // The amount of standing players!
--        obj.getScore("  ").setScore(0); // Bottom spacer.
--        s().resetScores("    " + (alive.size() + 1) + "/" + participated.size()); // Reset old score.
--
--    }
--
--    /**
--     * If there is 1 or less players remaining,
--     * the match is over since it is a last man
--     * standing match.
--     */
--    private void checkWin() {
--        if (alive.size() <= 1 && active)  // Make sure this can only be called once a true round ends.
--            onEnd();
--    }
--
--    /**
--     * Sneaking is a strategy often used to hide
--     * on maps, so sneaking will not allow you to
--     * hide your name tag behind walls.
--     *
--     * @param event An event called by Spigot.
--     */
--    @EventHandler
--    public void onSneak(PlayerToggleSneakEvent event) {
--        event.setCancelled(true);
--    }
--
--    @Override
--    public HashMap<String, Object> getExtraTeamData(WarTeam team) {
--        HashMap<String, Object> extra = new HashMap<>();
--        extra.put("Participants", participated.size());
--        return extra;
--    }
--}
-diff --git a/src/au/edu/swin/war/game/modes/LP.java b/src/au/edu/swin/war/game/modes/LP.java
-deleted file mode 100644
-index 9241841..0000000
---- a/src/au/edu/swin/war/game/modes/LP.java
-+++ /dev/null
-@@ -1,169 +0,0 @@
--package au.edu.swin.war.game.modes;
--
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.util.WarManager;
--import au.edu.swin.war.game.Gamemode;
--import org.bukkit.Bukkit;
--import org.bukkit.entity.Player;
--import org.bukkit.scoreboard.DisplaySlot;
--import org.bukkit.scoreboard.Objective;
--
--import java.util.ArrayList;
--import java.util.HashMap;
--import java.util.Iterator;
--
--/**
-- * An extension to gamemode to implement LP.
-- * Lifepool objectives have been defined
-- * in my design brief, so I will assume you
-- * know what you are expecting to look at here.
-- *
-- * @author s101601828 @ Swin.
-- * @version 1.0
-- * @see WarManager
-- * <p>
-- * Created by Josh on 21/04/2017.
-- * @since 1.0
-- */
--public class LP extends Gamemode {
--
--    private final HashMap<String, Integer> lives = new HashMap<>(); // Key/value set to hold teams' lives.
--
--    public void reset() {
--        // Clears the "lives" key/value set for next time a LP is played.
--        lives.clear();
--    }
--
--    public void initialize() {
--        for (WarTeam team : getTeams()) // Give every participating team a finite amount of lives.
--            lives.put(team.getTeamName(), (Bukkit.getOnlinePlayers().size() * 5) + 3);
--
--        autoAssign();
--
--        // Assign objective to scoreboard for this gamemode.
--        Objective obj = s().registerNewObjective("gm", "dummy");
--        obj.setDisplaySlot(DisplaySlot.SIDEBAR); // Display it in sidebar. Pretty.
--        updateScoreboard(); // Update the scoreboard to put all the default values on it.
--
--        for (Player online : Bukkit.getOnlinePlayers())
--            online.setScoreboard(s()); // Everyone online needs to see this scoreboard.
--    }
--
--    public void tick() {
--        //Nothing needed here.
--    }
--
--    public void onKill(WarPlayer killed, WarPlayer killer) {
--        death(killed);
--    }
--
--    public void onDeath(WarPlayer killed) {
--        death(killed);
--    }
--
--    /**
--     * Procedure that handles death within a round.
--     * A life is decremented from the dead player's
--     * team's life pool.
--     *
--     * @param killed Player who died.
--     */
--    private void death(WarPlayer killed) {
--        int lives = this.lives.get(killed.getCurrentTeam().getTeamName()); // Check their current team's lives.
--        if (lives == 0) return; // They've already lost, there's no point continuing.
--        this.lives.put(killed.getCurrentTeam().getTeamName(), lives - 1);
--        updateScoreboard(); // Reflect the change on the scoreboard.
--        checkWin();
--    }
--
--    public void decideWinner() {
--        int highest = -1; // Highest is lower than zero since teams start off as zero.
--        ArrayList<WarTeam> winners = new ArrayList<>(); // Keep a temporary list of winners.
--
--        for (WarTeam team : getTeams()) {
--            // For each team, check their kills.
--            int count = lives.get(team.getTeamName());
--            if (count == highest)
--                // If they're equal to the current highest points, add them to the list of winners.
--                winners.add(team);
--            else if (count > highest) {
--                // If they're above the current highest points,
--                // Set the new highst points,
--                highest = count;
--                // Clear the current list of winners as they have less points than this team,
--                winners.clear();
--                // Then add this team to the list of winners.
--                winners.add(team);
--            }
--        }
--        broadcastWinner(winners, "lives remaining", highest);
--    }
--
--    private void checkWin() {
--        int aliveTeams = 0; // Record how many teams have more than 0 lives remaining.
--        for (WarTeam team : getTeams())
--            if (lives.get(team.getTeamName()) >= 1)
--                aliveTeams++; // This team has more than 0 lives.
--        if (aliveTeams <= 1) // Is there one or less teams remaining?
--            onEnd();
--    }
--
--    public String getOffensive() {
--        return "Kill enemies to deplete their lifepool!";
--    }
--
--    public String getDefensive() {
--        return "Protect your team and your lives!";
--    }
--
--    public String getName() {
--        return "LP";
--    }
--
--    public String getFullName() {
--        return "Lifepool";
--    }
--
--    public String getGrammar() {
--        return "an";
--    }
--
--    public void onLeave(WarPlayer left) {
--        //Nothing happens when a player leaves on TDM.
--        // Everything is handled automatically. Yay!
--    }
--
--    public void updateScoreboard() {
--        // Get the "objective" on the scoreboard, where data goes.
--        Objective obj = s().getObjective(DisplaySlot.SIDEBAR);
--
--        // The title of the scoreboard, which displays the map and gamemode playing this match.
--        String dp = map().getMapName() + " (" + getName() + ")";
--        if (dp.length() > 32) dp = dp.substring(0, 32); // Titles cannot be longer than 32 characters.
--        obj.setDisplayName(dp); // Set the title of the scoreboard.
--        obj.setDisplaySlot(DisplaySlot.SIDEBAR); // Ensure it is on the sidebar.
--
--        // Format it pretty for the players.
--        obj.getScore(" ").setScore(lives.size() + 2); // Top spacer.
--        obj.getScore("  Lives Remaining").setScore(lives.size() + 1); // 'Points' denoter.
--
--        Iterator<WarTeam> iterator = getTeams().iterator(); // An iterator to iterate through the teams.
--        for (int i = 0; i < lives.size(); i++) { // Only iterate the number of teams needed.
--            // For each team, display their their points colored respectively.
--            WarTeam target = iterator.next(); // Get the next team to be iterated.
--            // Set the new score value.
--            obj.getScore(target.getTeamColor() + "    " + lives.get(target.getTeamName())).setScore(i + 1);
--            // Remove the old value from the board since it is not needed.
--            s().resetScores(target.getTeamColor() + "    " + (lives.get(target.getTeamName()) + 1));
--        }
--        obj.getScore("  ").setScore(0); // Bottom spacer.
--    }
--
--    @Override
--    public HashMap<String, Object> getExtraTeamData(WarTeam team) {
--        HashMap<String, Object> extra = new HashMap<>();
--        extra.put("Lives Remaining", lives.get(team.getTeamName()));
--        return extra;
--    }
--}
-diff --git a/src/au/edu/swin/war/game/modes/LTS.java b/src/au/edu/swin/war/game/modes/LTS.java
-deleted file mode 100644
-index fce3bf2..0000000
---- a/src/au/edu/swin/war/game/modes/LTS.java
-+++ /dev/null
-@@ -1,216 +0,0 @@
--package au.edu.swin.war.game.modes;
--
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.util.WarManager;
--import au.edu.swin.war.game.Gamemode;
--import org.bukkit.Bukkit;
--import org.bukkit.entity.Player;
--import org.bukkit.event.EventHandler;
--import org.bukkit.event.player.PlayerToggleSneakEvent;
--import org.bukkit.scoreboard.DisplaySlot;
--import org.bukkit.scoreboard.Objective;
--
--import java.util.ArrayList;
--import java.util.HashMap;
--import java.util.Iterator;
--import java.util.UUID;
--
--/**
-- * An extension to gamemode to implement LTS.
-- * Last Team Standing objectives have been defined
-- * in my design brief, so I will assume you
-- * know what you are expecting to look at here.
-- *
-- * @author s101601828 @ Swin.
-- * @version 1.0
-- * @see WarManager
-- * <p>
-- * Created by Josh on 26/04/2017.
-- * @since 1.0
-- */
--public class LTS extends Gamemode {
--
--    private ArrayList<UUID> participated; // Keep a list of people who participated.
--    private HashMap<String, Integer> original; // Keep a record of how many players originally played.
--
--    public void reset() {
--        if (participated != null)
--            while (participated.size() > 0) {
--                WarPlayer wp = main.getWarPlayer(participated.get(0));
--                if (wp != null)
--                    wp.setJoined(true); // Re-set this player as joined, since they participated.
--                participated.remove(participated.get(0)); // We can remove this player from the list now.
--            }
--        participated = null; // Remove instance of this list.
--        original.clear(); // Clear and remove instance of original participants.
--        original = null;
--    }
--
--    public void initialize() {
--        // Initialize the array and key/value set first!
--        participated = new ArrayList<>();
--        original = new HashMap<>();
--
--        if (getJoined() < 2) {
--            // LTS requires 2 players at the least to play.
--            Bukkit.broadcastMessage("There needs to be 2 or more participating players!");
--            logEvent("Match cancelled as there was not enough players");
--            onEnd();
--            return;
--        }
--
--        autoAssign();
--
--        // Mark playing players are participated.
--        for (WarPlayer check : main.getWarPlayers().values())
--            if (check.isPlaying())
--                participated.add(check.getPlayer().getUniqueId());
--
--        for (WarTeam team : getTeams()) // Record the original amount of participants.
--            original.put(team.getTeamName(), team.getBukkitTeam().getEntries().size());
--
--        permaDeath = true; // Set permanent death to true for the duration of the match.
--
--        // Assign objective to scoreboard for this gamemode.
--        Objective obj = s().registerNewObjective("gm", "dummy");
--        obj.setDisplaySlot(DisplaySlot.SIDEBAR); // Display it in sidebar. Pretty.
--        updateScoreboard(); // Update the scoreboard to put all the default values on it.
--
--        for (Player online : Bukkit.getOnlinePlayers())
--            online.setScoreboard(s()); // Everyone online needs to see this scoreboard.
--    }
--
--    public void tick() {
--        //Nothing needed here.
--    }
--
--    public void onKill(WarPlayer killed, WarPlayer killer) {
--        dead(killed);
--    }
--
--    public void onDeath(WarPlayer dead) {
--        dead(dead);
--    }
--
--    /**
--     * Common code is shared by onKill and onDeath,
--     * both call to this procedure to prevent duplication.
--     *
--     * @param dead The player who died.
--     */
--    private void dead(WarPlayer dead) {
--        // Kick them out of the match as this is permanent death.
--        dead.setJoined(false);
--        entryHandle(dead);
--    }
--
--    public void decideWinner() {
--        int highest = 0; // Highest is lower than zero since teams start off as zero.
--        ArrayList<WarTeam> winners = new ArrayList<>(); // Keep a temporary list of winners.
--
--        for (WarTeam team : getTeams()) {
--            // For each team, check their kills.
--            int count = team.getBukkitTeam().getSize();
--            if (count == highest)
--                // If they're equal to the current highest members, add them to the list of winners.
--                winners.add(team);
--            else if (count > highest) {
--                // If they're above the current highest members,
--                // Set the new highst members,
--                highest = count;
--                // Clear the current list of winners as they have less members than this team,
--                winners.clear();
--                // Then add this team to the list of winners.
--                winners.add(team);
--            }
--        }
--        broadcastWinner(winners, "members remaining", highest);
--    }
--
--    public String getOffensive() {
--        return "Kill other players!";
--    }
--
--    public String getDefensive() {
--        return "Don't get yourself killed!";
--    }
--
--    public String getFullName() {
--        return "Last Team Standing";
--    }
--
--    public String getName() {
--        return "LTS";
--    }
--
--    public String getGrammar() {
--        return "an";
--    }
--
--    public void onLeave(WarPlayer left) {
--        // Do the usual stuff!
--        updateScoreboard();
--        checkWin();
--    }
--
--    public void updateScoreboard() {
--        // Get the "objective" on the scoreboard, where data goes.
--        Objective obj = s().getObjective(DisplaySlot.SIDEBAR);
--
--        // The title of the scoreboard, which displays the map and gamemode playing this match.
--        String dp = map().getMapName() + " (" + getName() + ")";
--        if (dp.length() > 32) dp = dp.substring(0, 32); // Titles cannot be longer than 32 characters.
--        obj.setDisplayName(dp); // Set the title of the scoreboard.
--        obj.setDisplaySlot(DisplaySlot.SIDEBAR); // Ensure it is on the sidebar.
--
--        obj.getScore(" ").setScore(getTeams().size() + 2); // Top spacer.
--        obj.getScore("  Players Remaining").setScore(getTeams().size() + 1); // 'Points' denoter.
--
--        Iterator<WarTeam> iterator = getTeams().iterator(); // An iterator to iterate through the teams.
--        for (int i = 0; i < getTeams().size(); i++) { // Only iterate the number of teams needed.
--            // For each team, display their their player count colored respectively.
--            WarTeam target = iterator.next(); // Get the next team to be iterated.
--            // Set the new score value.
--            obj.getScore(target.getTeamColor() + "    " + target.getBukkitTeam().getEntries().size()).setScore(i + 1);
--            // Remove the old value from the board since it is not needed.
--            s().resetScores(target.getTeamColor() + "    " + (target.getBukkitTeam().getEntries().size() + 1));
--        }
--        obj.getScore("  ").setScore(0); // Bottom spacer.
--    }
--
--    /**
--     * Check if there is 1 or less teams with 1
--     * or more players remaining. If that is the
--     * case, end the round.
--     */
--    private void checkWin() {
--        if (!active) return; // Don't execute this if the gamemode isn't active.
--        int remainingTeams = 0;
--        for (WarTeam team : getTeams())
--            if (team.getBukkitTeam().getEntries().size() >= 1) remainingTeams++; // This team is still alive.
--
--        if (remainingTeams <= 1) // Is there one or less remaining teams?
--            onEnd();
--
--    }
--
--    /**
--     * Sneaking is a strategy often used to hide
--     * on maps, so sneaking will not allow you to
--     * hide your name tag behind walls.
--     *
--     * @param event An event called by Spigot.
--     */
--    @EventHandler
--    public void onSneak(PlayerToggleSneakEvent event) {
--        event.setCancelled(true);
--    }
--
--    @Override
--    public HashMap<String, Object> getExtraTeamData(WarTeam team) {
--        HashMap<String, Object> extra = new HashMap<>();
--        extra.put("Participants", original.get(team.getTeamName()));
--        return extra;
--    }
--}
-diff --git a/src/au/edu/swin/war/game/modes/TDM.java b/src/au/edu/swin/war/game/modes/TDM.java
-deleted file mode 100644
-index c10996e..0000000
---- a/src/au/edu/swin/war/game/modes/TDM.java
-+++ /dev/null
-@@ -1,152 +0,0 @@
--package au.edu.swin.war.game.modes;
--
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.util.WarManager;
--import au.edu.swin.war.game.Gamemode;
--import org.bukkit.Bukkit;
--import org.bukkit.entity.Player;
--import org.bukkit.scoreboard.DisplaySlot;
--import org.bukkit.scoreboard.Objective;
--
--import java.util.ArrayList;
--import java.util.HashMap;
--import java.util.Iterator;
--
--/**
-- * An extension to gamemode to implement TDM.
-- * Team Death Match objectives have been defined
-- * in my design brief, so I will assume you
-- * know what you are expecting to look at here.
-- *
-- * @author s101601828 @ Swin.
-- * @version 1.0
-- * @see WarManager
-- * <p>
-- * Created by Josh on 21/04/2017.
-- * @since 1.0
-- */
--public class TDM extends Gamemode {
--
--    private final HashMap<String, Integer> kills = new HashMap<>(); // Key/value set to hold teams' points.
--
--    public void reset() {
--        // Clears the "kills" key/value set for next time a TDM is played.
--        kills.clear();
--    }
--
--    public void initialize() {
--        for (WarTeam team : getTeams()) // Give every participating team a default score of zero.
--            kills.put(team.getTeamName(), 0);
--
--        autoAssign();
--
--        // Assign objective to scoreboard for this gamemode.
--        Objective obj = s().registerNewObjective("gm", "dummy");
--        obj.setDisplaySlot(DisplaySlot.SIDEBAR); // Display it in sidebar. Pretty.
--        updateScoreboard(); // Update the scoreboard to put all the default values on it.
--
--        for (Player online : Bukkit.getOnlinePlayers())
--            online.setScoreboard(s()); // Everyone online needs to see this scoreboard.
--    }
--
--    public void tick() {
--        //Nothing needed here.
--    }
--
--    public void onKill(WarPlayer killed, WarPlayer killer) {
--        // Increments the killer's team's points.
--        kills.put(killer.getCurrentTeam().getTeamName(), kills.get(killer.getCurrentTeam().getTeamName()) + 1);
--        updateScoreboard(); // Update the scoreboard to reflect the change.
--    }
--
--    public void onDeath(WarPlayer killed) {
--        // If the player kills themselves, award a point to every opposition team.
--        for (WarTeam awarded : getTeams()) {
--            if (!awarded.getTeamName().equals(killed.getCurrentTeam().getTeamName())) // Is this team not their team?
--                kills.put(awarded.getTeamName(), kills.get(awarded.getTeamName()) + 1); // Increment their points!
--        }
--        updateScoreboard(); // Update the scoreboard to reflect the change.
--    }
--
--    public void decideWinner() {
--        int highest = -1; // Highest is lower than zero since teams start off as zero.
--        ArrayList<WarTeam> winners = new ArrayList<>(); // Keep a temporary list of winners.
--
--        for (WarTeam team : getTeams()) {
--            // For each team, check their kills.
--            int count = kills.get(team.getTeamName());
--            if (count == highest)
--                // If they're equal to the current highest points, add them to the list of winners.
--                winners.add(team);
--            else if (count > highest) {
--                // If they're above the current highest points,
--                // Set the new highst points,
--                highest = count;
--                // Clear the current list of winners as they have less points than this team,
--                winners.clear();
--                // Then add this team to the list of winners.
--                winners.add(team);
--            }
--        }
--        broadcastWinner(winners, "points", highest);
--    }
--
--    public String getOffensive() {
--        return "Kill players to score points!";
--    }
--
--    public String getDefensive() {
--        return "Don't let the enemy kill you! They will get points!";
--    }
--
--    public String getName() {
--        return "TDM";
--    }
--
--    public String getFullName() {
--        return "Team Death Match";
--    }
--
--    public String getGrammar() {
--        return "a";
--    }
--
--    public void onLeave(WarPlayer left) {
--        //Nothing happens when a player leaves on TDM.
--        // Everything is handled automatically. Yay!
--    }
--
--    public void updateScoreboard() {
--        // Get the "objective" on the scoreboard, where data goes.
--        Objective obj = s().getObjective(DisplaySlot.SIDEBAR);
--
--        // The title of the scoreboard, which displays the map and gamemode playing this match.
--        String dp = map().getMapName() + " (" + getName() + ")";
--        if (dp.length() > 32) dp = dp.substring(0, 32); // Titles cannot be longer than 32 characters.
--        obj.setDisplayName(dp); // Set the title of the scoreboard.
--        obj.setDisplaySlot(DisplaySlot.SIDEBAR); // Ensure it is on the sidebar.
--
--        // Format it pretty for the players.
--        obj.getScore(" ").setScore(kills.size() + 2); // Top spacer.
--        obj.getScore("  Points").setScore(kills.size() + 1); // 'Points' denoter.
--
--        Iterator<WarTeam> iterator = getTeams().iterator(); // An iterator to iterate through the teams.
--        for (int i = 0; i < kills.size(); i++) { // Only iterate the number of teams needed.
--            // For each team, display their their points colored respectively.
--            WarTeam target = iterator.next(); // Get the next team to be iterated.
--            // Set the new score value.
--            obj.getScore(target.getTeamColor() + "    " + kills.get(target.getTeamName())).setScore(i + 1);
--            // Remove the old value from the board since it is not needed.
--            s().resetScores(target.getTeamColor() + "    " + (kills.get(target.getTeamName()) - 1));
--        }
--        obj.getScore("  ").setScore(0); // Bottom spacer.
--    }
--
--    @Override
--    public HashMap<String, Object> getExtraTeamData(WarTeam team) {
--        HashMap<String, Object> extra = new HashMap<>();
--        extra.put("Points", kills.get(team.getTeamName()));
--        return extra;
--    }
--}
-diff --git a/src/au/edu/swin/war/util/Manager.java b/src/au/edu/swin/war/util/Manager.java
-deleted file mode 100644
-index 5e3e4b7..0000000
---- a/src/au/edu/swin/war/util/Manager.java
-+++ /dev/null
-@@ -1,245 +0,0 @@
--package au.edu.swin.war.util;
--
--import au.edu.swin.war.Main;
--import au.edu.swin.war.WarPlayerPlus;
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.util.WarManager;
--import au.edu.swin.war.stats.WarStats;
--import au.edu.swin.war.util.modules.ConfigUtility;
--import au.edu.swin.war.util.modules.EntityUtility;
--import au.edu.swin.war.util.modules.QueryUtility;
--import au.edu.swin.war.util.modules.RespawnUtility;
--import net.md_5.bungee.api.chat.ComponentBuilder;
--import net.md_5.bungee.api.chat.HoverEvent;
--import net.md_5.bungee.api.chat.TextComponent;
--import org.bukkit.Bukkit;
--import org.bukkit.ChatColor;
--import org.bukkit.Material;
--import org.bukkit.entity.Player;
--import org.bukkit.inventory.ItemStack;
--import org.bukkit.inventory.meta.BookMeta;
--import org.bukkit.inventory.meta.ItemMeta;
--import org.bukkit.potion.PotionEffectType;
--
--import java.util.ArrayList;
--import java.util.HashMap;
--import java.util.List;
--import java.util.UUID;
--
--/**
-- * An extension to WarManager.
-- * Acts as a hub for all modules to interact.
-- *
-- * @author s101601828 @ Swin.
-- * @version 1.0
-- * @see WarManager
-- * <p>
-- * Created by Josh on 20/04/2017.
-- * @since 1.0
-- */
--public class Manager extends WarManager {
--
--    private final Match matchutil; // An instance of the match controller.
--    private final Cache cacheutil; // An instance of the cache.
--    private final RespawnUtility respawnutil; // An instance of the respawning utility.
--    private final EntityUtility entiutil; // An instance of the entity utility.
--    private final ConfigUtility confutil; // An instance of the configuration utility.
--    private final QueryUtility qryutil; // An instance of the database utility.
--
--    private final ArrayList<UUID> warned; // Keeps track of warning messages for players.
--    private final HashMap<UUID, WarStats> tempStats; // Holds statistics for a player until they log in.
--
--    private ItemStack HANDBOOK; // Needs to be created in its own function because it's HELLA huge.
--    ItemStack VOTE;
--    ItemStack SKYBLOCK;
--
--    /**
--     * Creates an instance of this class.
--     * Must be called in onEnable();
--     *
--     * @param plugin Instance of main plugin. Must extend WarPlugin.
--     */
--    public Manager(Main plugin) {
--        super(plugin);
--        // Initialize everything.
--        this.cacheutil = new Cache(this);
--        this.matchutil = new Match(this);
--        this.respawnutil = new RespawnUtility(this);
--        this.entiutil = new EntityUtility(this);
--        this.confutil = new ConfigUtility(this);
--        this.qryutil = new QueryUtility(this, plugin.getConfig().getBoolean("database.enabled"));
--        new Guard(this); // Guard does not need a reference so just initialize it.
--        new StatsListener(this); // Stats Listener does not need a reference so just initialize it.
--
--        warned = new ArrayList<>();
--        tempStats = new HashMap<>();
--        // Task that allows players to receive a warning message every 3 seconds.
--        // Clear warnings.
--        Bukkit.getScheduler().runTaskTimer(plugin, warned::clear, 0L, 60L);
--        createItems();
--    }
--
--    /**
--     * Returns a running instance of the extended Match manager.
--     *
--     * @return Match manager.
--     */
--    public Match match() {
--        return matchutil;
--    }
--
--    /**
--     * Returns a running instance of the extended Cache.
--     *
--     * @return Cache.
--     */
--    public Cache cache() {
--        return cacheutil;
--    }
--
--    /**
--     * Returns a running instance of the respawn utility.
--     *
--     * @return Respawn utility.
--     */
--    public RespawnUtility respawn() {
--        return respawnutil;
--    }
--
--    /**
--     * Returns a running instance of the entity utility.
--     *
--     * @return Entity utility.
--     */
--    public EntityUtility entity() {
--        return entiutil;
--    }
--
--    /**
--     * Returns a running instance of the configuration utility.
--     *
--     * @return Configuration utility.
--     */
--    public ConfigUtility conf() {
--        return confutil;
--    }
--
--    /**
--     * Returns a running instance of the query utility.
--     *
--     * @return Query utility.
--     */
--    public QueryUtility query() {
--        return qryutil;
--    }
--
--    /**
--     * Temporarily holds onto a player's statistics
--     * without necessarily having a WarPlayerPlus
--     * instance created yet. (pre login)
--     *
--     * @param uuid      UUID associated with the stats.
--     * @param tempStats Actual stats.
--     */
--    void putTempStats(UUID uuid, WarStats tempStats) {
--        this.tempStats.put(uuid, tempStats);
--    }
--
--    /**
--     * Creates an instance of a WarPlayer for a player.
--     *
--     * @param target The target to base the WarPlayer object on.
--     */
--    public WarPlayer craftWarPlayer(Player target) {
--        WarStats stats = tempStats.getOrDefault(target.getUniqueId(), new WarStats(this, target.getUniqueId())); // Get their stats, or create new ones.
--        tempStats.remove(target.getUniqueId()); // Remove their pre-login storage stats.
--        WarPlayer result = new WarPlayerPlus(target, this, stats); // Create their instance.
--        getWarPlayers().put(target.getUniqueId(), result); // Put it in the key/value set!
--        return result;
--    }
--
--    /**
--     * Checks if a player can be warned, and then warns them.
--     *
--     * @param whoWasWarned Who was warned. (lol)
--     */
--    public void warn(Player whoWasWarned, String warning) {
--        if (warned.contains(whoWasWarned.getPlayer().getUniqueId())) return;
--        warned.add(whoWasWarned.getPlayer().getUniqueId());
--        whoWasWarned.sendMessage("TIP: " + warning);
--    }
--
--    /**
--     * Returns a message from a selected key, and then replaces
--     * the placeholders with relevant string data.
--     *
--     * @param key          Message key.
--     * @param replacements Replacement phrases.
--     * @return The resulting string.
--     */
--    public String _(String key, Object... replacements) {
--        int i = 0;
--        String result = ChatColor.translateAlternateColorCodes('&', conf().getMessage(key));
--        while (result.contains("{" + i + "}")) {
--            result = result.replace("{" + i + "}", String.valueOf(replacements[i].toString()));
--            i++;
--        }
--        return result;
--    }
--
--    /**
--     * Gives a targeted player the spectator kit.
--     * This isn't needed, but it might be later.
--     *
--     * @param wp The target player.
--     * @since 1.0
--     */
--    @Deprecated /* See WarManager for deprecation reason */
--    public void giveSpectatorKit(WarPlayer wp) {
--        wp.getPlayer().getInventory().setHeldItemSlot(4);
--        wp.getPlayer().getInventory().setItem(4, HANDBOOK);
--        wp.getPlayer().getInventory().setItem(0, SKYBLOCK);
--        wp.getPlayer().getInventory().setItem(1, VOTE);
--    }
--
--    /**
--     * Creates the handbook because the process of
--     * doing so consumes lines like no tomorrow.
--     * All other items too why not.
--     */
--    private void createItems() {
--        HANDBOOK = new ItemStack(Material.WRITTEN_BOOK);
--        BookMeta bookMeta = (BookMeta) HANDBOOK.getItemMeta();
--        bookMeta.setTitle(ChatColor.BOLD + "War: The Basics");
--        bookMeta.setAuthor("War Administration");
--        bookMeta.setGeneration(BookMeta.Generation.TATTERED);
--
--        List<String> pages = new ArrayList<>();
--        pages.add(ChatColor.translateAlternateColorCodes('&', "&lWar: The Basics\n&0Hey there, player!\n\nBook Contents:\n&ci.&0 Overview\n&9ii.&0 Commands\n&6iii.&0 Players\n&aiv.&0 Rules\n\nIf you're &cnew&0, read through me and then\n       &nHAVE FUN!\n\n&0  »»»"));
--        pages.add(ChatColor.translateAlternateColorCodes('&', "&oPart I. An Overview\n&0Welcome to War!\n\nThis is a &5team-based &0strategy PvP server!\nWork with your &4team mates &0to win matches.\n\nThere's a &agamemode &0tosuit everyone's play style!\n\n\n&0     »»»"));
--        pages.add(ChatColor.translateAlternateColorCodes('&', "&oPart II. Commands\n\nStart Playing!\n&c/join &0- &9/leave\n&0What's up next?\n&4/rotation\n&0Have your say!\n&a/vote &0<gamemode>\nStatistics!\n&6/stats &0+ &7/leaderboard\n\n&0Or, &n/? War\n\n&0        »»»"));
--        pages.add(ChatColor.translateAlternateColorCodes('&', "&oPart III. Players\n&0You'll see these people online!\n\n&oStaff:\n&6@&8Administrator\n&5@&8Moderator\n\n&0&oOther Ranks:\n&a#&8Donator\n&e#&8DonatorPlus\n&4#&8MapCreator\n\n&0           »»»"));
--        pages.add(ChatColor.translateAlternateColorCodes('&', "&oPart IV. Rules\n&0Follow these!\n\n&ci. &0Don't be a dick.\n&9ii. &0Play the game.\n&4iii. &0Don't cheat.\n&6iv. &0Don't combat log.\n&2v. &0Be a good sport.\n&5vi. &0Don't spawncamp.\n&8vii. &0Listen to @Staff\n&7viii. &0Have fun!\n\n\n&0              »»»"));
--        pages.add(ChatColor.translateAlternateColorCodes('&', "&oNow, go get 'em!\n\n&0We encourage players to use &4common sense &0whilst playing. Have a safe, sensible, and &dfun &cWar!\n\n&0- Administration\n\n\n\n\n                  X"));
--        bookMeta.setPages(pages);
--        HANDBOOK.setItemMeta(bookMeta);
--
--        SKYBLOCK = new ItemStack(Material.EYE_OF_ENDER);
--        ItemMeta sbMeta = SKYBLOCK.getItemMeta();
--        sbMeta.setDisplayName(ChatColor.BOLD + "To: Skyblock");
--        List<String> lore = new ArrayList<>();
--        lore.add(ChatColor.GRAY + "Right click to return");
--        lore.add(ChatColor.GRAY + "to the Skyblock server!");
--        sbMeta.setLore(lore);
--        SKYBLOCK.setItemMeta(sbMeta);
--
--        VOTE = items().createPotion(PotionEffectType.HEAL, 0,0, 1);
--        ItemMeta voteMeta = VOTE.getItemMeta();
--        voteMeta.setDisplayName(ChatColor.BOLD + "Vote For Us!");
--        lore.clear();
--        lore.add(ChatColor.GRAY + "Right click to reaveal the");
--        lore.add(ChatColor.GRAY + "voting link. Earn rewards!");
--        voteMeta.setLore(lore);
--        VOTE.setItemMeta(voteMeta);
--    }
--}
-diff --git a/src/sbs/mira/pvp/MiraPvpMaster.java b/src/sbs/mira/pvp/MiraPvpMaster.java
-new file mode 100644
-index 0000000..af977e6
---- /dev/null
-+++ b/src/sbs/mira/pvp/MiraPvpMaster.java
-@@ -0,0 +1,233 @@
-+package sbs.mira.pvp;
-+
-+import org.bukkit.craftbukkit.v1_21_R5.entity.CraftPlayer;
-+import org.jetbrains.annotations.NotNull;
-+import sbs.mira.pvp.framework.MiraPluginMaster;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.stats.WarStats;
-+import sbs.mira.pvp.util.Cache;
-+import sbs.mira.pvp.util.Match;
-+import sbs.mira.pvp.util.modules.ConfigUtility;
-+import sbs.mira.pvp.util.modules.EntityUtility;
-+import sbs.mira.pvp.util.modules.QueryUtility;
-+import sbs.mira.pvp.util.modules.RespawnUtility;
-+import org.bukkit.Bukkit;
-+import org.bukkit.ChatColor;
-+import org.bukkit.Material;
-+import org.bukkit.entity.Player;
-+import org.bukkit.inventory.ItemStack;
-+import org.bukkit.inventory.meta.BookMeta;
-+import org.bukkit.inventory.meta.ItemMeta;
-+import org.bukkit.potion.PotionEffectType;
-+
-+import java.util.*;
-+
-+/**
-+ * [wit.]
-+ * created on 2017-03-20.
-+ *
-+ * @author jj.mira.sbs
-+ * @version 1.0.1
-+ * @see sbs.mira.pvp.framework.MiraPluginMaster
-+ * @since 1.0.0
-+ */
-+public class MiraPvpMaster extends MiraPluginMaster<MiraPvpPulse, MiraPvpPlayer> {
-+  
-+  
-+  /*private final Match matchutil; // An instance of the match controller.
-+  private final Cache cacheutil; // An instance of the cache.
-+  private final RespawnUtility respawnutil; // An instance of the respawning utility.
-+  private final EntityUtility entiutil; // An instance of the entity utility.
-+  private final ConfigUtility confutil; // An instance of the configuration utility.
-+  private final QueryUtility qryutil; // An instance of the database utility.
-+  
-+  private final ArrayList<UUID> warned; // Keeps track of warning messages for players.
-+  private final HashMap<UUID, WarStats> tempStats; // Holds statistics for a player until they log in.
-+  
-+  private ItemStack HANDBOOK; // Needs to be created in its own function because it's HELLA huge.
-+  ItemStack VOTE;
-+  ItemStack SKYBLOCK;*/
-+  
-+  public MiraPvpMaster(MiraPvpPlugin plugin) {
-+    super(plugin);
-+    /*this.cacheutil = new Cache(this);
-+    this.matchutil = new Match(this);
-+    this.respawnutil = new RespawnUtility(this);
-+    this.entiutil = new EntityUtility(this);
-+    this.confutil = new ConfigUtility(this);
-+    this.qryutil = new QueryUtility(this, plugin.getConfig().getBoolean("database.enabled"));
-+    new Guard(this); // Guard does not need a reference so just initialize it.
-+    new StatsListener(this); // Stats Listener does not need a reference so just initialize it.*/
-+    
-+    warned = new ArrayList<>();
-+    tempStats = new HashMap<>();
-+    // Task that allows players to receive a warning message every 3 seconds.
-+    // Clear warnings.
-+    Bukkit.getScheduler().runTaskTimer(plugin, warned::clear, 0L, 60L);
-+    createItems();
-+  }
-+  
-+  /**
-+   * Returns a running instance of the extended Match manager.
-+   *
-+   * @return Match manager.
-+   */
-+  public Match match() {
-+    return matchutil;
-+  }
-+  
-+  /**
-+   * Returns a running instance of the extended Cache.
-+   *
-+   * @return Cache.
-+   */
-+  public Cache cache() {
-+    return cacheutil;
-+  }
-+  
-+  /**
-+   * Returns a running instance of the respawn utility.
-+   *
-+   * @return Respawn utility.
-+   */
-+  public RespawnUtility respawn() {
-+    return respawnutil;
-+  }
-+  
-+  /**
-+   * Returns a running instance of the entity utility.
-+   *
-+   * @return Entity utility.
-+   */
-+  public EntityUtility entity() {
-+    return entiutil;
-+  }
-+  
-+  /**
-+   * Returns a running instance of the configuration utility.
-+   *
-+   * @return Configuration utility.
-+   */
-+  public ConfigUtility conf() {
-+    return confutil;
-+  }
-+  
-+  /**
-+   * Returns a running instance of the query utility.
-+   *
-+   * @return Query utility.
-+   */
-+  public QueryUtility query() {
-+    return qryutil;
-+  }
-+  
-+  /**
-+   * Temporarily holds onto a player's statistics
-+   * without necessarily having a WarPlayerPlus
-+   * instance created yet. (pre login)
-+   *
-+   * @param uuid      UUID associated with the stats.
-+   * @param tempStats Actual stats.
-+   */
-+  void putTempStats(UUID uuid, WarStats tempStats) {
-+    this.tempStats.put(uuid, tempStats);
-+  }
-+  
-+  /**
-+   * Creates an instance of a WarPlayer for a player.
-+   *
-+   * @param target The target to base the WarPlayer object on.
-+   */
-+  public MiraPvpPlayer declares(Player target) {
-+    WarStats stats = tempStats.getOrDefault(target.getUniqueId(), new WarStats(this, target.getUniqueId())); // Get their stats, or create new ones.
-+    tempStats.remove(target.getUniqueId()); // Remove their pre-login storage stats.
-+    MiraPlayer result = new MiraPvpPlayer(target, this, stats); // Create their instance.
-+    players().put(target.getUniqueId(), result); // Put it in the key/value set!
-+    return result;
-+  }
-+  
-+  /**
-+   * Checks if a player can be warned, and then warns them.
-+   *
-+   * @param whoWasWarned Who was warned. (lol)
-+   */
-+  public void warn(Player whoWasWarned, String warning) {
-+    if (warned.contains(whoWasWarned.getPlayer().getUniqueId())) return;
-+    warned.add(whoWasWarned.getPlayer().getUniqueId());
-+    whoWasWarned.sendMessage("TIP: " + warning);
-+  }
-+  
-+  /**
-+   * Gives a targeted player the spectator kit.
-+   * This isn't needed, but it might be later.
-+   *
-+   * @param wp The target player.
-+   * @since 1.0
-+   */
-+  public void spectating(MiraPlayer wp) {
-+    wp.crafter().getInventory().setHeldItemSlot(4);
-+    wp.crafter().getInventory().setItem(4, HANDBOOK);
-+    wp.crafter().getInventory().setItem(0, SKYBLOCK);
-+    wp.crafter().getInventory().setItem(1, VOTE);
-+  }
-+  
-+  /**
-+   * Creates the handbook because the process of
-+   * doing so consumes lines like no tomorrow.
-+   * All other items too why not.
-+   */
-+  private void createItems() {
-+    HANDBOOK = new ItemStack(Material.WRITTEN_BOOK);
-+    BookMeta bookMeta = (BookMeta) HANDBOOK.getItemMeta();
-+    bookMeta.setTitle(ChatColor.BOLD + "War: The Basics");
-+    bookMeta.setAuthor("War Administration");
-+    bookMeta.setGeneration(BookMeta.Generation.TATTERED);
-+    
-+    List<String> pages = new ArrayList<>();
-+    pages.add(ChatColor.translateAlternateColorCodes('&', "&lWar: The Basics\n&0Hey there, player!\n\nBook Contents:\n&ci.&0 Overview\n&9ii.&0 Commands\n&6iii.&0 Players\n&aiv.&0 Rules\n\nIf you're &cnew&0, read through me and then\n       &nHAVE FUN!\n\n&0  »»»"));
-+    pages.add(ChatColor.translateAlternateColorCodes('&', "&oPart I. An Overview\n&0Welcome to War!\n\nThis is a &5team-based &0strategy PvP server!\nWork with your &4team mates &0to win matches.\n\nThere's a &agamemode &0tosuit everyone's play style!\n\n\n&0     »»»"));
-+    pages.add(ChatColor.translateAlternateColorCodes('&', "&oPart II. Commands\n\nStart Playing!\n&c/join &0- &9/leave\n&0What's up next?\n&4/rotation\n&0Have your say!\n&a/vote &0<gamemode>\nStatistics!\n&6/stats &0+ &7/leaderboard\n\n&0Or, &n/? War\n\n&0        »»»"));
-+    pages.add(ChatColor.translateAlternateColorCodes('&', "&oPart III. Players\n&0You'll see these people online!\n\n&oStaff:\n&6@&8Administrator\n&5@&8Moderator\n\n&0&oOther Ranks:\n&a#&8Donator\n&e#&8DonatorPlus\n&4#&8MapCreator\n\n&0           »»»"));
-+    pages.add(ChatColor.translateAlternateColorCodes('&', "&oPart IV. Rules\n&0Follow these!\n\n&ci. &0Don't be a dick.\n&9ii. &0Play the game.\n&4iii. &0Don't cheat.\n&6iv. &0Don't combat log.\n&2v. &0Be a good sport.\n&5vi. &0Don't spawncamp.\n&8vii. &0Listen to @Staff\n&7viii. &0Have fun!\n\n\n&0              »»»"));
-+    pages.add(ChatColor.translateAlternateColorCodes('&', "&oNow, go get 'em!\n\n&0We encourage players to use &4common sense &0whilst playing. Have a safe, sensible, and &dfun &cWar!\n\n&0- Administration\n\n\n\n\n                  X"));
-+    bookMeta.setPages(pages);
-+    HANDBOOK.setItemMeta(bookMeta);
-+    
-+    SKYBLOCK = new ItemStack(Material.EYE_OF_ENDER);
-+    ItemMeta sbMeta = SKYBLOCK.getItemMeta();
-+    sbMeta.setDisplayName(ChatColor.BOLD + "To: Skyblock");
-+    List<String> lore = new ArrayList<>();
-+    lore.add(ChatColor.GRAY + "Right click to return");
-+    lore.add(ChatColor.GRAY + "to the Skyblock server!");
-+    sbMeta.setLore(lore);
-+    SKYBLOCK.setItemMeta(sbMeta);
-+    
-+    VOTE = items().createPotion(PotionEffectType.HEAL, 0, 0, 1);
-+    ItemMeta voteMeta = VOTE.getItemMeta();
-+    voteMeta.setDisplayName(ChatColor.BOLD + "Vote For Us!");
-+    lore.clear();
-+    lore.add(ChatColor.GRAY + "Right click to reaveal the");
-+    lore.add(ChatColor.GRAY + "voting link. Earn rewards!");
-+    voteMeta.setLore(lore);
-+    VOTE.setItemMeta(voteMeta);
-+  }
-+  
-+  @Override
-+  public @NotNull Cache observe() {
-+    return cacheutil;
-+  }
-+  
-+  @Override
-+  public @NotNull
-+  MiraPlayer<?> declares(CraftPlayer target)
-+  {
-+    return null;
-+  }
-+  
-+  @Override
-+  public
-+  void spectating(MiraPvpPlayer wp)
-+  {
-+  
-+  }
-+}
-diff --git a/src/sbs/mira/pvp/MiraPvpPlayer.java b/src/sbs/mira/pvp/MiraPvpPlayer.java
-new file mode 100644
-index 0000000..705aa0a
---- /dev/null
-+++ b/src/sbs/mira/pvp/MiraPvpPlayer.java
-@@ -0,0 +1,163 @@
-+package sbs.mira.pvp;
-+
-+import org.bukkit.craftbukkit.v1_21_R5.entity.CraftPlayer;
-+import org.jetbrains.annotations.Nullable;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.stats.WarStats;
-+import org.bukkit.ChatColor;
-+
-+/**
-+ * An extension to WarPlayer that contains non-framework fields.
-+ * Mostly used for statistics tracking.
-+ * created on 2025-08-17.
-+ *
-+ * @author jj.mira.sbs, jd.mira.sbs
-+ * @version 1.0.1
-+ * @see org.bukkit.plugin.java.JavaPlugin
-+ * @since 1.0.0
-+ */
-+public final class MiraPvpPlayer extends MiraPlayer<MiraPvp> {
-+  
-+  /**
-+   * @see sbs.mira.pvp.stats.WarStats
-+   */
-+  private final WarStats stats;
-+  
-+  /***
-+   * true if the player has indicated that they would like to join a team (once available).
-+   */
-+  private boolean joined;
-+  /**
-+   * @see sbs.mira.pvp.framework.game.WarTeam
-+   */
-+  private WarTeam team;
-+  
-+  public MiraPvpPlayer(WarStats stats, CraftPlayer player, MiraPvp mira) {
-+    super(player, mira);
-+    
-+    this.stats = stats;
-+    this.joined = false;
-+    this.team = null;
-+    
-+    changes_visibility();
-+  }
-+  
-+  /**
-+   * @see #stats
-+   */
-+  public WarStats stats() {
-+    return stats;
-+  }
-+  
-+  /**
-+   * @see #joined
-+   */
-+  public boolean joined() {
-+    return joined;
-+  }
-+  
-+  /**
-+   * @see #joined
-+   */
-+  public void joined(boolean joined) {
-+    this.joined = joined;
-+  }
-+  
-+  /**
-+   * @return true if the mira pvp stan has an [sic, lol] designated team.
-+   */
-+  public boolean has_team() {
-+    return team != null;
-+  }
-+  
-+  /**
-+   * Returns the team that the player is currently associated with.
-+   * This is the team that the player currently on during a match.
-+   *
-+   * @return Player's associated team.
-+   */
-+  public @Nullable WarTeam team() {
-+    return team;
-+  }
-+  
-+  /**
-+   * @param new_team the player is joining this team (consensually).
-+   */
-+  public void joins(WarTeam new_team) {
-+    this.team = new_team;
-+    
-+    changes_visibility();
-+    changes_name();
-+  }
-+  
-+  /**
-+   * players participating in the match should not be able to see spectators flying around.
-+   * spectators should be able to see everyone, but not interfere with the match participants at all.
-+   * <ul>
-+   *   <li>`setCollidable(false)` ensures spectators cannot bump match participants around.</li>
-+   * </ul>
-+   */
-+  private void changes_visibility() {
-+    if (has_team()) {
-+      player.setCollidable(true);
-+      // If they are playing, everyone can see this player.
-+      // They however, cannot see spectators.
-+      for (MiraPvpPlayer dp : mira.master().players().values())
-+        if (dp.equals(this)) continue;
-+        else if (dp.is_member_of_team()) {
-+          // They are both playing, so they can both see each other.
-+          dp.crafter().showPlayer(player);
-+          player.showPlayer(dp.crafter());
-+        } else {
-+          // The other player is spectating, so this player cannot see them.
-+          dp.crafter().showPlayer(player);
-+          player.hidePlayer(dp.crafter());
-+        }
-+    } else {
-+      player.setCollidable(false);
-+      // If they are spectating, only spectators can see this player.
-+      // They can see others playing as well.
-+      for (MiraPvpPlayer dp : manager.getWarPlayers().values())
-+        if (dp.equals(this)) continue;
-+        else if (dp.is_member_of_team()) {
-+          // The other player is playing, so they cannot see this player.
-+          dp.crafter().hidePlayer(player);
-+          player.showPlayer(dp.crafter());
-+        } else {
-+          // The other player is spectating, so they can see each other.
-+          dp.crafter().showPlayer(player);
-+          player.showPlayer(dp.crafter());
-+        }
-+    }
-+  }
-+  
-+  /**
-+   * Updates this player's display name.
-+   * This should be called whenever their
-+   * team changes or rank changes.
-+   */
-+  public void changes_name() {
-+    String prefix = "";
-+    if (manager.plugin().hasPermission(crafter(), "war.admin"))
-+      // Admins do not have any other prefixes, except map builder.
-+      prefix = ChatColor.GOLD + "@";
-+    else {
-+      if (manager.plugin().hasPermission(crafter(), "war.mod"))
-+        // Give mod prefixes priority too.
-+        prefix = ChatColor.DARK_PURPLE + "@";
-+      
-+      if (manager.plugin().hasPermission(crafter(), "war.donatorplus"))
-+        // DonatorPlus takes priority over Donator.
-+        prefix = ChatColor.YELLOW + "#" + prefix;
-+      else if (manager.plugin().hasPermission(crafter(), "war.donator"))
-+        // Otherwise do donator if they only have that.
-+        prefix = ChatColor.GREEN + "#" + prefix;
-+    }
-+    if (manager.cache().getCurrentMap().isCreator(crafter().getUniqueId()))
-+      prefix = ChatColor.DARK_RED + "#" + prefix;
-+    
-+    ChatColor teamColor = has_team() ? joins_team().getTeamColor() : ChatColor.LIGHT_PURPLE;
-+    crafter().setDisplayName(prefix + teamColor + name() + ChatColor.WHITE);
-+  }
-+}
-diff --git a/src/sbs/mira/pvp/MiraPvpPlugin.java b/src/sbs/mira/pvp/MiraPvpPlugin.java
-new file mode 100644
-index 0000000..f82b84d
---- /dev/null
-+++ b/src/sbs/mira/pvp/MiraPvpPlugin.java
-@@ -0,0 +1,62 @@
-+package sbs.mira.pvp;
-+
-+import org.bukkit.Bukkit;
-+import org.bukkit.entity.Player;
-+import sbs.mira.pvp.framework.MiraPlugin;
-+import sbs.mira.pvp.util.modules.CommandUtility;
-+import sbs.mira.pvp.util.modules.StatsCommandUtility;
-+
-+/**
-+ * [witty comment here.]
-+ * created on 2017-03-20.
-+ *
-+ * @author jj.mira.sbs
-+ * @version 1.0.1
-+ * @see sbs.mira.pvp.framework.MiraPlugin
-+ * @since 1.0.0
-+ */
-+public
-+class MiraPvpPlugin
-+  extends MiraPlugin<MiraPvpPulse>
-+{
-+  
-+  
-+  /**
-+   * required method by WarPlugin.
-+   * acts as the program's "Main()".
-+   */
-+  public
-+  void onEnable()
-+  {
-+    log("War program has awoken!");
-+    this.getServer().getMessenger().registerOutgoingPluginChannel(this, "BungeeCord");
-+    
-+    final MiraPvpMaster master = new MiraPvpMaster(this);
-+    
-+    super.breathe(new MiraPvpPulse(this, master));
-+    master.breathe(pulse());
-+    
-+    register_module(CommandUtility.class);
-+    register_module(StatsCommandUtility.class);
-+    register_module_commands();
-+    
-+    pulse().master().match().firstMatch(); // Start the special first round procedure to kick off the cycle.
-+  }
-+  
-+  /**
-+   * requires method by WarPlugin.
-+   * called when this program is shut down.
-+   */
-+  public
-+  void onDisable()
-+  {
-+    for (Player online : Bukkit.getOnlinePlayers())
-+    {
-+      online.kickPlayer(getServer().getShutdownMessage());
-+    }
-+    pulse().master().world().restoreMap(pulse()
-+                                          .master()
-+                                          .match()
-+                                          .getRawRoundID() + ""); // Delete the current match world on shutdown.
-+  }
-+}
-diff --git a/src/sbs/mira/pvp/MiraPvpPulse.java b/src/sbs/mira/pvp/MiraPvpPulse.java
-new file mode 100644
-index 0000000..0b3f7c9
---- /dev/null
-+++ b/src/sbs/mira/pvp/MiraPvpPulse.java
-@@ -0,0 +1,19 @@
-+package sbs.mira.pvp;
-+
-+import org.jetbrains.annotations.NotNull;
-+import sbs.mira.pvp.framework.MiraPulse;
-+
-+public
-+final
-+class MiraPvpPulse
-+  extends MiraPulse<MiraPvpPlugin, MiraPvpMaster>
-+{
-+  public
-+  MiraPvpPulse(
-+    @NotNull MiraPvpPlugin plugin,
-+    @NotNull MiraPvpMaster master
-+  )
-+  {
-+    super(plugin, master);
-+  }
-+}
-diff --git a/src/au/edu/swin/war/event/MatchPlayerRespawnEvent.java b/src/sbs/mira/pvp/event/MatchPlayerRespawnEvent.java
-similarity index 80%
-rename from src/au/edu/swin/war/event/MatchPlayerRespawnEvent.java
-rename to src/sbs/mira/pvp/event/MatchPlayerRespawnEvent.java
-index 7bd0386..5ddb5a3 100644
---- a/src/au/edu/swin/war/event/MatchPlayerRespawnEvent.java
-+++ b/src/sbs/mira/pvp/event/MatchPlayerRespawnEvent.java
-@@ -1,6 +1,6 @@
--package au.edu.swin.war.event;
-+package sbs.mira.pvp.event;
- 
--import au.edu.swin.war.framework.WarPlayer;
-+import sbs.mira.pvp.framework.MiraPlayer;
- import org.bukkit.event.Event;
- import org.bukkit.event.HandlerList;
- 
-@@ -21,9 +21,9 @@ import org.bukkit.event.HandlerList;
- public class MatchPlayerRespawnEvent extends Event {
- 
-     private static final HandlerList handlers = new HandlerList();
--    private final WarPlayer player;
-+    private final MiraPlayer player;
- 
--    public MatchPlayerRespawnEvent(WarPlayer player) {
-+    public MatchPlayerRespawnEvent(MiraPlayer player) {
-         this.player = player;
-     }
- 
-@@ -41,7 +41,7 @@ public class MatchPlayerRespawnEvent extends Event {
-      *
-      * @return The player who respawned.
-      */
--    public WarPlayer getPlayer() {
-+    public MiraPlayer getPlayer() {
-         return player;
-     }
- }
-diff --git a/src/au/edu/swin/war/event/PostMatchPlayerRespawnEvent.java b/src/sbs/mira/pvp/event/PostMatchPlayerRespawnEvent.java
-similarity index 73%
-rename from src/au/edu/swin/war/event/PostMatchPlayerRespawnEvent.java
-rename to src/sbs/mira/pvp/event/PostMatchPlayerRespawnEvent.java
-index 8ad901a..10d581e 100644
---- a/src/au/edu/swin/war/event/PostMatchPlayerRespawnEvent.java
-+++ b/src/sbs/mira/pvp/event/PostMatchPlayerRespawnEvent.java
-@@ -1,8 +1,9 @@
--package au.edu.swin.war.event;
-+package sbs.mira.pvp.event;
- 
--import au.edu.swin.war.framework.WarPlayer;
-+import sbs.mira.pvp.framework.MiraPlayer;
- import org.bukkit.event.Event;
- import org.bukkit.event.HandlerList;
-+import sbs.mira.pvp.game.util.SpawnArea;
- 
- /**
-  * Custom event to handle events after a match respawn.
-@@ -10,7 +11,7 @@ import org.bukkit.event.HandlerList;
-  *
-  * @author s101601828 @ Swin.
-  * @version 1.0
-- * @see au.edu.swin.war.game.util.SpawnArea
-+ * @see SpawnArea
-  * <p>
-  * Created by Josh on 20/04/2017.
-  * @since 1.0
-@@ -18,9 +19,9 @@ import org.bukkit.event.HandlerList;
- public class PostMatchPlayerRespawnEvent extends Event {
- 
-     private static final HandlerList handlers = new HandlerList();
--    private final WarPlayer player;
-+    private final MiraPlayer player;
- 
--    public PostMatchPlayerRespawnEvent(WarPlayer player) {
-+    public PostMatchPlayerRespawnEvent(MiraPlayer player) {
-         this.player = player;
-     }
- 
-@@ -38,7 +39,7 @@ public class PostMatchPlayerRespawnEvent extends Event {
-      *
-      * @return The player who respawned.
-      */
--    public WarPlayer getPlayer() {
-+    public MiraPlayer getPlayer() {
-         return player;
-     }
- }
-diff --git a/src/sbs/mira/pvp/framework/Breather.java b/src/sbs/mira/pvp/framework/Breather.java
-new file mode 100644
-index 0000000..ccfbe0d
---- /dev/null
-+++ b/src/sbs/mira/pvp/framework/Breather.java
-@@ -0,0 +1,32 @@
-+package sbs.mira.pvp.framework;
-+
-+import org.jetbrains.annotations.NotNull;
-+
-+/**
-+ * 🫀
-+ *
-+ * @author jj.mira.sbs
-+ * @version 1.0.0
-+ * @since 1.0.0
-+ */
-+public
-+interface Breather<Pulse extends MiraPulse<?, ?>>
-+{
-+  
-+  /**
-+   * @return heartbeat of mira, still going i hope.
-+   * @throws FlatlineException bruh...
-+   */
-+  @NotNull
-+  Pulse pulse() throws FlatlineException;
-+  
-+  void breathe(@NotNull Pulse pulse) throws IllegalStateException;
-+  
-+  /**
-+   * just set the pulse brah?
-+   */
-+  class FlatlineException
-+    extends RuntimeException
-+  {
-+  }
-+}
-diff --git a/src/sbs/mira/pvp/framework/MiraModule.java b/src/sbs/mira/pvp/framework/MiraModule.java
-new file mode 100644
-index 0000000..5725acb
---- /dev/null
-+++ b/src/sbs/mira/pvp/framework/MiraModule.java
-@@ -0,0 +1,31 @@
-+package sbs.mira.pvp.framework;
-+
-+import org.bukkit.event.Listener;
-+
-+/**
-+ * a moving cog within the mira framework.
-+ * slide it into place (as needed) to turn neighbouring gears.
-+ * created on 2017-03-20.
-+ *
-+ * @author jj.mira.sbs
-+ * @version 1.0.1
-+ * @since 1.0.0
-+ */
-+public abstract class MiraModule implements Listener {
-+  
-+  private final MiraPulse mira;
-+  
-+  protected MiraModule(MiraPulse main) {
-+    this.mira = main;
-+  }
-+  
-+  /**
-+   * don't get lost.
-+   *
-+   * @return stay with us.
-+   */
-+  public
-+  MiraPulse mira() {
-+    return mira;
-+  }
-+}
-diff --git a/src/sbs/mira/pvp/framework/MiraPlayer.java b/src/sbs/mira/pvp/framework/MiraPlayer.java
-new file mode 100644
-index 0000000..75ee78f
---- /dev/null
-+++ b/src/sbs/mira/pvp/framework/MiraPlayer.java
-@@ -0,0 +1,59 @@
-+package sbs.mira.pvp.framework;
-+
-+import org.bukkit.craftbukkit.v1_21_R5.entity.CraftPlayer;
-+import org.bukkit.entity.Player;
-+
-+/**
-+ * oh look another mira stan.
-+ * created on 2017-03-21.
-+ *
-+ * @author jj.mira.sbs
-+ * @author jd.mira.sbs
-+ * @version 1.0.1
-+ * @since 1.0.0
-+ */
-+public abstract class MiraPlayer<M extends MiraPulse> {
-+  
-+  protected final M mira;
-+  protected final CraftPlayer player;
-+  
-+  /**
-+   * @param player is for me?
-+   * @param mira   anchorrr.
-+   */
-+  public MiraPlayer(CraftPlayer player, M mira) {
-+    this.mira = mira;
-+    this.player = player;
-+  }
-+  
-+  /**
-+   * @see org.bukkit.craftbukkit.v1_21_R5.entity.CraftPlayer
-+   */
-+  public CraftPlayer crafter() {
-+    return player;
-+  }
-+  
-+  /**
-+   * @param message The message to send to the player.
-+   * @see Player#sendMessage(String)
-+   */
-+  public void dm(String message) {
-+    player.sendMessage(message);
-+  }
-+  
-+  /**
-+   * @return the current in game name of this mira stan.
-+   * @see Player#getName()
-+   */
-+  public String name() {
-+    return player.getName();
-+  }
-+  
-+  /**
-+   * @return formatted "display" name with formatting enabled+encouraged.
-+   * @see org.bukkit.entity.Player#getName()
-+   */
-+  public String display_name() {
-+    return player.getDisplayName();
-+  }
-+}
-diff --git a/src/sbs/mira/pvp/framework/MiraPlugin.java b/src/sbs/mira/pvp/framework/MiraPlugin.java
-new file mode 100644
-index 0000000..489bd3e
---- /dev/null
-+++ b/src/sbs/mira/pvp/framework/MiraPlugin.java
-@@ -0,0 +1,182 @@
-+package sbs.mira.pvp.framework;
-+
-+import org.jetbrains.annotations.NotNull;
-+import com.sk89q.bukkit.util.CommandsManagerRegistration;
-+import com.sk89q.minecraft.util.commands.*;
-+import org.bukkit.command.Command;
-+import org.bukkit.command.CommandSender;
-+import org.bukkit.command.ConsoleCommandSender;
-+import org.bukkit.permissions.Permission;
-+import org.bukkit.permissions.PermissionDefault;
-+import org.bukkit.plugin.java.JavaPlugin;
-+import org.jetbrains.annotations.Nullable;
-+import sbs.mira.pvp.MiraPvpMaster;
-+import sbs.mira.pvp.MiraPvpPlugin;
-+import sbs.mira.pvp.MiraPvpPulse;
-+
-+import java.util.ArrayList;
-+import java.util.logging.Level;
-+
-+/**
-+ * everything good in mira, built on top of JavaPlugin.
-+ * created on 2017-03-20.
-+ *
-+ * @author jj.mira.sbs
-+ * @version 1.0.1
-+ * @see org.bukkit.plugin.java.JavaPlugin
-+ * @since 1.0.0
-+ */
-+public abstract
-+class MiraPlugin<Pulse extends MiraPulse<?, ?>>
-+  extends JavaPlugin
-+  implements Breather<Pulse>
-+{
-+  
-+  @Nullable
-+  private Pulse pulse;
-+  
-+  @NotNull
-+  private final CommandsManager<CommandSender> commands_manager = new CommandsManager<>()
-+  {
-+    
-+    /***
-+     * @see org.bukkit.permissions.Permission
-+     */
-+    @Override
-+    public
-+    boolean hasPermission(CommandSender sender, String perm)
-+    {
-+      Permission permission = new Permission(perm, PermissionDefault.FALSE);
-+      return sender instanceof ConsoleCommandSender || sender.hasPermission(permission);
-+    }
-+  };
-+  
-+  
-+  private final ArrayList<Class<? extends MiraModule>> module_classes = new ArrayList<>();
-+  
-+  
-+  @Override
-+  public @NotNull
-+  Pulse pulse() throws FlatlineException
-+  {
-+    if (this.pulse != null)
-+    {
-+      return pulse;
-+    }
-+    else
-+    {
-+      throw new FlatlineException();
-+    }
-+  }
-+  
-+  @Override
-+  public
-+  void breathe(@NotNull Pulse pulse) throws IllegalStateException
-+  {
-+    if (this.pulse == null)
-+    {
-+      this.pulse = pulse;
-+    }
-+    else
-+    {
-+      throw new IllegalStateException("a breather may not have two pulses.");
-+    }
-+  }
-+  
-+  /**
-+   * log an informational message to the jvm console.
-+   *
-+   * @param message yap.
-+   * @see java.util.logging.Logger
-+   */
-+  public
-+  void log(String message)
-+  {
-+    getLogger().log(Level.INFO, "[war] " + message);
-+  }
-+  
-+  /**
-+   * registers a mira module.
-+   *
-+   * @see MiraModule
-+   * @see com.sk89q.minecraft.util.commands.Command
-+   */
-+  protected
-+  void register_module(Class<? extends MiraModule> module_class)
-+  {
-+    // Add the class so it will be initialised later.
-+    module_classes.add(module_class);
-+  }
-+  
-+  /**
-+   * registers commands found in the provided plugin module classes.
-+   *
-+   * @see MiraPlugin#module_classes
-+   */
-+  protected
-+  void register_module_commands()
-+  {
-+    assert !module_classes.isEmpty();
-+    
-+    commands_manager.setInjector(new SimpleInjector(pulse()));
-+    
-+    CommandsManagerRegistration registration = new CommandsManagerRegistration(this, commands_manager);
-+    
-+    module_classes.forEach(registration::register);
-+  }
-+  
-+  /**
-+   * our lord and saviour sk89q takes the wheel.
-+   *
-+   * @return true; always; don't fall back on standard nms logic.
-+   * @see com.sk89q.minecraft.util.commands.Command
-+   */
-+  @Override
-+  public
-+  boolean onCommand(
-+    @NotNull CommandSender sender,
-+    @NotNull Command command,
-+    @NotNull String label,
-+    @NotNull String[] arguments
-+  )
-+  {
-+    try
-+    {
-+      // Execute it through sk89q's command processor.
-+      commands_manager.execute(command.getName(), arguments, sender, sender);
-+    }
-+    catch (CommandPermissionsException e)
-+    {
-+      // No permission?
-+      sender.sendMessage(pulse().master().message("command.validation.error.permission"));
-+    }
-+    catch (MissingNestedCommandException e)
-+    {
-+      sender.sendMessage(pulse().master().message("command.validation.error.generic", e.getUsage()));
-+    }
-+    catch (CommandUsageException e)
-+    {
-+      sender.sendMessage(pulse().master().message("command.validation.error.usage", e.getMessage(), e.getUsage()));
-+    }
-+    catch (WrappedCommandException e)
-+    {
-+      if (e.getCause() instanceof NumberFormatException)
-+      {
-+        sender.sendMessage(pulse().master().message("command.validation.error.number.format"));
-+      }
-+      else
-+      {
-+        sender.sendMessage(pulse()
-+                             .master()
-+                             .message("command.validation.error.generic", "unknown error: " + e.getMessage()));
-+        //noinspection CallToPrintStackTrace
-+        e.printStackTrace();
-+      }
-+    }
-+    catch (CommandException e)
-+    {
-+      sender.sendMessage(pulse().master().message("command.validation.error.generic", e.getMessage()));
-+    }
-+    return true;
-+  }
-+}
-diff --git a/src/sbs/mira/pvp/framework/MiraPluginMaster.java b/src/sbs/mira/pvp/framework/MiraPluginMaster.java
-new file mode 100644
-index 0000000..6a4fb1b
---- /dev/null
-+++ b/src/sbs/mira/pvp/framework/MiraPluginMaster.java
-@@ -0,0 +1,173 @@
-+package sbs.mira.pvp.framework;
-+
-+import net.md_5.bungee.api.chat.TextComponent;
-+import org.bukkit.ChatColor;
-+import org.bukkit.craftbukkit.v1_21_R5.entity.CraftPlayer;
-+import org.bukkit.entity.Player;
-+import org.jetbrains.annotations.NotNull;
-+import org.jetbrains.annotations.Nullable;
-+import sbs.mira.pvp.framework.util.modules.ItemUtility;
-+import sbs.mira.pvp.framework.util.modules.StringUtility;
-+import sbs.mira.pvp.framework.util.modules.WorldUtility;
-+
-+import java.util.*;
-+
-+/**
-+ * represents the state of a bukkit server under the influence of mira.
-+ * created on 2017-03-20.
-+ *
-+ * @author jj.mira.sbs
-+ * @version 1.0.1
-+ * @see MiraPulse
-+ * @since 1.0.0
-+ */
-+public abstract
-+class MiraPluginMaster<Pulse extends MiraPulse<?, ?>, Player extends MiraPlayer<?>>
-+  implements Breather<Pulse>
-+{
-+  private @Nullable Pulse pulse;
-+  
-+  private final @NotNull Random rng;
-+  private final @NotNull TreeMap<UUID, Player> players;
-+  private final @NotNull ItemUtility items;
-+  private final @NotNull StringUtility strings;
-+  private final @NotNull WorldUtility world;
-+  
-+  public
-+  MiraPluginMaster()
-+  {
-+    this.rng = new Random(0xfdffdeadL);
-+    this.players = new TreeMap<>();
-+    this.items = new ItemUtility(this);
-+    this.strings = new StringUtility(this);
-+    this.world = new WorldUtility(this);
-+  }
-+  
-+  
-+  @Override
-+  public @NotNull
-+  Pulse pulse() throws FlatlineException
-+  {
-+    if (this.pulse != null)
-+    {
-+      return pulse;
-+    }
-+    else
-+    {
-+      throw new FlatlineException();
-+    }
-+  }
-+  
-+  @Override
-+  public
-+  void breathe(@NotNull Pulse pulse) throws IllegalStateException
-+  {
-+    if (this.pulse == null)
-+    {
-+      this.pulse = pulse;
-+    }
-+    else
-+    {
-+      throw new IllegalStateException("a breather may not have two pulses.");
-+    }
-+  }
-+  
-+  public
-+  abstract
-+  @NotNull
-+  MiraPlayer<?> declares(CraftPlayer target);
-+  
-+  /**
-+   * When called, this should clear a player's inventory
-+   * and if applicable, give the player a spectator kit.
-+   *
-+   * @param wp The target player.
-+   */
-+  public
-+  abstract
-+  void spectating(Player wp);
-+  
-+  
-+  public
-+  void destroys(UUID victim)
-+  {
-+    players.remove(victim);
-+  }
-+  
-+  public
-+  @Nullable
-+  Player player(UUID target)
-+  {
-+    return players.get(target);
-+  }
-+  
-+  @Nullable
-+  public
-+  Player player(@Nullable Player target)
-+  {
-+    return target == null ? null : player(target.getUniqueId());
-+  }
-+  
-+  public
-+  @NotNull
-+  Map<UUID, Player> players()
-+  {
-+    return players;
-+  }
-+  
-+  public
-+  @NotNull
-+  ItemUtility items()
-+  {
-+    return items;
-+  }
-+  
-+  public
-+  @NotNull
-+  StringUtility strings()
-+  {
-+    return strings;
-+  }
-+  
-+  public
-+  @NotNull
-+  WorldUtility world()
-+  {
-+    return world;
-+  }
-+  
-+  /**
-+   * retrieve and prefill a pre-configured message template.
-+   *
-+   * @param key          message key name.
-+   * @param replacements replaces "{0}", "{1}" and so on with the provided.
-+   * @throws IllegalArgumentException message key does not exist.
-+   */
-+  public
-+  @NotNull
-+  String message(String key, String... replacements) throws IllegalArgumentException
-+  {
-+    int i = 0;
-+    String result = ChatColor.translateAlternateColorCodes('&', pulse().conf().getMessage(key));
-+    while (result.contains("{" + i + "}"))
-+    {
-+      result = result.replace("{%d}".formatted(i), replacements[i]);
-+      i++;
-+    }
-+    return result;
-+  }
-+  
-+  /**
-+   * Sends a TextComponent message to everyone online.
-+   *
-+   * @param comp Message to send.
-+   */
-+  public
-+  void broadcastSpigotMessage(TextComponent comp)
-+  {
-+    for (MiraPlayer<?> online : players.values())
-+    {
-+      online.crafter().spigot().sendMessage(comp);
-+    }
-+  }
-+}
-diff --git a/src/sbs/mira/pvp/framework/MiraPulse.java b/src/sbs/mira/pvp/framework/MiraPulse.java
-new file mode 100644
-index 0000000..33c8a13
---- /dev/null
-+++ b/src/sbs/mira/pvp/framework/MiraPulse.java
-@@ -0,0 +1,43 @@
-+package sbs.mira.pvp.framework;
-+
-+import org.jetbrains.annotations.NotNull;
-+
-+/**
-+ * [recursive wit.]
-+ * created on 2017-03-20.
-+ *
-+ * @author jj.mira.sbs
-+ * @author jd.mira.sbs
-+ * @version 1.0.1
-+ * @see MiraPlugin
-+ * @since 1.0.0
-+ */
-+public
-+class MiraPulse<Plugin extends MiraPlugin, Master extends MiraPluginMaster>
-+{
-+  @NotNull
-+  private final Plugin plugin;
-+  @NotNull
-+  private final Master master;
-+  
-+  public
-+  MiraPulse(@NotNull Plugin plugin, @NotNull Master master)
-+  {
-+    this.plugin = plugin;
-+    this.master = master;
-+  }
-+  
-+  @NotNull
-+  public
-+  Plugin plugin()
-+  {
-+    return plugin;
-+  }
-+  
-+  @NotNull
-+  public
-+  Master master()
-+  {
-+    return master;
-+  }
-+}
-diff --git a/src/sbs/mira/pvp/framework/event/MatchEndEvent.java b/src/sbs/mira/pvp/framework/event/MatchEndEvent.java
-new file mode 100644
-index 0000000..21b8af2
---- /dev/null
-+++ b/src/sbs/mira/pvp/framework/event/MatchEndEvent.java
-@@ -0,0 +1,29 @@
-+package sbs.mira.pvp.framework.event;
-+
-+import org.bukkit.event.Event;
-+import org.bukkit.event.HandlerList;
-+import org.jetbrains.annotations.NotNull;
-+
-+/**
-+ * [wit.]
-+ * created on 2017-09-21.
-+ *
-+ * @author jj.mira.sbs
-+ * @author jd.mira.sbs
-+ * @version 1.0.0
-+ * @see Event
-+ * @since 1.0.0
-+ */
-+public class MatchEndEvent extends Event {
-+  
-+  private static final HandlerList handlers = new HandlerList();
-+  
-+  public static HandlerList getHandlerList() {
-+    return handlers;
-+  }
-+  
-+  @Override
-+  public @NotNull HandlerList getHandlers() {
-+    return handlers;
-+  }
-+}
-diff --git a/src/sbs/mira/pvp/framework/event/MatchPlayerDeathEvent.java b/src/sbs/mira/pvp/framework/event/MatchPlayerDeathEvent.java
-new file mode 100644
-index 0000000..8d75ee7
---- /dev/null
-+++ b/src/sbs/mira/pvp/framework/event/MatchPlayerDeathEvent.java
-@@ -0,0 +1,54 @@
-+package sbs.mira.pvp.framework.event;
-+
-+import org.jetbrains.annotations.NotNull;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import org.bukkit.event.Event;
-+import org.bukkit.event.HandlerList;
-+
-+/**
-+ * custom event to handle death during an active, ongoing pvp match.
-+ * <p>
-+ * Just like all events, custom ones can be created.
-+ * This one is called when a player dies during a match.
-+ * <p>
-+ * created on 2017-09-21.
-+ *
-+ * @author jj.mira.sbs
-+ * @author jd.mira.sbs
-+ * @version 1.0.0
-+ * @see Event
-+ * @since 1.0.0
-+ */
-+public class MatchPlayerDeathEvent extends Event {
-+  
-+  private static final HandlerList handlers = new HandlerList();
-+  private final MiraPlayer dead, killer;
-+  
-+  public MatchPlayerDeathEvent(MiraPlayer dead, MiraPlayer killer) {
-+    this.dead = dead;
-+    this.killer = killer;
-+  }
-+  
-+  public static HandlerList getHandlerList() {
-+    return handlers;
-+  }
-+  
-+  @Override
-+  public @NotNull HandlerList getHandlers() {
-+    return handlers;
-+  }
-+  
-+  /**
-+   * @return the victim.
-+   */
-+  public MiraPlayer getPlayer() {
-+    return dead;
-+  }
-+  
-+  /**
-+   * @return the killer.
-+   */
-+  public MiraPlayer getKiller() {
-+    return killer;
-+  }
-+}
-diff --git a/src/sbs/mira/pvp/framework/event/MatchPlayerJoinEvent.java b/src/sbs/mira/pvp/framework/event/MatchPlayerJoinEvent.java
-new file mode 100644
-index 0000000..2ec245f
---- /dev/null
-+++ b/src/sbs/mira/pvp/framework/event/MatchPlayerJoinEvent.java
-@@ -0,0 +1,39 @@
-+package sbs.mira.pvp.framework.event;
-+
-+import org.jetbrains.annotations.NotNull;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import org.bukkit.event.Event;
-+import org.bukkit.event.HandlerList;
-+
-+/**
-+ * custom event to handle team joining.
-+ * created on 2017-09-21.
-+ *
-+ * @author jj.mira.sbs
-+ * @author jd.mira.sbs
-+ * @version 1.0.1
-+ * @see Event
-+ * @since 1.0.0
-+ */
-+public class MatchPlayerJoinEvent extends Event {
-+  
-+  private static final HandlerList handlers = new HandlerList();
-+  private final MiraPlayer player;
-+  
-+  public MatchPlayerJoinEvent(MiraPlayer player) {
-+    this.player = player;
-+  }
-+  
-+  public static HandlerList getHandlerList() {
-+    return handlers;
-+  }
-+  
-+  @Override
-+  public @NotNull HandlerList getHandlers() {
-+    return handlers;
-+  }
-+  
-+  public MiraPlayer getPlayer() {
-+    return player;
-+  }
-+}
-diff --git a/src/sbs/mira/pvp/framework/event/MatchPlayerLeaveEvent.java b/src/sbs/mira/pvp/framework/event/MatchPlayerLeaveEvent.java
-new file mode 100644
-index 0000000..57115eb
---- /dev/null
-+++ b/src/sbs/mira/pvp/framework/event/MatchPlayerLeaveEvent.java
-@@ -0,0 +1,46 @@
-+package sbs.mira.pvp.framework.event;
-+
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import org.bukkit.event.Event;
-+import org.bukkit.event.HandlerList;
-+
-+/**
-+ * Custom event to handle team leaving.
-+ * <p>
-+ * Just like all events, custom ones can be created.
-+ * This one is called when a player leaves the match.
-+ *
-+ * @author s101601828 @ Swin.
-+ * @version 1.0
-+ * @see Event
-+ * <p>
-+ * Created by Josh on 21/09/2017.
-+ * @since 1.1
-+ */
-+public class MatchPlayerLeaveEvent extends Event {
-+
-+    private static final HandlerList handlers = new HandlerList();
-+    private final MiraPlayer player;
-+
-+    public MatchPlayerLeaveEvent(MiraPlayer player) {
-+        this.player = player;
-+    }
-+
-+    public static HandlerList getHandlerList() {
-+        return handlers;
-+    }
-+
-+    @Override
-+    public HandlerList getHandlers() {
-+        return handlers;
-+    }
-+
-+    /**
-+     * Returns the player who leaves.
-+     *
-+     * @return The player who leaves.
-+     */
-+    public MiraPlayer getPlayer() {
-+        return player;
-+    }
-+}
-diff --git a/src/sbs/mira/pvp/framework/game/WarMap.java b/src/sbs/mira/pvp/framework/game/WarMap.java
-new file mode 100644
-index 0000000..0da5df1
---- /dev/null
-+++ b/src/sbs/mira/pvp/framework/game/WarMap.java
-@@ -0,0 +1,601 @@
-+package sbs.mira.pvp.framework.game;
-+
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.stored.Activatable;
-+import sbs.mira.pvp.framework.stored.SerializedLocation;
-+import sbs.mira.pvp.framework.MiraPulse;
-+import org.bukkit.Location;
-+import org.bukkit.Material;
-+import org.bukkit.entity.Hanging;
-+import org.bukkit.event.EventHandler;
-+import org.bukkit.event.EventPriority;
-+import org.bukkit.event.Listener;
-+import org.bukkit.event.block.*;
-+import org.bukkit.event.entity.EntityDamageEvent;
-+import org.bukkit.event.entity.EntityExplodeEvent;
-+import org.bukkit.event.entity.PlayerDeathEvent;
-+import org.bukkit.event.hanging.HangingBreakEvent;
-+import org.bukkit.inventory.ItemStack;
-+
-+import java.util.*;
-+
-+/**
-+ * This extensible class stores all &amp; handles
-+ * some map data. Most map data is manipulated at
-+ * match runtime if the selected map is playing.
-+ * <p>
-+ * Do NOT use WarMap as a direct extension for
-+ * your map configurations. Certain procedures must
-+ * be defined on an extra map subclass in the
-+ * program that actually extends this framework.
-+ * <p>
-+ * Check out activate() and deactivate().
-+ * You must have this defined on another subclass,
-+ * and not defined in each individual map extension.
-+ * <p>
-+ * Created by Josh on 09/04/2017.
-+ *
-+ * @author s101601828 @ Swin.
-+ * @version 1.0
-+ * @since 1.0
-+ */
-+public abstract class WarMap implements Listener {
-+
-+    /* Team-related data. */
-+    final HashMap<String, Object> attributes; // Custom map attributes can be set here if needed.
-+    final HashMap<String, ArrayList<SerializedLocation>> teamSpawns; // A key/value set defining all team spawns.
-+    private final List<Activatable> objectives; // Objectives which are activatable should be set here.
-+    private final HashMap<String, WarTeam> teams; // The list of defined teams available in this map.
-+    /* Do not interfere with these values! */
-+    protected MiraPulse main; // The WarManager instance. This allows access to all other crucial modules.
-+    protected SerializedLocation specSpawn; // The location at which all spectators will initially spawn.
-+    private boolean active = false; // Specified if this map is currently being played.
-+    /* Designation attributes. */
-+    private UUID[] creators = new UUID[]{}; // An array of map creator UUIDs, if applicable.
-+    private String mapName; // The name of the map. For example, "Awesome Arena II"!
-+    private Material[] disabledDrops = new Material[]{}; // A list of disabled drops. One is automatically applied.
-+
-+    /**
-+     * Since this class is intialized through reflections,
-+     * no parameters can be included in the constructor.
-+     * <p>
-+     * To work around this, init() is called after the
-+     * class has actually been initialized to set values.
-+     *
-+     * @see WarMode
-+     */
-+    public WarMap() {
-+        /* Initialize things that need to be ready for the configuration. */
-+        teams = new HashMap<>(); // The Key/Value set only needs to be cleared on a match end. Do not null or free it.
-+        teamSpawns = new HashMap<>(); // The same as above applies to the spawns. Please clear instead of nulling.
-+        objectives = new ArrayList<>(); // Initialize the objectives array.
-+
-+        /* Here are some default values which can be modified by extended configurations. */
-+        attributes = new HashMap<>(); // Initialise the key/value set first!!
-+        attributes.put("allDamage", true); // allDamage allows players to take physical PvP damage;
-+        attributes.put("blockBreak", true); // blockBreak allows players to break blocks;
-+        attributes.put("blockPlace", true); // blockPlace allows players to place blocks;
-+        attributes.put("blockExplode", true); // blockExplode allows blocks to be destroyed from an explosion;
-+        attributes.put("pearlDamage", true); // pearlDamage allows players to take enderpearl collision damage;
-+        attributes.put("fireSpread", false); // fireSpread allows fire to burn, destroy, and spread to other blocks;
-+        // -ONLY IF THEY ARE SET TO TRUE!
-+
-+        attributes.put("matchDuration", 900L); // Defines the default match duration as 15 minutes. (900 seconds)
-+        attributes.put("ffaKills", 20); // Defines the default kill cap needed to win an FFA. (20 kills)
-+        attributes.put("captureRequirement", 3); // Defines the default amount of flag captures to win a CTF. (3 caps)
-+        attributes.put("captureTime", 180); // Defines the default amount of time to hold a flag to win a KoTH. (180 seconds)
-+
-+        // For the love of god, please call init()!
-+        // When configuring a map, please call super(); before doing anything else!
-+        // Review the template if you are confused.
-+    }
-+
-+    /**
-+     * Calling this procedure is IMPORTANT. The program will
-+     * NOT work if you do not define the WarManager instance.
-+     * <p>
-+     * You only need to call this ONCE.
-+     *
-+     * @param main The WarManager instance.
-+     * @see WarMode
-+     */
-+    public void init(MiraPulse main) {
-+        this.main = main;
-+        readyAttributes(); // Ready attributes.
-+        readySpawns(); // Ready spawns.
-+    }
-+
-+    /**
-+     * Extend this procedure in another abstract map class to
-+     * define actions needed to be taken prior to the match
-+     * starting, such as enabling listeners and activating the map.
-+     */
-+    public abstract void activate();
-+
-+    /**
-+     * Extend this procedure to handle any changed attributes in
-+     * the map class since the class itself is NOT cloned.
-+     * Disable listeners, clear lists, reset values, the usual stuff.
-+     */
-+    public abstract void deactivate();
-+
-+    /**
-+     * This is the procedure that must be kept abstract for map
-+     * configuration classes. This procedure will write to the
-+     * class, defining teams, spawns, names, and other attributes.
-+     */
-+    protected abstract void readyAttributes();
-+
-+    /**
-+     * Extend this procedure also to define team spawns after
-+     * defining the attributes in the above abstract procedure.
-+     */
-+    protected abstract void readySpawns();
-+
-+    /**
-+     * If your configuration requires map-specific instantiations,
-+     * feel free to override this procedure and write your own code.
-+     * <p>
-+     * An example usage of this procedure would be to enable listeners
-+     * and initialize values to get a map-specific ability to work.
-+     */
-+    protected void postStart() {
-+    }
-+
-+    /**
-+     * If your configuration, as stated above, requires map-specific
-+     * instantiations, you should also override this procedure to reset
-+     * those instantiations at the end of a match.
-+     * <p>
-+     * An example usage of this procedure would be to reset variables
-+     */
-+    public void reset() {
-+    }
-+
-+    /**
-+     * Applies a player's inventory then updates it.
-+     * <p>
-+     * This is the procedure your actual program should
-+     * use, as it clears their inventory and updates it.
-+     *
-+     * @param target The player to apply.
-+     */
-+    public void applyInv(MiraPlayer target) {
-+        main.items().clear(target);
-+        applyInventory(target);
-+        target.crafter().updateInventory();
-+    }
-+
-+    /**
-+     * Applies a player's inventory for the map.
-+     * <p>
-+     * Extend this procedure to give the relevant player
-+     * their kit for this map when they spawn or respawn.
-+     *
-+     * @param target The player to apply.
-+     */
-+    public abstract void applyInventory(MiraPlayer target);
-+
-+    /**
-+     * Returns the list of map objectives if applicable.
-+     * <p>
-+     * An objective can be a Destroy The Monument monument.
-+     *
-+     * @return The map's objectives.
-+     */
-+    public List<Activatable> objectives() {
-+        return objectives;
-+    }
-+
-+    /**
-+     * Returns the key/value set of attributes for this map.
-+     * Attributes can contain anything: gamemode-specific
-+     * attributes, map-specific attributes, etc.
-+     * <p>
-+     * A gamemode-specific attribute can be the KoTH flag.
-+     * A map-specific attribute could be a temporary point system.
-+     *
-+     * @return The map's attributes.
-+     */
-+    public HashMap<String, Object> attr() {
-+        return attributes;
-+    }
-+
-+    /**
-+     * Quick procedure to set both the block placing and breaking rules.
-+     *
-+     * @param blockBreak Whether block breaking is allowed.
-+     * @param blockPlace Whether block placing is allowed.
-+     */
-+    protected void setAllowBuild(boolean blockBreak, boolean blockPlace) {
-+        attributes.put("blockBreak", blockBreak);
-+        attributes.put("blockExplode", blockBreak);
-+        attributes.put("blockPlace", blockPlace);
-+    }
-+
-+    /**
-+     * Define the region in which blocks can be interacted with.
-+     *
-+     * @param x1 Bottom left X.
-+     * @param z1 Bottom left Z.
-+     * @param x2 Top right X.
-+     * @param z2 Top right Z.
-+     */
-+    protected void setBuildBoundary(int x1, int z1, int x2, int z2) {
-+        attributes.put("boundary", true);
-+        attributes.put("bottomLeft", new SerializedLocation(Math.min(x1, x2), 0, Math.min(z1, z2)));
-+        attributes.put("topRight", new SerializedLocation(Math.max(x1, x2), 0, Math.max(z1, z2)));
-+    }
-+
-+    /**
-+     * Defines whether or not Minecraft monsters/animals can
-+     * naturally spawn on the map terrain while a round is in progress.
-+     *
-+     * @param mobSpawning Mob spawning definition rule.
-+     * @see org.bukkit.entity.LivingEntity
-+     * @deprecated Using the gamerule doMobSpawning = false is more effective!
-+     */
-+    @Deprecated
-+    public void setMobSpawning(boolean mobSpawning) {
-+        attributes.put("mobSpawning", mobSpawning);
-+    }
-+
-+    /**
-+     * Defines the time in the map world manually,
-+     * and then locks the time permanently to that.
-+     *
-+     * @param timeLockTime The time at which to be locked to the map.
-+     */
-+    protected void setTimeLockTime(long timeLockTime) {
-+        attributes.put("timeLockTime", timeLockTime);
-+        attributes.put("timeLock", true);
-+    }
-+
-+    /**
-+     * Sets the maximum Y the players can build up to.
-+     *
-+     * @param y Skybox Y.
-+     */
-+    protected void setBuildHeight(int y) {
-+        attr().put("buildHeight", y);
-+    }
-+
-+    /**
-+     * Sets an array of items for which to are
-+     * not be dropped by a player when they die.
-+     *
-+     * @param disabledDrops Items that will not be dropped on death.
-+     * @see PlayerDeathEvent
-+     */
-+    protected void setDisabledDrops(Material[] disabledDrops) {
-+        this.disabledDrops = disabledDrops;
-+    }
-+
-+    /**
-+     * Instantiates and fills an array of items for which
-+     * are to not be dropped by a player when they die.
-+     * <p>
-+     * The items listed are amongst the most common that
-+     * will be used. Configurations can have their own unique
-+     * drop lists if needed.
-+     *
-+     * @see PlayerDeathEvent;
-+     */
-+    protected Material[] defaultDisabledDrops() {
-+        return new Material[]{Material.LEATHER_BOOTS, Material.LEATHER_LEGGINGS, Material.LEATHER_CHESTPLATE,
-+                Material.LEATHER_HELMET, Material.WOOD_SWORD, Material.STONE_SWORD, Material.IRON_BOOTS, Material.IRON_LEGGINGS,
-+                Material.IRON_CHESTPLATE, Material.IRON_HELMET, Material.IRON_SWORD, Material.GOLD_BOOTS, Material.GOLD_LEGGINGS,
-+                Material.GOLD_CHESTPLATE, Material.GOLD_HELMET, Material.GOLD_SWORD, Material.BOW, Material.DIAMOND_BOOTS,
-+                Material.DIAMOND_LEGGINGS, Material.DIAMOND_CHESTPLATE, Material.DIAMOND_HELMET, Material.DIAMOND_SWORD, Material.ARROW,
-+                Material.FISHING_ROD, Material.GLASS_BOTTLE, Material.WOOL, Material.CHAINMAIL_BOOTS, Material.CHAINMAIL_LEGGINGS,
-+                Material.CHAINMAIL_CHESTPLATE, Material.CHAINMAIL_HELMET, Material.IRON_AXE, Material.IRON_PICKAXE, Material.STONE_PICKAXE,
-+                Material.STONE_AXE, Material.WOOD_HOE, Material.STONE_HOE, Material.GOLD_HOE, Material.IRON_HOE,
-+                Material.DIAMOND_HOE, Material.DIAMOND_PICKAXE};
-+    }
-+
-+    /**
-+     * Returns the maximum duration of the match, in seconds.
-+     * By default, this is set to 900 seconds. (15 minutes)
-+     * <p>
-+     * As documented, the match automatically ends if this time out
-+     * out, even if the objective of the gamemode is not fulfilled.
-+     *
-+     * @return The maximum duration of the match.
-+     */
-+    public long getMatchDuration() {
-+        return (Long) attributes.get("matchDuration");
-+    }
-+
-+    /**
-+     * Sets the maximum duration of the match, in seconds.
-+     * See more documentation of match duration above.
-+     *
-+     * @param matchDuration The maximum duration of the match.
-+     */
-+    protected void setMatchDuration(long matchDuration) {
-+        attributes.put("matchDuration", matchDuration);
-+    }
-+
-+    /**
-+     * This function should conventionally return a converted
-+     * form of the specSpawn field. This should be done by
-+     * your program's extension of this map framework class.
-+     *
-+     * @return The spectator spawn for the map.
-+     */
-+    public abstract Location getSpectatorSpawn();
-+
-+    /**
-+     * Sets where the spectators will spawn before, during, and after the match.
-+     * Extend this procedure in your readySpawns() procedure for consistency.
-+     *
-+     * @param spectatorSpawn The spectator spawn.
-+     */
-+    protected void setSpectatorSpawn(SerializedLocation spectatorSpawn) {
-+        this.specSpawn = spectatorSpawn;
-+    }
-+
-+    /**
-+     * After a WarTeam is created, it should be registered into the Key/Value set.
-+     * These should never be modified, since they are used by the gamemode runtime.
-+     *
-+     * @param team The team to register.
-+     */
-+    protected void registerTeam(WarTeam team) {
-+        if (team == null) {
-+            main.plugin().log("We failed to load the team as it was null!");
-+            return;
-+        }
-+        teams.put(team.toString(), team);
-+    }
-+
-+    /**
-+     * Returns all registered teams.
-+     * This should be used by the active gamemode to handle teams.
-+     *
-+     * @return All registered teams.
-+     * @see WarMode
-+     */
-+    public Collection<WarTeam> getTeams() {
-+        return teams.values();
-+    }
-+
-+    /**
-+     * Returns the list of spawns for a team.
-+     * You may insert the Team object as the parameter,
-+     * since toString() returns the Team's name.
-+     *
-+     * @param team The team's scoreboard name.
-+     * @return The team's spawn list.
-+     */
-+    public ArrayList<SerializedLocation> getTeamSpawns(String team) {
-+        return teamSpawns.get(team);
-+    }
-+
-+    /**
-+     * Adds a spawnpoint to a team.
-+     * !IMPORTANT! Never do this before registering teams! Bad things will happen!
-+     *
-+     * @param team  The team to add the spawn to.
-+     * @param spawn The team's spawn.
-+     */
-+    protected void addTeamSpawn(WarTeam team, SerializedLocation spawn) {
-+        if (!teamSpawns.containsKey(team.toString()))
-+            teamSpawns.put(team.toString(), new ArrayList<>()); // Initialize the array list first!
-+        teamSpawns.get(team.toString()).add(spawn); // Add the team spawn to the team's spawn list.
-+    }
-+
-+    /**
-+     * Returns the designated name for this map.
-+     *
-+     * @return The map name.
-+     */
-+    public String getMapName() {
-+        return mapName;
-+    }
-+
-+    /**
-+     * Sets the designated name for this map.
-+     *
-+     * @param mapName The name of the map.
-+     */
-+    protected void setMapName(String mapName) {
-+        this.mapName = mapName;
-+    }
-+
-+    /**
-+     * Returns the creators of this map.
-+     *
-+     * @return The creators of this map.
-+     */
-+    public UUID[] getCreators() {
-+        return creators;
-+    }
-+
-+    /**
-+     * Handy little method that creates a UUID from a string.
-+     *
-+     * @param fromString String to make UUID from.
-+     * @return Resulting UUID.
-+     */
-+    protected UUID id(String fromString) {
-+        return UUID.fromString(fromString);
-+    }
-+
-+    /**
-+     * Checks if a UUID is also a creator of this map.
-+     *
-+     * @param uuid UUID to check.
-+     * @return Are they a creator?
-+     */
-+    public boolean isCreator(UUID uuid) {
-+        for (UUID toCompare : getCreators())
-+            if (toCompare.equals(uuid)) return true;
-+        return false;
-+    }
-+
-+    /**
-+     * Sets the creators of this map. Please ensure you know how
-+     * universially unique idenfiers work and how to get your IGN's
-+     * UUID.
-+     *
-+     * @param creators The creators of this map.
-+     * @see UUID
-+     */
-+    protected void setCreators(UUID[] creators) {
-+        this.creators = creators;
-+    }
-+
-+    /**
-+     * Returns whether the map is currently being played this match.
-+     * This active state is automatically controlled by the gamemode.
-+     *
-+     * @return Whether the map is active or not.
-+     */
-+    public boolean isActive() {
-+        return active;
-+    }
-+
-+    /**
-+     * Sets this map to 'active', designating that it is the map being
-+     * played this match. The gamemode controls this attribute.
-+     *
-+     * @param active Whether the map is active or not.
-+     */
-+    protected void setActive(boolean active) {
-+        this.active = active;
-+    }
-+
-+    /**
-+     * If block breaking is disabled, and explosions are disabled,
-+     * explosions will not damage the terrain of the map.
-+     *
-+     * @param event An event called by the server.
-+     */
-+    @EventHandler
-+    public void entityExplode(EntityExplodeEvent event) {
-+        if (!(Boolean) attributes.get("blockBreak") && !(Boolean) attributes.get("blockExplode"))
-+            event.blockList().clear();
-+    }
-+
-+    /**
-+     * Causes any disabled drops to be removed from the "drop list"
-+     * when a player dies and drops all their items.
-+     *
-+     * @param event An event called by the server.
-+     */
-+    @EventHandler
-+    public void entityDeath(PlayerDeathEvent event) {
-+        for (ItemStack drop : event.getDrops()) {
-+            if (Arrays.asList(disabledDrops).contains(drop.getType()))
-+                drop.setType(Material.AIR);
-+        }
-+    }
-+
-+    /**
-+     * If fire spreading is disabled, blocks will not catch on fire or spread.
-+     *
-+     * @param event An event called by the server.
-+     */
-+    @EventHandler
-+    public void onBlockSpread(BlockSpreadEvent event) {
-+        if (event.getSource().getType() == Material.FIRE && !(Boolean) attributes.get("fireSpread"))
-+            event.setCancelled(true);
-+    }
-+
-+    /**
-+     * This procedure shares the same rule as onBlockSpread(event);
-+     *
-+     * @param event An event called by the server.
-+     */
-+    @EventHandler
-+    public void onIgnite(BlockIgniteEvent event) {
-+        if (event.getCause() == BlockIgniteEvent.IgniteCause.SPREAD && !(Boolean) attributes.get("fireSpread"))
-+            event.setCancelled(true);
-+    }
-+
-+    /**
-+     * This procedure shares the same rule as onBlockSpread(event);
-+     *
-+     * @param event An event called by the server.
-+     */
-+    @EventHandler
-+    public void onBurn(BlockBurnEvent event) {
-+        if (!(Boolean) attributes.get("fireSpread")) event.setCancelled(true);
-+    }
-+
-+    /**
-+     * If block breaking is disabled, paintings/item frames cannot be broken.
-+     *
-+     * @param event An event called by the server.
-+     */
-+    @EventHandler
-+    public void hngbrk(HangingBreakEvent event) {
-+        if (!(Boolean) attributes.get("blockBreak")) event.setCancelled(true);
-+    }
-+
-+    /**
-+     * If block breaking is disabled, paintings/item frames cannot be broken.
-+     *
-+     * @param event An event called by the server.
-+     */
-+    @EventHandler
-+    public void hngbrk(EntityDamageEvent event) {
-+        if (!(Boolean) attributes.get("blockBreak") && event.getEntity() instanceof Hanging) event.setCancelled(true);
-+    }
-+
-+    /**
-+     * If block breaking is disabled, blocks will re-appear when broken.
-+     *
-+     * @param event An event called by the server.
-+     */
-+    @EventHandler(priority = EventPriority.HIGHEST)
-+    public void brk(BlockBreakEvent event) {
-+        if (event.isCancelled()) return;
-+        if (!(Boolean) attributes.get("blockBreak")) {
-+            if (main.match().isAffected(event.getPlayer())) {
-+                event.setCancelled(true);
-+                main.warn(event.getPlayer(), main.message("guard.building"));
-+            }
-+        }
-+    }
-+
-+    /**
-+     * If block placing is disabled, blocks will disappear when placed.
-+     * Also blocks building outside the defined boundary.
-+     *
-+     * @param event An event called by the server.
-+     */
-+    @EventHandler(priority = EventPriority.HIGHEST)
-+    public void plc(BlockPlaceEvent event) {
-+        if (event.isCancelled()) return;
-+        if (!(Boolean) attributes.get("blockPlace")) {
-+            if (main.match().isAffected(event.getPlayer())) {
-+                event.setCancelled(true);
-+                main.warn(event.getPlayer(), main.message("guard.building"));
-+            }
-+        } else if (attributes.containsKey("boundary")) {
-+            Location placed = event.getBlock().getLocation();
-+            SerializedLocation bl = (SerializedLocation) attributes.get("bottomLeft");
-+            SerializedLocation tr = (SerializedLocation) attributes.get("topRight");
-+            if (main.match().isAffected(event.getPlayer()) && (placed.getX() < bl.x() || placed.getZ() < bl.z() || placed.getX() > tr.x() || placed.getZ() > tr.z())) {
-+                event.setCancelled(true);
-+                main.warn(event.getPlayer(), main.message("guard.border"));
-+            }
-+        } else if (attributes.containsKey("plateau")) {
-+            int plateauY = (int) attributes.get("plateau");
-+            Location equiv = event.getBlock().getLocation().clone();
-+            equiv.setY(plateauY);
-+            if (equiv.getBlock().getType() != Material.BEDROCK) {
-+                event.setCancelled(true);
-+                main.warn(event.getPlayer(), main.message("guard.border"));
-+            }
-+        } else if (attributes.containsKey("buildHeight")) {
-+            int buildHeight = (int) attributes.get("buildHeight");
-+            if (event.getBlock().getY() > buildHeight) {
-+                event.setCancelled(true);
-+                main.warn(event.getPlayer(), main.message("guard.highest"));
-+            }
-+        }
-+    }
-+}
-diff --git a/src/sbs/mira/pvp/framework/game/WarMode.java b/src/sbs/mira/pvp/framework/game/WarMode.java
-new file mode 100644
-index 0000000..9d22308
---- /dev/null
-+++ b/src/sbs/mira/pvp/framework/game/WarMode.java
-@@ -0,0 +1,634 @@
-+package sbs.mira.pvp.framework.game;
-+
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.event.MatchEndEvent;
-+import sbs.mira.pvp.framework.event.MatchPlayerJoinEvent;
-+import sbs.mira.pvp.framework.event.MatchPlayerLeaveEvent;
-+import sbs.mira.pvp.framework.stored.SerializedLocation;
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.framework.util.WarMatch;
-+import net.md_5.bungee.api.chat.TextComponent;
-+import net.minecraft.server.v1_12_R1.*;
-+import org.bukkit.Bukkit;
-+import org.bukkit.ChatColor;
-+import org.bukkit.GameMode;
-+import org.bukkit.OfflinePlayer;
-+import org.bukkit.craftbukkit.v1_12_R1.inventory.CraftItemStack;
-+import org.bukkit.entity.Player;
-+import org.bukkit.event.HandlerList;
-+import org.bukkit.event.Listener;
-+import org.bukkit.scheduler.BukkitTask;
-+import org.bukkit.scoreboard.Scoreboard;
-+import org.bukkit.scoreboard.Team;
-+
-+import java.util.*;
-+
-+/**
-+ * This extensible class handles all gamemode-related
-+ * function that is commonly shared among classes.
-+ * When creating new gamemodes, make sure they extend
-+ * this class otherwise the program will NOT work.
-+ * <p>
-+ * Created by Josh on 20/03/2017.
-+ *
-+ * @author s101601828 @ Swin.
-+ * @version 1.0
-+ * @since 1.0
-+ */
-+public abstract class WarMode implements Listener {
-+
-+    private final Random rng; // A random number generator for any usage.
-+    protected boolean permaDeath; // Specifies that permanent death is enabled.
-+    protected boolean active; // Whether or not this class is active during a match.
-+    protected MiraPulse main; // The WarManager instance. This allows access to all other crucial modules.
-+    // !! IMPORTANT !! //
-+    /* Ensure that these fields are initialized & freed when needed. */
-+    private BukkitTask runtimeTask; // Global gamemode-specific runtime task.
-+    private Team spec; // Holds the Spigot team extension for the spectators.
-+    private int timeElapsed; // Specifies the number of seconds elapsed during the match.
-+    private Scoreboard score; // Holds the Spigot scoreboard extension that players see.
-+    private WarMap map; // The map currently associated with this gamemode.
-+    /* HashMaps that must be initialized/freed on a match start/end. */
-+    private HashMap<String, WarTeam> teams; // Temporary Key/Value set to hold maps for the match.
-+    private HashMap<String, ArrayList<SerializedLocation>> teamSpawns; // Temporary Key/Value set to hold Team spawns.
-+
-+    /**
-+     * Since this class is intialized through reflections,
-+     * no parameters can be included in the constructor.
-+     * <p>
-+     * To work around this, init() is called after the
-+     * class has actually been initialized to set values.
-+     */
-+    public WarMode() {
-+        // Call init() externally
-+        rng = new Random();
-+    }
-+
-+    /**
-+     * Calling this procedure is IMPORTANT. The program will
-+     * NOT work if you do not define the WarManager instance.
-+     * <p>
-+     * You only need to call this ONCE.
-+     *
-+     * @param main The WarManager instance.
-+     */
-+    public void init(MiraPulse main) {
-+        this.main = main;
-+        teams = new HashMap<>(); // The Key/Value set only needs to be cleared on a match end. Do not null or free it.
-+        teamSpawns = new HashMap<>(); // The same as above applies to the spawns. Please clear instead of nulling.
-+    }
-+
-+    /**
-+     * Required procedure in all external classes.
-+     * Configure this procedure to reset everything that needs
-+     * to be fresh for when the gamemode is activated once
-+     * again. i.e. Team Death Match scores, etc.
-+     */
-+    public abstract void reset();
-+
-+    /**
-+     * Possible required procedure in your Gamemode extension.
-+     * Configure this procedure to reset everything that needs
-+     * to be fresh for when the gamemode is activated once
-+     * again. i.e. Statistics.
-+     */
-+    public abstract void resetCommon();
-+
-+    /**
-+     * ! IMPORTANT !
-+     * ! DO NOT CONFUSE THIS WITH INIT()!
-+     * <p>
-+     * This procedure should be configured in a way that all
-+     * appropriate values are loaded into the gamemode class
-+     * when the map is loaded also.
-+     * <p>
-+     * Do NOT load or change any fields that are a member of
-+     * this abstract class. Only initialize what is needed for
-+     * the specific gamemode, such as the TDM scores being set to 0.
-+     */
-+    public abstract void initialize();
-+
-+    /**
-+     * This procedure is very similar to initialize().
-+     * This should be extended in your Gamemode class
-+     * to reset local, common variables in it.
-+     * <p>
-+     * i.e. Statistics counters
-+     */
-+    public abstract void initializeCommon();
-+
-+    /**
-+     * This function simply makes a call to the gamemode
-+     * to update every player's scoreboard. This should be
-+     * done whenever a score changes, such as the amount of
-+     * points a team has on Team Death Match.
-+     * <p>
-+     * Try not to call this too much, as it is intensive and
-+     * can flicker a lot if not used carefully.
-+     * <p>
-+     * If the gamemode doesn't use a scoreboard, ignore this.
-+     *
-+     * @see org.bukkit.scoreboard.Scoreboard
-+     */
-+    public abstract void updateScoreboard();
-+
-+    /**
-+     * This documentation will explain the 4 below functions:
-+     * <p>
-+     * 1. Returns the shortened abbreviation of a gamemode. i.e. TDM.
-+     * 2. Returns the full gamemode name. i.e. Team Death Match.
-+     * 3. Returns the offensive tactic. i.e. Kill enemy players!
-+     * 4. Returns the defensive tactic. i.e. Protect your teammates!
-+     *
-+     * @return The relevant result for the requested function.
-+     */
-+    public abstract String getName();
-+
-+    public abstract String getFullName();
-+
-+    public abstract String getOffensive();
-+
-+    public abstract String getDefensive();
-+
-+    /**
-+     * Returns the correct grammar of the WarMode for broadcasts.
-+     * For example, 'a' TDM, or 'an' FFA.
-+     * 1. The current match is a TDM at This Map!
-+     * 2. The current match is an FFA at This Map!
-+     * <p>
-+     * You wouldn't say an TDM or a FFA, would you?
-+     *
-+     * @return The correct grammar of the WarMode.
-+     */
-+    public abstract String getGrammar();
-+
-+    /**
-+     * A procedure that is run when a player dies.
-+     * You must configure this yourself in an external gamemode class.
-+     * <p>
-+     * This procedure is automatically called when a player dies.
-+     * onDeath() is called when there is no killer repsonsible.
-+     *
-+     * @param killed The player who died.
-+     * @param killer The player's killer.
-+     * @see org.bukkit.event.entity.PlayerDeathEvent below.
-+     * <p>
-+     * An example of this procedure would be to credit the killer's team 1 point in TDM.
-+     */
-+    public abstract void onKill(MiraPlayer killed, MiraPlayer killer);
-+
-+    /**
-+     * A procedure that is run when a player dies.
-+     * This is different to onKill, because no player
-+     * was responsible for the player's death.
-+     * You must configure this yourself in an external gamemode class.
-+     * <p>
-+     * This procedure is automatically called when a player dies.
-+     *
-+     * @param killed The player who died.
-+     * @see org.bukkit.event.entity.PlayerDeathEvent below.
-+     * <p>
-+     * An example of this procedure would be to credit the killer's team 1 point in TDM.
-+     */
-+    public abstract void onDeath(MiraPlayer killed);
-+
-+    /**
-+     * Called when a player leaves.
-+     * You must configure this yourself in an external gamemode class.
-+     * As stated above, this is called automatically.
-+     * <p>
-+     * An example of this procedure would be to penalize a team or modify
-+     * the match in some way to compensate for the player leaving.
-+     * i.e. a flagholder in CTF leaving the match.
-+     *
-+     * @param left The player who left.
-+     */
-+    public abstract void onLeave(MiraPlayer left);
-+
-+    /**
-+     * This performs the opposite of above, so read the documentation
-+     * that is provided above. Please extend and utilise.
-+     * <p>
-+     * An example of this procedure would be to modify the match in
-+     * some way to compensate for the player joining.
-+     * <p>
-+     * i.e. to display appropriate data to the
-+     * player depending on what team they joined.
-+     *
-+     * @param joined The player who joined.
-+     */
-+    public abstract void onJoin(MiraPlayer joined);
-+
-+    /**
-+     * A function that is run when the match is ended.
-+     * This is an essential function in gamemode management.
-+     * It must be called when the objective is fulfilled or
-+     * if an operator decides to end the match with a command.
-+     * <p>
-+     * This calls decideWinner(), so any gamemode-specific
-+     * conclusion logic should be done there, such as broadcasting
-+     * the winning team or player and the results.
-+     */
-+    public void onEnd() {
-+        if (runtimeTask != null) {
-+            runtimeTask.cancel();
-+            decideWinner();
-+        }
-+        finish();
-+    }
-+
-+    /**
-+     * A function that was briefly explained in onEnd().
-+     * Any gamemode-specific conclusion logic should be
-+     * done here, such as broadcasting the winning team
-+     * or player and the results.
-+     * <p>
-+     * i.e. in Team Death Match
-+     * -> Broadcast the team(s) with the most points
-+     * -> Broadcast the final results of each team
-+     */
-+    protected abstract void decideWinner();
-+
-+    /**
-+     * Returns the gamemode's loaded teams, if any.
-+     * Teams should only be loaded in this gamemode
-+     * if there is a match running and this was the
-+     * gamemode that was selected.
-+     *
-+     * @return The active teams Key/Value set.
-+     */
-+    public Collection<WarTeam> getTeams() {
-+        return teams.values();
-+    }
-+
-+    /**
-+     * This procedure should be called from the external class
-+     * once a match has fulfilled its criteria.
-+     * <p>
-+     * i.e. time running out in TDM,
-+     * i.e. reaching score cap in FFA, etc.
-+     */
-+    private void finish() {
-+        main.plugin().getServer().getPluginManager().callEvent(new MatchEndEvent()); // Call a custom event.
-+        setActive(false); // Sets the gamemode instance to inactive.
-+        if (teamSpawns != null)
-+            teamSpawns.clear(); // CLEAR the Key/Value set, do not free it.
-+        main.match().matchEnd();
-+    }
-+
-+    /**
-+     * Increases the time elapsed in the match by 1.
-+     * This procedure is automatically called every
-+     * second by the runtimeTask.
-+     *
-+     * @see org.bukkit.scheduler.BukkitRunnable;
-+     */
-+    private void incrementTimeElapsed() {
-+        timeElapsed += 1;
-+    }
-+
-+    /**
-+     * Returns the amount of time elapsed during this match.
-+     *
-+     * @return The amount of time elapsed.
-+     */
-+    public int getTimeElapsed() {
-+        return timeElapsed;
-+    }
-+
-+    /**
-+     * Sets -specifically- the amount of time elapsed
-+     * in the match. Mainly for debugging purposes.
-+     */
-+    public void setTimeElapsed(int timeElapsed) {
-+        this.timeElapsed = timeElapsed;
-+    }
-+
-+    /**
-+     * Returns whether or not the current gamemode has permanent
-+     * death enabled. This should be used when respawning to not
-+     * notify the player that they will respawn as it is permanent
-+     * death.
-+     *
-+     * @return Perma death?
-+     */
-+    public boolean isPermaDeath() {
-+        return permaDeath;
-+    }
-+
-+    /**
-+     * Returns the current map associated with this gamemode
-+     * during the current match. This is stored temporarily
-+     * so certain attributes in the WarMap class can be accessed
-+     * during runtime.
-+     *
-+     * @return The current associated map.
-+     */
-+    protected WarMap map() {
-+        return map;
-+    }
-+
-+    /**
-+     * Awaken this gamemode for the match. A -LOT- of things
-+     * will be done automatically here, and will be documented.
-+     * <p>
-+     * In a nutshell, once everything is good to go and the match
-+     * has started, this will awaken the gamemode and objectives
-+     * will become available.
-+     *
-+     * @see java.lang.Runnable
-+     * @see org.bukkit.scheduler.BukkitScheduler
-+     */
-+    @SuppressWarnings("unchecked")
-+    public void activate() {
-+        main.plugin().getServer().getPluginManager().registerEvents(this, main.plugin()); // Allows the server to listen in on events for this gamemode class.
-+        map = main.cache().getCurrentMap();
-+
-+        for (WarTeam team : map().getTeams())
-+            // Copies every WarTeam defined in the map over to the gamemode!
-+            teams.put(team.getTeamName(), team.clone());
-+
-+        // Copies every spawnpoint for every team defined in the map also!
-+        teamSpawns = (HashMap<String, ArrayList<SerializedLocation>>) map().teamSpawns.clone();
-+
-+        setActive(true); // Sets this gamemode as active and will be recognised as so by the program.
-+        score = main.plugin().getServer().getScoreboardManager().getNewScoreboard(); // Create a new scoreboard. (Spigot)
-+
-+        for (WarTeam team : teams.values()) {
-+            Team lTeam = score.registerNewTeam(team.getTeamName()); // Creates a Spigot Team instance for this team.
-+            team.setBukkitTeam(lTeam); // Assigns the Spigot Team to the copied WarTeam instance.
-+            lTeam.setCanSeeFriendlyInvisibles(true); // Allows teammates to see each other when visible. (Spigot)
-+            lTeam.setAllowFriendlyFire(false); // Disables friendly fire for teammates. (Spigot)
-+            lTeam.setPrefix(team.getTeamColor() + ""); // Sets the player's name color to the team's color. (Spigot)
-+        }
-+
-+        spec = score.registerNewTeam("Spectators"); // Manually defines the spectator team. (Spigot)
-+        spec.setCanSeeFriendlyInvisibles(true); // Allows spectators to see each other. (Spigot)
-+        spec.setAllowFriendlyFire(false); // Disables friendly fire. (Spigot)
-+        spec.setPrefix(ChatColor.LIGHT_PURPLE + ""); // Spectators are purple!!! (Spigot)
-+
-+        for (MiraPlayer wp : main.getWarPlayers().values())
-+            spec.addPlayer(wp.crafter()); // Adds every player to the spectator team by default. (Spigot)
-+
-+        initializeCommon(); // Initializes common values in the extended gamemode class.
-+        initialize(); // Initializes everything in the external gamemode class!
-+
-+        // Defines the plugin executing the timer and the runnable interface. (Spigot)
-+        runtimeTask = Bukkit.getScheduler().runTaskTimer( // Runs a task timer at a regular interval. (Spigot)
-+                main.plugin(), () -> {
-+                    if (main.match().getStatus() != WarMatch.Status.PLAYING) {
-+                        // Cancel this if the match is not currently active.
-+                        runtimeTask.cancel();
-+                        return;
-+                    }
-+                    incrementTimeElapsed(); // Increments the time elapsed, every second!
-+
-+                    long timeLeft = getMatchDuration() - getTimeElapsed(); // Calculates the amount of time remaining.
-+                    if (timeLeft % 60 == 0 && timeLeft != 0) { // Checks that the time is a remainder of
-+                        long minutes = (timeLeft / 60); // Calculates number of minutes remaining.
-+                        String s = (minutes == 1 ? "" : "s"); // Should it be 'minute' or 'minutes'?
-+
-+                        // Broadcasts the amount of minutes remaining.
-+                        Bukkit.broadcastMessage("There is " + minutes + " minute" + s + " remaining!");
-+                    } else if (timeLeft == 30) {
-+                        // Broadcasts that there is 30 seconds remaining.
-+                        Bukkit.broadcastMessage("There is " + timeLeft + " seconds remaining!");
-+                    } else if (timeLeft < 6 && timeLeft > 0) {
-+                        String s = (timeLeft == 1 ? "" : "s"); // Calculates number of seconds remaining.
-+
-+                        // Broadcasts the amount of seconds.
-+                        Bukkit.broadcastMessage("There is " + timeLeft + " second" + s + " remaining!");
-+                    }
-+
-+                    tick(); // Allows the external class to execute certain procedures every second too.
-+
-+                    if (getTimeElapsed() >= getMatchDuration())
-+                        onEnd(); // If the time is up, end the match even if the objective is not complete.
-+                }, 0L, 20L); // Have a 0 tick delay before starting the task, and repeat every 20 ticks.
-+        // ! IMPORTANT ! A 'tick' is a 20th of a second. Minecraft servers run at 20 ticks per second. (TPS)
-+    }
-+
-+    /**
-+     * Automatically balances everyone onto teams.
-+     */
-+    protected void autoAssign() {
-+        // Keep a temporary list of people who have not being assigned to a team.
-+        ArrayList<MiraPlayer> targets = new ArrayList<>(main.getWarPlayers().values());
-+        while (targets.size() != 0) { // Keep looping until this array is empty.
-+            MiraPlayer target = targets.get(rng.nextInt(targets.size())); // Gets a random player.
-+            if (target.isJoined()) {
-+                // If joined, use entryHandle() to put them on the lowest team.
-+                entryHandle(target);
-+                if (!target.isJoined()) {
-+                    // If, for some reason, they did not get put on a team, assume them as spectating.
-+                    target.crafter().setGameMode(GameMode.CREATIVE);
-+                    main.giveSpectatorKit(target);
-+                }
-+            } else {
-+                // They don't want to play. Assume them as spectating.
-+                target.crafter().setGameMode(GameMode.CREATIVE);
-+                main.giveSpectatorKit(target);
-+            }
-+            targets.remove(target);
-+        }
-+    }
-+
-+    /**
-+     * This procedure is automatically called by the runtimeTask
-+     * every 20 ticks, or every 1 second. You must configure this
-+     * procedure, but you don't have to use it if it isn't needed.
-+     * <p>
-+     * An example usage of this would be to shoot up a firework every
-+     * 20 ticks at a flagholder's location to show everyone else where
-+     * they currently are.
-+     */
-+    public abstract void tick();
-+
-+    /**
-+     * This procedure incapacitates the gamemode after the match
-+     * has been completed. Listeners are disabled, and all fields
-+     * that were changed during the match are reset.
-+     */
-+    public void deactivate() {
-+        if (runtimeTask != null) runtimeTask.cancel(); // If the task isn't null already, cancel the task first.
-+        runtimeTask = null; // Free up the task in memory.
-+        HandlerList.unregisterAll(this); // Unregister all listener handlers for this class. (Spigot)
-+        setActive(false); // Sets this gamemode as inactive and will be ignored by the program.
-+        resetCommon(); // Resets common values in external Gamemode class.
-+        reset(); // Resets any other values in the external class.
-+        resetLocalValues(); // Resets values defined in this class as stated below.
-+        map = null; // Frees up the currently playing map's assignment in memory.
-+    }
-+
-+    /**
-+     * Similar to reset(), this procedure will automatically
-+     * reset any values that are commonly shared amongst all
-+     * gamemode classes, such as the time elapsed.
-+     */
-+    private void resetLocalValues() {
-+        timeElapsed = 0; // Sets time elapsed back to 0 seconds.
-+        permaDeath = false; // Sets permadeath for this gamemode back to the default of false.
-+
-+        for (WarTeam team : teams.values()) {
-+            for (OfflinePlayer pl : team.getBukkitTeam().getPlayers())
-+                team.getBukkitTeam().removePlayer(pl); // Removes the player from the defined Spigot team. (Spigot)
-+            team.setBukkitTeam(null); // Sets the associated Spigot team to null to free up memory.
-+        }
-+        spec = null; // Removes the spectator team to free up memory.
-+        score = Bukkit.getScoreboardManager().getNewScoreboard(); // Re-assign the scoreboard field with a fresh one.
-+        if (teams != null)
-+            teams.clear(); // Clear associated teams to free up memory.
-+    }
-+
-+    /**
-+     * Quick function to return the global Scoreboard.
-+     * This is to make the code look cleaner.
-+     *
-+     * @return The scoreboard associated with this gamemode.
-+     */
-+    public Scoreboard s() {
-+        return score;
-+    }
-+
-+    /**
-+     * Returns whether or not this gamemode is marked
-+     * as active or not. A gamemode should only be marked
-+     * as active when the match playing is the gamemode
-+     * in question.
-+     *
-+     * @return Whether the gamemode is active or not.
-+     */
-+    private boolean isActive() {
-+        return active;
-+    }
-+
-+    /**
-+     * Sets the gamemode as 'active' or not.
-+     * As stated above, only the associated gamemode
-+     * should be marked as active during a match.
-+     *
-+     * @param active Whether the core is active or not.
-+     */
-+    private void setActive(boolean active) {
-+        this.active = active;
-+    }
-+
-+    /**
-+     * Handles entry into and out of the match.
-+     * If the player tries to enter a match during permadeath, deny it.
-+     * If the player joins, assign their team and call onJoin().
-+     * If the player leaves, disassociate them and call onLeave();
-+     * If the match is permadeath, do not message the player.
-+     *
-+     * @param wp         The player to handle.
-+     * @param preference What team the player would like to be on. (if supplied)
-+     */
-+    public void entryHandle(MiraPlayer wp, WarTeam... preference) {
-+        Player pl = wp.crafter(); // Returns Spigot's implementation of Player. (Spigot)
-+        if (!isActive()) return; // If this gamemode is not active, do not execute anything.
-+        if (permaDeath && wp.isJoined()) {
-+            // Alert the player that permanent death is enabled and cancel the entry.
-+            pl.sendMessage("You are too late to join!");
-+            wp.setJoined(false);
-+        } else if (wp.isJoined()) {
-+            // Assign the player to their team and call onJoin() for the external class.
-+            if (preference != null && preference.length == 1)
-+                carryOutTeam(wp, preference[0]);
-+            else
-+                carryOutTeam(wp, getSmallestTeam());
-+            main.plugin().getServer().getPluginManager().callEvent(new MatchPlayerJoinEvent(wp)); // Call an event.
-+        } else { // If the player did not join, execute a leaving handle.
-+            if (!permaDeath)
-+                pl.sendMessage("You have left the match!"); // Alert the player physically if this is not a permadeath match.
-+            WarTeam team = wp.getCurrentTeam(); // Returns the player's associated team for temporary use.
-+            wp.setCurrentTeam(null); // Disassociates the player with their team.
-+            pl.teleport(map().getSpectatorSpawn()); // Teleports the player to the map's spectator spawnpoint. (Spigot)
-+            pl.setGameMode(GameMode.CREATIVE); // Sets the player to spectator mode. (Spigot)
-+            team.getBukkitTeam().removeEntry(pl.getName()); // Removes the player from their Spigot team. (Spigot)
-+            spec.addEntry(pl.getName()); // Assigns the player to the spectator team. (Spigot).
-+            main.items().clear(wp); // Clears the player's inventory.
-+            main.giveSpectatorKit(wp); // Gives the player a spectator kit.
-+            onLeave(wp); // Calls onLeave() for the external class.
-+            main.plugin().getServer().getPluginManager().callEvent(new MatchPlayerLeaveEvent(wp)); // Call an event.
-+        }
-+    }
-+
-+    /**
-+     * If the player is joining the match, this procedure
-+     * acts to carry out the player to an assigned team.
-+     * <p>
-+     * This procedure assigns the player to a team.
-+     * <p>
-+     * //TODO: Add team preference for debug?
-+     *
-+     * @param dp   The player to assign a team.
-+     * @param team The team to assign to a player.
-+     */
-+    private void carryOutTeam(MiraPlayer dp, WarTeam team) {
-+        Player pl = dp.crafter(); // Assigns Spigot player implementation.
-+
-+        if (team.isFull()) {
-+            //
-+            pl.sendMessage("All teams are full, please try joining later.");
-+            dp.setJoined(false);
-+            return;
-+        }
-+
-+        pl.teleport(randomSpawnFrom(teamSpawns.get(team.getTeamName())).toLocation(main.match().getCurrentWorld(), true)); // Teleports player to random team spawnpoint. (Spigot)
-+        pl.setGameMode(GameMode.SURVIVAL); // Sets the player's gamemode to survival. (Spigot)
-+        pl.setFallDistance(0F); // Reset fall distance. (Spigot)
-+        dp.setCurrentTeam(team); // Assigns the player's team.
-+        spec.removeEntry(pl.getName()); // Removes the player from the spectator team. (Spigot)
-+        team.getBukkitTeam().addEntry(pl.getName()); // Assigns the player to the team's Spigot team. (Spigot)
-+        map().applyInv(dp); // Applies the map's inventory to the player.
-+
-+        TextComponent comp = new TextComponent("You have joined the ");
-+        comp.addExtra(team.getHoverInformation());
-+        pl.spigot().sendMessage(comp);
-+
-+        onJoin(dp);
-+    }
-+
-+    /**
-+     * Searches through all current teams in the match for
-+     * the team with the least amount of members.
-+     *
-+     * @return The team with the least members.
-+     */
-+    private WarTeam getSmallestTeam() {
-+        WarTeam found = null; // The 'result' field.
-+        int size = -1; // The initial 'highest' size.
-+        for (WarTeam team : teams.values()) { // Loops through every team.
-+            if (size == -1) {
-+                found = team; // Recognises this team as the one with the least amount of members.
-+                size = team.getBukkitTeam().getEntries().size(); // Assigns the lowest amount of members to the amount of members in this team.
-+            } else if (team.getBukkitTeam().getEntries().size() < size) {
-+                found = team; // Sets this as the smallest team.
-+                size = team.getBukkitTeam().getEntries().size(); // Assigns new smallest team size.
-+            }
-+        }
-+        return found;
-+    }
-+
-+    /**
-+     * Returns how long the map is configured to run for.
-+     * All maps must end after a certain period of time.
-+     *
-+     * @return The duration of the map.
-+     */
-+    private Long getMatchDuration() {
-+        return (Long) map().attributes.get("matchDuration");
-+    }
-+
-+    /**
-+     * Randomly picks a value from a list.
-+     * This is just to randomly return a team spawn.
-+     *
-+     * @param array The list.
-+     * @return The value.
-+     */
-+    protected SerializedLocation randomSpawnFrom(List<SerializedLocation> array) {
-+        Random picker = new Random();
-+        return array.get(picker.nextInt(array.size()));
-+    }
-+}
-diff --git a/src/sbs/mira/pvp/framework/game/WarTeam.java b/src/sbs/mira/pvp/framework/game/WarTeam.java
-new file mode 100644
-index 0000000..ba4a033
---- /dev/null
-+++ b/src/sbs/mira/pvp/framework/game/WarTeam.java
-@@ -0,0 +1,213 @@
-+package sbs.mira.pvp.framework.game;
-+
-+import net.md_5.bungee.api.chat.ComponentBuilder;
-+import net.md_5.bungee.api.chat.HoverEvent;
-+import net.md_5.bungee.api.chat.TextComponent;
-+import org.bukkit.ChatColor;
-+import org.bukkit.scoreboard.Team;
-+
-+
-+/**
-+ * This (non-extendable) class handles all
-+ * Team-based interactions by the Gamemode.
-+ *
-+ * @author s101601828 @ Swin.
-+ * @version 1.0
-+ * @see org.bukkit.scoreboard.Scoreboard
-+ * @see org.bukkit.scoreboard.Team
-+ * <p>
-+ * Created by Josh on 20/03/2017.
-+ * @since 1.0
-+ */
-+public final class WarTeam {
-+
-+    /* BEGIN RECORD */
-+    private final String teamName;
-+    private final ChatColor teamColor;
-+    private final Integer maxTeamSize;
-+    private final String scoreboardName;
-+    private Team bukkitTeam;
-+
-+    // Since the WarTeam is cloned upon usage, these variables reset.
-+    private int kills;
-+    private int deaths;
-+    /*  END RECORD  */
-+
-+    /**
-+     * Creates an instance of this record,
-+     * With a team limit & its own unique identifier.
-+     * All separate methods will call this.
-+     *
-+     * @param teamName       The team's name.
-+     * @param teamColor      The team's color.
-+     * @param maxTeamSize    The maximum amount of players allowed on this team.
-+     * @param scoreboardName The team's scoreboard name.
-+     */
-+    private WarTeam(String teamName, ChatColor teamColor, Integer maxTeamSize, String scoreboardName) {
-+        this.teamName = teamName;
-+        this.teamColor = teamColor;
-+        this.maxTeamSize = maxTeamSize;
-+        this.scoreboardName = scoreboardName;
-+        this.bukkitTeam = null;
-+        kills = 0;
-+        deaths = 0;
-+    }
-+
-+    /**
-+     * Creates an instance of this record,
-+     * With no team limit & its own unique identifier.
-+     *
-+     * @param teamName       The team's name.
-+     * @param teamColor      The team's color.
-+     * @param scoreboardName The team's scoreboard name.
-+     */
-+    public WarTeam(String teamName, ChatColor teamColor, String scoreboardName) {
-+        this(teamName, teamColor, -1, scoreboardName);
-+    }
-+
-+    /**
-+     * Creates an instance of this record,
-+     * With a team limit & no unique identifier.
-+     *
-+     * @param teamName    The team's name.
-+     * @param teamColor   The team's color.
-+     * @param maxTeamSize The maximum amount of players allowed on this team.
-+     */
-+    public WarTeam(String teamName, ChatColor teamColor, Integer maxTeamSize) {
-+        this(teamName, teamColor, maxTeamSize, teamName);
-+    }
-+
-+    /**
-+     * Creates an instance of this record,
-+     * Without a team limit or a unique identifier.
-+     *
-+     * @param teamName  The team's name.
-+     * @param teamColor The team's color.
-+     */
-+    public WarTeam(String teamName, ChatColor teamColor) {
-+        this(teamName, teamColor, -1, teamName);
-+    }
-+
-+    /**
-+     * Returns the name for the team that was
-+     * designated in the map configuration file.
-+     *
-+     * @return The Team's name.
-+     */
-+    public String getTeamName() {
-+        return teamName;
-+    }
-+
-+    /**
-+     * Returns the color for the team that was
-+     * designated in the map configuration file.
-+     *
-+     * @return The Team's designated color.
-+     */
-+    public ChatColor getTeamColor() {
-+        return teamColor;
-+    }
-+
-+    /**
-+     * Returns the maximum number of players
-+     * allowed on this team at any given time.
-+     *
-+     * @return Maximum team size.
-+     */
-+    private Integer getMaxTeamSize() {
-+        return maxTeamSize;
-+    }
-+
-+    /**
-+     * Returns the unique scoreboard identifier for this Team.
-+     *
-+     * @return The unique scoreboard identifier for this Team.
-+     */
-+    private String getScoreboardName() {
-+        return scoreboardName;
-+    }
-+
-+    /**
-+     * Returns the Spigot Team object
-+     * used at runtime during a match.
-+     *
-+     * @return The Spgiot Team.
-+     */
-+    public Team getBukkitTeam() {
-+        return bukkitTeam;
-+    }
-+
-+    /**
-+     * This method must be called on a cloned instantiation
-+     * of the class to implement Spigot's useful Team functions.
-+     *
-+     * @param bukkitTeam The Bukkit Team the gamemode will assign & control.
-+     */
-+    void setBukkitTeam(Team bukkitTeam) {
-+        this.bukkitTeam = bukkitTeam;
-+    }
-+
-+    /**
-+     * Returns whether or not the team is accepting any more members.
-+     *
-+     * @return Whether team is full or not.
-+     */
-+    boolean isFull() {
-+        return bukkitTeam.getEntries().size() >= maxTeamSize;
-+    }
-+
-+    /**
-+     * Returns useful information for those who hover over the team name.
-+     *
-+     * @return Hover information.
-+     */
-+    public TextComponent getHoverInformation() {
-+        TextComponent result = new TextComponent(getTeamColor() + "[" + getTeamName() + "]" + ChatColor.WHITE);
-+        result.setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, new ComponentBuilder("Members: " + getBukkitTeam().getEntries().size() + "/" + maxTeamSize + "\nKills: " + kills + "\nDeaths: " + deaths).create()));
-+        return result;
-+    }
-+
-+    /**
-+     * Creates an instantiated copy of this class and
-+     * any relevant fields needed for manipulation.
-+     *
-+     * @return A clean, usable copy of this class for runtime.
-+     */
-+    @Override
-+    public WarTeam clone() {
-+        return new WarTeam(getTeamName(), getTeamColor(), getMaxTeamSize(), getScoreboardName());
-+    }
-+
-+    /**
-+     * Makes toString() return the team's designated name.
-+     *
-+     * @return The team's name.
-+     */
-+    @Override
-+    public String toString() {
-+        return this.getTeamName();
-+    }
-+
-+    /**
-+     * Returns a colored team name string.
-+     *
-+     * @return The colored team name.
-+     */
-+    public String getDisplayName() {
-+        return getTeamColor() + getTeamName() + ChatColor.WHITE;
-+    }
-+
-+    /**
-+     * Adds a kill in favor of this team.
-+     */
-+    public void addKill() {
-+        kills++;
-+    }
-+
-+    /**
-+     * Adds a death in spite of this team.
-+     */
-+    public void addDeath() {
-+        deaths++;
-+    }
-+}
-diff --git a/src/sbs/mira/pvp/framework/stored/Activatable.java b/src/sbs/mira/pvp/framework/stored/Activatable.java
-new file mode 100644
-index 0000000..7c441ee
---- /dev/null
-+++ b/src/sbs/mira/pvp/framework/stored/Activatable.java
-@@ -0,0 +1,28 @@
-+package sbs.mira.pvp.framework.stored;
-+
-+/**
-+ * This interface adds an extra layer of selection when
-+ * needing to activate or de-activate classes in mass.
-+ * <p>
-+ * To use this class, implement it in another class and you
-+ * will be able to access the activate() and deactivate()
-+ * procedures from multiple but shared class types.
-+ *
-+ * @author s101601828 @ Swin.
-+ * @version 1.0
-+ *          <p>
-+ *          Created by Josh on 27/03/2017.
-+ * @since 1.0
-+ */
-+public interface Activatable {
-+
-+    /**
-+     * Activates the object.
-+     */
-+    void activate();
-+
-+    /**
-+     * Deactivates the object.
-+     */
-+    void deactivate();
-+}
-diff --git a/src/sbs/mira/pvp/framework/stored/SerializedLocation.java b/src/sbs/mira/pvp/framework/stored/SerializedLocation.java
-new file mode 100644
-index 0000000..74bda97
---- /dev/null
-+++ b/src/sbs/mira/pvp/framework/stored/SerializedLocation.java
-@@ -0,0 +1,94 @@
-+package sbs.mira.pvp.framework.stored;
-+
-+import org.bukkit.Location;
-+import org.bukkit.World;
-+
-+/**
-+ * This class is fundamentally the same as Spigot's Location
-+ * class (or record, since it holds extra data). However, this
-+ * 'Serialized' location does not require you to store an apparent
-+ * world, and only stores the XYZ coordinates of the location, to
-+ * which you may translate back into a Spigot Location provided
-+ * you supply a valid World instance using the Spigot API.
-+ * <p>
-+ * To use this class, use any of the 3 constructors below to
-+ * initialize and make use of the object.
-+ *
-+ * @author s101601828 @ Swin.
-+ * @version 1.0
-+ * @see org.bukkit.Location
-+ * <p>
-+ * Created by Josh on 27/03/2017.
-+ * @since 1.0
-+ */
-+public class SerializedLocation {
-+
-+    private final double x;
-+    private final double y;
-+    private final double z;
-+    private final float yaw;
-+    private final float pitch;
-+
-+    /**
-+     * Main constructor for this class.
-+     *
-+     * @param x     The X coordinate.
-+     * @param y     The Y coordinate.
-+     * @param z     The Z coordinate.
-+     * @param yaw   Yaw is the player's head rotation. (-90 to 90 degrees)
-+     * @param pitch Pitch is the player's body rotation. (360 degrees)
-+     */
-+    public SerializedLocation(double x, double y, double z, float yaw, float pitch) {
-+        this.x = x;
-+        this.y = y;
-+        this.z = z;
-+        this.yaw = yaw;
-+        this.pitch = pitch;
-+    }
-+
-+    /**
-+     * This constructor allows for cleaner code where a
-+     * pitch and yaw are not defined. Defaults are 0.
-+     *
-+     * @param x The X coordinate.
-+     * @param y The Y coordinate.
-+     * @param z The Z coordinate.
-+     */
-+    public SerializedLocation(double x, double y, double z) {
-+        this(x, y, z, 0, 0);
-+    }
-+
-+    /**
-+     * This function translates this basic extension of
-+     * an XYZ location back into Spigot's Location implementation.
-+     *
-+     * @param world The world the XYZ coordinate is in.
-+     * @param pitch Whether or not to include pitch.
-+     * @return The resultant Location object.
-+     * @see org.bukkit.Location
-+     */
-+    public Location toLocation(World world, boolean pitch) {
-+        if (pitch) return new Location(world, x, y, z, yaw, this.pitch);
-+        return new Location(world, x, y, z);
-+    }
-+
-+    public double x() {
-+        return x;
-+    }
-+
-+    public double y() {
-+        return y;
-+    }
-+
-+    public double z() {
-+        return z;
-+    }
-+
-+    public float yaw() {
-+        return yaw;
-+    }
-+
-+    public float pitch() {
-+        return pitch;
-+    }
-+}
-diff --git a/src/sbs/mira/pvp/framework/util/WarCache.java b/src/sbs/mira/pvp/framework/util/WarCache.java
-new file mode 100644
-index 0000000..84aaa9e
---- /dev/null
-+++ b/src/sbs/mira/pvp/framework/util/WarCache.java
-@@ -0,0 +1,137 @@
-+package sbs.mira.pvp.framework.util;
-+
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.framework.MiraModule;
-+import sbs.mira.pvp.framework.game.WarMap;
-+import sbs.mira.pvp.framework.game.WarMode;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+
-+import java.util.HashMap;
-+
-+/**
-+ * This class acts as a cache for gamemode and
-+ * map running instances. If an instance of either
-+ * must be retrieved, it should be done through this
-+ * cache.
-+ * Created by Josh on 18/04/2017.
-+ *
-+ * @author s101601828 @ Swin.
-+ * @version 1.0
-+ * @since 1.0
-+ */
-+public abstract class WarCache extends MiraModule {
-+
-+    protected final HashMap<String, WarMap> maps; // The key/value set for all maps.
-+    protected final HashMap<String, WarMode> gamemodes; // The key/value set for all gamemodes.
-+
-+    /**
-+     * Constructor of the cache. It should:
-+     * Load all gamemodes using reflections.
-+     * Load all maps using instantiations or reflections.
-+     *
-+     * @param main The supercontroller.
-+     */
-+    protected WarCache(MiraPulse main) {
-+        super(main);
-+        maps = new HashMap<>();
-+        gamemodes = new HashMap<>();
-+        loadMaps();
-+        loadGamemodes();
-+    }
-+
-+    /**
-+     * This procedure should load any gamemode classes created.
-+     * In the external program, gamemodes should be detected via
-+     * reflections, instantiated, and put in the gamemodes array.
-+     */
-+    public abstract void loadGamemodes();
-+
-+    /**
-+     * This procedure should load any maps classes created.
-+     * In the external program, maps should be detected via
-+     * reflections or instantiated, and put in the maps array.
-+     */
-+    public abstract void loadMaps();
-+
-+    /**
-+     * Returns the current map playing.
-+     * This returns a running instance, not a name.
-+     * If you want to get the name of the map, preferably
-+     * use the getCurrentMap() function in WarMatch.
-+     *
-+     * @return The current map playing.
-+     */
-+    public WarMap getCurrentMap() {
-+        return getMap(mira().match().getCurrentMap());
-+    }
-+
-+    /**
-+     * Returns a gamemode based on its name.
-+     *
-+     * @param gamemode The gamemode to search for.
-+     * @return The gamemode found, if any.
-+     */
-+    public WarMode getGamemode(String gamemode) {
-+        return gamemodes.get(gamemode);
-+    }
-+
-+    /**
-+     * Returns a map based on its name.
-+     * This returns a running instance, as stated above.
-+     *
-+     * @param map The map to match in the key/value set.
-+     * @return The map found, if any.
-+     */
-+    public WarMap getMap(String map) {
-+        return maps.get(map);
-+    }
-+
-+    /**
-+     * Finds a team based on an incomplete or complete word.
-+     * <p>
-+     * For example: ['Red Team', 'Blue Team']
-+     * <p>
-+     * Input of 'bl' or 'Bl' -> 'Blue Team'
-+     * Input of 'r' -> 'Red Team'
-+     *
-+     * @param preference The team to try and find.
-+     * @return The team found, if any.
-+     * <p>
-+     * (this function was for debugging purposes)
-+     * (might have a use later or no?)
-+     */
-+    public WarTeam matchTeam(String preference) {
-+        WarTeam found = null;
-+        if (preference == null) return null;
-+        for (WarTeam team : mira().match().getCurrentMode().getTeams()) {
-+            if (team.getTeamName().toLowerCase().startsWith(preference.toLowerCase())) {
-+                found = team;
-+                break;
-+            }
-+        }
-+        return found;
-+    }
-+
-+    /**
-+     * Finds a map based on an incomplete or complete word.
-+     * <p>
-+     * For example: ['Map One', 'Cool Map Two']
-+     * <p>
-+     * Input of 'cool' or 'cool m' -> 'Cool Map Two'
-+     * Input of 'ma' -> 'Map One'
-+     *
-+     * @param preference The map to try and find.
-+     * @return The map found, if any.
-+     */
-+    public WarMap matchMap(String preference) {
-+        WarMap found = null;
-+        if (preference == null) return null;
-+        for (WarMap map : maps.values()) {
-+            if (map.getMapName().toLowerCase().startsWith(preference.toLowerCase())) {
-+                found = map;
-+                break;
-+            }
-+        }
-+        return found;
-+    }
-+}
-diff --git a/src/sbs/mira/pvp/framework/util/WarMatch.java b/src/sbs/mira/pvp/framework/util/WarMatch.java
-new file mode 100644
-index 0000000..053f9bf
---- /dev/null
-+++ b/src/sbs/mira/pvp/framework/util/WarMatch.java
-@@ -0,0 +1,300 @@
-+package sbs.mira.pvp.framework.util;
-+
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.framework.MiraModule;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarMode;
-+import org.bukkit.Bukkit;
-+import org.bukkit.World;
-+import org.bukkit.entity.Entity;
-+
-+import java.io.File;
-+import java.io.IOException;
-+import java.nio.file.Files;
-+import java.nio.file.Paths;
-+import java.util.ArrayList;
-+import java.util.List;
-+import java.util.stream.Stream;
-+
-+/**
-+ * This (extendable) class controls all flow of match cycles.
-+ * While not directly interfering with rounds, its functions
-+ * are defined here for a ground point to manifest the movement
-+ * of the match to the next stage of cycling.
-+ * <p>
-+ * i.e. Starting match -> Match started
-+ * i.e. Match ending -> Cycle
-+ *
-+ * @author s101601828 @ Swin.
-+ * @version 1.0
-+ * @see org.bukkit.Bukkit
-+ * @since 1.0
-+ */
-+public abstract class WarMatch extends MiraModule {
-+
-+    public int rotationPoint; // Holds the point at which the rotation is at.
-+    private WarMode currentMode; // Holds the current gamemode's running instance.
-+    private Status status; // Holds the current state of the match.
-+    private String cyclePrevMap; // Holds the map played prior to the last cycle.
-+    private String currentMap; // Holds the current map being played, if any.
-+    private long roundID; // A unique, random 5-digit number for the Minecraft world name.
-+    private List<String> rotationList; // Holds a list of map names that are on the rotation.
-+
-+    /**
-+     * Constructor of the War Match manager.
-+     * Calling this will setup your default variables + the rotation.
-+     */
-+    public WarMatch(MiraPulse main) {
-+        super(main);
-+
-+        //Set up match variables.
-+        status = Status.NONE;
-+        cyclePrevMap = "None";
-+        currentMap = "None";
-+        currentMap = null;
-+
-+        //Set up rotation list.
-+        try (Stream<String> stream = Files.lines(Paths.get(mira().plugin().getDataFolder() + File.separator + "rotation"))) {
-+            rotationList = new ArrayList<>();
-+            stream.forEachOrdered(rotationList::add); // For each line read, add it to the list.
-+        } catch (IOException e) {
-+            e.printStackTrace();
-+            mira().plugin().getServer().shutdown(); // Don't play without a rotation.
-+        }
-+    }
-+
-+    /**
-+     * Returns the 5-digit ID of the map's Minecraft world.
-+     * This is randomly generated so files do not duplicate
-+     * or clash when a round cycles.
-+     *
-+     * @return Round ID.
-+     */
-+    private String getRoundID() {
-+        return roundID + "";
-+    }
-+
-+    /**
-+     * Redefines the round ID being used by the match.
-+     *
-+     * @param roundID New round ID.
-+     */
-+    protected void setRoundID(long roundID) {
-+        this.roundID = roundID;
-+    }
-+
-+    /**
-+     * Returns the 5-digit ID of the map's Minecraft world.
-+     * Some procedures require the number as a number and
-+     * not as a string, so this is the method that returns it.
-+     *
-+     * @return Round it.
-+     */
-+    public long getRawRoundID() {
-+        return roundID;
-+    }
-+
-+    /**
-+     * Checks whether or not the player can interact in a match
-+     * based on their state and whether or not they're an admin.
-+     *
-+     * @param pl          The player, to check their state.
-+     * @param adminBypass If true, returns true always if player is admin.
-+     * @return Whether or not the player can interact.
-+     */
-+    public boolean canInteract(Entity pl, boolean adminBypass) {
-+        MiraPlayer wp = mira().getWarPlayer(pl.getUniqueId());
-+        return wp == null || (wp.is_member_of_team() || adminBypass && mira().plugin().hasPermission(pl, "war.admin"));
-+    }
-+
-+    /**
-+     * Checks whether this played should be affected by something
-+     * in a match. Basically returns false if not a spectator.
-+     *
-+     * @param pl The player, to check their state.
-+     * @return Whether or not they are affected.
-+     */
-+    public boolean isAffected(Entity pl) {
-+        MiraPlayer wp = mira().getWarPlayer(pl.getUniqueId());
-+        return wp != null && wp.is_member_of_team();
-+    }
-+
-+    /**
-+     * Translates the #getRoundID() result into a Bukkit
-+     * world that can be manipulated further.
-+     *
-+     * @return The world associated with the round ID.
-+     */
-+    public World getCurrentWorld() {
-+        if (status == Status.NONE) {
-+            mira().plugin().log("A null world may have been returned!");
-+            return null;
-+        } else return Bukkit.getWorld(getRoundID());
-+    }
-+
-+    /**
-+     * Returns the current map playing, by its name.
-+     * If you want the running instance, you should
-+     * probably use WarCache's getCurrentMap().
-+     *
-+     * @return The current map's name.
-+     */
-+    protected String getCurrentMap() {
-+        return currentMap;
-+    }
-+
-+    /**
-+     * Sets the current map playing, by name.
-+     * This does not set the running instance,
-+     * but the function that does uses this variable.
-+     *
-+     * @param currentMap The current map's name.
-+     */
-+    protected void setCurrentMap(String currentMap) {
-+        this.currentMap = currentMap;
-+    }
-+
-+    /**
-+     * Returns the map that was previously played.
-+     * This is used when the previous map needs to
-+     * be known.
-+     * <p>
-+     * When a player connects, the previous map needs
-+     * to be known. If the match is cycling or under
-+     * a vote, players are still in the previous world
-+     * even though the new world has been assigned.
-+     *
-+     * @return The previous map played.
-+     */
-+    public String getPreviousMap() {
-+        return cyclePrevMap;
-+    }
-+
-+    /**
-+     * Sets the previous map played, by name.
-+     * This should be used to set the previous
-+     * map for checks when needed.
-+     *
-+     * @param cyclePrevMap The previous map's name.
-+     */
-+    protected void setPreviousMap(String cyclePrevMap) {
-+        this.cyclePrevMap = cyclePrevMap;
-+    }
-+
-+    /**
-+     * Returns the currently active gamemode.
-+     * This returns a running instance of the mode.
-+     *
-+     * @return The gamemode.
-+     */
-+    public WarMode getCurrentMode() {
-+        return currentMode;
-+    }
-+
-+    /**
-+     * Sets the current gamemode playing by running instance.
-+     * Once a vote has been completed, it should be set using this.
-+     *
-+     * @param currentMode The gamemode.
-+     */
-+    protected void setCurrentMode(WarMode currentMode) {
-+        this.currentMode = currentMode;
-+    }
-+
-+    /**
-+     * Returns the current state of the match.
-+     *
-+     * @return Match state.
-+     */
-+    public Status getStatus() {
-+        return status;
-+    }
-+
-+    /**
-+     * Redefines the current state of the match.
-+     *
-+     * @param status The new match state.
-+     */
-+    protected void setStatus(Status status) {
-+        this.status = status;
-+    }
-+
-+    /**
-+     * Returns the currently loaded rotation list.
-+     * Used to display to a player who requests it.
-+     *
-+     * @return The rotation list.
-+     */
-+    public List<String> getRotationList() {
-+        return rotationList;
-+    }
-+
-+    /**
-+     * This is called once a cycle is over and a
-+     * new map is ready to be played on.
-+     * <p>
-+     * This should:
-+     * Transfer current map to the previous map.
-+     * Determine the next map and allocate it.
-+     * Hold a vote for a multi-gamemode map if applicable.
-+     * Recycle and clear variables used in voting logic.
-+     * Then call preMatch().
-+     */
-+    public abstract void endCycle();
-+
-+    /**
-+     * This is called once a new map has been
-+     * allocated and it must be prepped for usage.
-+     * <p>
-+     * This should:
-+     * Copy the physical map data over for temporary usage.
-+     * Assign a random 5-digit temporary ID for the world.
-+     * Load the map and teleport all players into it.
-+     * Unload the previous map and discard any unneeded data.
-+     * Start a countdown, then call matchStart();
-+     */
-+    public abstract void preMatch();
-+
-+    /**
-+     * Once a match starts, the map will take over
-+     * the flow of the match, assigning players to
-+     * teams, initialising the gamemode, etc.
-+     * <p>
-+     * There is no need to call matchEnd() in this procedure.
-+     */
-+    public abstract void matchStart();
-+
-+    /**
-+     * Called when a match is ended. This procedure
-+     * should not be called intrinsically to end a
-+     * match, but after the map has faciliated the
-+     * end to one.
-+     * <p>
-+     * This will make everyone a spectator and clean everything.
-+     * Afterwards, startCycle() should be called to keep the flow.
-+     */
-+    public abstract void matchEnd();
-+
-+    /**
-+     * This allows a brief amount of time to pass for reflection.
-+     * Every now and then, fireworks or special effects should
-+     * appear out of the winning team or player to congratulate.
-+     * <p>
-+     * Call endCycle() after we're all done here.
-+     */
-+    public abstract void startCycle();
-+
-+    /**
-+     * This enumerated type ensures accuracy & readability when
-+     * defining the the status of a round.
-+     * <p>
-+     * The NONE status is used when no match has been established.
-+     */
-+    public enum Status {
-+        VOTING,
-+        STARTING,
-+        PLAYING,
-+        CYCLE,
-+        NONE
-+    }
-+}
-diff --git a/src/sbs/mira/pvp/framework/util/modules/ItemUtility.java b/src/sbs/mira/pvp/framework/util/modules/ItemUtility.java
-new file mode 100644
-index 0000000..b5367d7
---- /dev/null
-+++ b/src/sbs/mira/pvp/framework/util/modules/ItemUtility.java
-@@ -0,0 +1,276 @@
-+package sbs.mira.pvp.framework.util.modules;
-+
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.framework.MiraModule;
-+import org.bukkit.ChatColor;
-+import org.bukkit.Color;
-+import org.bukkit.Material;
-+import org.bukkit.entity.Player;
-+import org.bukkit.inventory.Inventory;
-+import org.bukkit.inventory.ItemStack;
-+import org.bukkit.inventory.meta.ItemMeta;
-+import org.bukkit.inventory.meta.LeatherArmorMeta;
-+import org.bukkit.inventory.meta.PotionMeta;
-+import org.bukkit.inventory.meta.SkullMeta;
-+import org.bukkit.potion.PotionEffect;
-+import org.bukkit.potion.PotionEffectType;
-+
-+import java.util.ArrayList;
-+
-+/**
-+ * This class handles cruicial inventory and
-+ * item-related prodecures as documented below.
-+ * <p>
-+ * Created by Josh on 18/04/2017.
-+ *
-+ * @author s101601828 @ Swin.
-+ * @version 1.0
-+ * @see ItemStack
-+ * @since 1.0
-+ */
-+@SuppressWarnings("unused")
-+public class ItemUtility extends MiraModule {
-+
-+    public ItemUtility(MiraPulse main) {
-+        super(main);
-+    }
-+
-+    /**
-+     * Checks if an inventory is empty.
-+     *
-+     * @param inv Inventory to check.
-+     * @return Whether or not it is empty.
-+     * @see Inventory
-+     * <p>
-+     * Currently not used, but may used in the future?
-+     * (-> no maps I added currently use this function)
-+     */
-+    public boolean isInventoryEmpty(Inventory inv) {
-+        for (ItemStack item : inv.getContents()) { // Checks every item slot in an inventory.
-+            if (item != null)
-+                return true; // A slot contains an item, this inventory is not empty.
-+        }
-+        return false; // No slots weren't null, this inventory is empty.
-+    }
-+
-+    /**
-+     * Completely resets a player's inventory and state.
-+     *
-+     * @param wp The target to clear.
-+     * @see Player
-+     */
-+    public void clear(MiraPlayer wp) {
-+        Player target = wp.crafter();
-+        target.closeInventory(); // Closes their inventory so it can be properly modified.
-+        for (PotionEffect pe : target.getActivePotionEffects())
-+            target.removePotionEffect(pe.getType()); // Remove all active potion effects.
-+        target.getInventory().clear(); // Clear the target's inventory.
-+        target.getInventory().setArmorContents(new ItemStack[4]); // Removes the target's armor.
-+        target.setExp(0); // Resets XP gained.
-+        target.setLevel(0); // Resets XP level.
-+        target.setHealth(20); // Sets health back to 10 hearts. (1 = 1/2 a heart)
-+        target.setSaturation(20F); // Sets food saturation back to high. (how quickly a player gains hunger)
-+        target.setFoodLevel(20); // Sets food level back to maximum.
-+        target.setMaxHealth(20); // Resets a player's total maximum health.
-+    }
-+
-+    /**
-+     * Modifies an ItemStack's ItemMeta.
-+     *
-+     * @param stack The ItemStack to change.
-+     * @param name  The ItemStack's name.
-+     * @param lore  The ItemStack's lore.
-+     */
-+    public ItemStack changeItem(ItemStack stack, String name, Object[] lore) {
-+        ArrayList<String> loreList = new ArrayList<>();
-+        for (Object st : lore)
-+            loreList.add(st.toString());
-+        return changeItem(stack, name, loreList);
-+        // For statement documentation, check the below function.
-+    }
-+
-+    /**
-+     * ORIGINAL METHOD.
-+     * Modifies an ItemStack's ItemMeta.
-+     *
-+     * @param stack The ItemStack to change.
-+     * @param name  The ItemStack's name.
-+     * @param lore  The ItemStack's lore.
-+     */
-+    private ItemStack changeItem(ItemStack stack, String name, ArrayList<String> lore) {
-+        ItemMeta meta = stack.getItemMeta(); // Gets an ItemStack's meta (which holds display names, lore, etc.)
-+        if (name != null)
-+            meta.setDisplayName(ChatColor.RED + name); // Set the display name if it isn't null.
-+        if (lore != null)
-+            meta.setLore(lore); // Set the lore if it isn't null.
-+        stack.setItemMeta(meta); // Apply our changes!
-+        return stack;
-+    }
-+
-+    /**
-+     * ORIGINAL METHOD.
-+     * Modifies an ItemStack's ItemMeta.
-+     * Use this method if you do not want to apply lore.
-+     *
-+     * @param stack The ItemStack to change.
-+     * @param name  The ItemStack's name.
-+     *              <p>
-+     *              Currently not used, but may used in the future?
-+     *              (-> no maps I added currently use this function)
-+     */
-+    public ItemStack changeItem(ItemStack stack, String name) {
-+        ItemMeta meta = stack.getItemMeta();
-+        if (name != null)
-+            meta.setDisplayName(ChatColor.RED + name);
-+        stack.setItemMeta(meta);
-+        return stack;
-+        // For statement documentation, check the above function.
-+    }
-+
-+    /**
-+     * Colors an item depending on the user's current team.
-+     * Ignores non-leather armor.
-+     *
-+     * @param armor       The armor piece to color.
-+     * @param currentTeam The user's current team.
-+     * @return The colored armor.
-+     * <p>
-+     */
-+    private ItemStack colorArmor(ItemStack armor, WarTeam currentTeam) {
-+        if (armor.getType().toString().startsWith("LEATHER_")) {
-+            LeatherArmorMeta meta = (LeatherArmorMeta) armor.getItemMeta(); // Gets the leather armor's specific meta.
-+            meta.setColor(convertChatToDye(currentTeam.getTeamColor())); // Sets the color of the leather armor.
-+            armor.setItemMeta(meta); // Apply our changes!
-+        }
-+        return armor;
-+    }
-+
-+    /**
-+     * Colors supplied armor (if leather) and applies it
-+     * to the user automatically according to team color.
-+     *
-+     * @param dp    The player to apply the armor to.
-+     * @param armor The armor supplied.
-+     */
-+    public void applyArmorAcccordingToTeam(MiraPlayer dp, Material[] armor) {
-+        for (Material toApply : armor) {
-+            ItemStack result = colorArmor(new ItemStack(toApply), dp.getCurrentTeam());
-+            switch (toApply.toString().split("_")[1]) {
-+                case "HELMET":
-+                    dp.crafter().getInventory().setHelmet(result);
-+                    break;
-+                case "CHESTPLATE":
-+                    dp.crafter().getInventory().setChestplate(result);
-+                    break;
-+                case "LEGGINGS":
-+                    dp.crafter().getInventory().setLeggings(result);
-+                    break;
-+                case "BOOTS":
-+                    dp.crafter().getInventory().setBoots(result);
-+                    break;
-+            }
-+        }
-+    }
-+
-+    /**
-+     * Returns the skull of a player.
-+     *
-+     * @param name The name of the player.
-+     * @return The skull.
-+     * @see SkullMeta
-+     * <p>
-+     * Currently not used, but may used in the future?
-+     * (-> no maps I added currently use this function)
-+     */
-+    public ItemStack giveSkull(String name) {
-+        ItemStack skull = new ItemStack(Material.SKULL_ITEM, 1, (short) 3); // Creates an ItemStack of player skull.
-+        SkullMeta meta = (SkullMeta) skull.getItemMeta(); // Gets the skull item's specific meta.
-+        meta.setOwner(name); // Sets the skull to a player's IGN for their skin.
-+        skull.setItemMeta(meta); // Apply our changes!
-+        return skull;
-+    }
-+
-+    /**
-+     * Creates a potion.
-+     *
-+     * @param type      Potion effect type.
-+     * @param duration  Duration.
-+     * @param amplifier Strength.
-+     * @return The potion.
-+     * <p>
-+     */
-+    public ItemStack createPotion(PotionEffectType type, int duration, int amplifier, int amount) {
-+        ItemStack POTION = new ItemStack(Material.POTION, amount); // Creates a potion with no ingredients.
-+        PotionMeta meta = (PotionMeta) POTION.getItemMeta(); // Gets the potion's specific meta.
-+        PotionEffect effect = new PotionEffect(type, duration, amplifier); // Create the custom effect.
-+        meta.addCustomEffect(effect, true); // Add the custom effect.
-+        meta.setDisplayName(ChatColor.WHITE + "Potion of " + mira().strings().potionEffect(effect)); // Don't show it as uncraftable.
-+        POTION.setItemMeta(meta); // Apply our changes!
-+        return POTION;
-+    }
-+
-+    /**
-+     * Creates a tipped arrow.
-+     *
-+     * @param type      Potion effect type.
-+     * @param duration  Duration.
-+     * @param amplifier Strength.
-+     * @return The arrow.
-+     */
-+    public ItemStack createTippedArrow(PotionEffectType type, int duration, int amplifier, int amount) {
-+        ItemStack ARROW = new ItemStack(Material.TIPPED_ARROW, amount); // Creates a tipped arrow with no ingredients.
-+        PotionMeta meta = (PotionMeta) ARROW.getItemMeta(); // Gets the arrow's specific meta.
-+        PotionEffect effect = new PotionEffect(type, duration, amplifier); // Create the custom effect.
-+        meta.addCustomEffect(effect, true); // Add the custom effect.
-+        meta.setColor(type.getColor()); // Set the color.
-+        meta.setDisplayName(ChatColor.WHITE + "Potion of " + mira().strings().potionEffect(effect)); // Don't show it as uncraftable.
-+        ARROW.setItemMeta(meta); // Apply our changes!
-+        return ARROW;
-+    }
-+
-+    /**
-+     * Converts a Minecraft "Chat Color" into the most
-+     * appropriate "Dye Color" possible for team armor.
-+     *
-+     * @param color The ChatColor to convert.
-+     * @return The matching Color.
-+     */
-+    private Color convertChatToDye(ChatColor color) {
-+        switch (color) {
-+            case AQUA:
-+                return Color.AQUA;
-+            case BLACK:
-+                return Color.BLACK;
-+            case BLUE:
-+                return Color.BLUE;
-+            case DARK_AQUA:
-+                return Color.TEAL;
-+            case DARK_BLUE:
-+                return Color.NAVY;
-+            case DARK_GRAY:
-+                return Color.GRAY;
-+            case DARK_GREEN:
-+                return Color.GREEN;
-+            case DARK_PURPLE:
-+                return Color.PURPLE;
-+            case DARK_RED:
-+                return Color.MAROON;
-+            case GOLD:
-+                return Color.ORANGE;
-+            case GRAY:
-+                return Color.GRAY;
-+            case GREEN:
-+                return Color.LIME;
-+            case LIGHT_PURPLE:
-+                return Color.FUCHSIA;
-+            case RED:
-+                return Color.RED;
-+            case YELLOW:
-+                return Color.YELLOW;
-+            default:
-+                return Color.WHITE;
-+        }
-+    }
-+}
-diff --git a/src/sbs/mira/pvp/framework/util/modules/StringUtility.java b/src/sbs/mira/pvp/framework/util/modules/StringUtility.java
-new file mode 100644
-index 0000000..4428800
---- /dev/null
-+++ b/src/sbs/mira/pvp/framework/util/modules/StringUtility.java
-@@ -0,0 +1,261 @@
-+package sbs.mira.pvp.framework.util.modules;
-+
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.framework.MiraModule;
-+import net.md_5.bungee.api.chat.TextComponent;
-+import org.bukkit.ChatColor;
-+import org.bukkit.Color;
-+import org.bukkit.inventory.ItemStack;
-+import org.bukkit.potion.PotionEffect;
-+import org.bukkit.potion.PotionEffectType;
-+
-+import java.util.HashMap;
-+import java.util.List;
-+import java.util.Map;
-+import java.util.Random;
-+
-+/**
-+ * This class handles mildly helpful string functions
-+ * needed for user-friendliness.
-+ * <p>
-+ * Created by Josh on 18/04/2017.
-+ *
-+ * @author s101601828 @ Swin.
-+ * @version 1.0
-+ * @see ItemStack
-+ * @since 1.0
-+ */
-+public class StringUtility extends MiraModule {
-+
-+    private Map<PotionEffectType, String> effects = new HashMap<>();
-+
-+    /**
-+     * String utility constructor.
-+     * We need to link back to the manager and plugin.
-+     *
-+     * @param main The supercontroller.
-+     */
-+    public StringUtility(MiraPulse main) {
-+        super(main);
-+        effects.put(PotionEffectType.ABSORPTION, "Absorption");
-+        effects.put(PotionEffectType.BLINDNESS, "Blindness");
-+        effects.put(PotionEffectType.CONFUSION, "Nausea");
-+        effects.put(PotionEffectType.DAMAGE_RESISTANCE, "Resistance");
-+        effects.put(PotionEffectType.FAST_DIGGING, "Haste");
-+        effects.put(PotionEffectType.FIRE_RESISTANCE, "Fire Resistance");
-+        effects.put(PotionEffectType.HARM, "Instant Damage");
-+        effects.put(PotionEffectType.HEAL, "Instant Health");
-+        effects.put(PotionEffectType.HEALTH_BOOST, "Health Boost");
-+        effects.put(PotionEffectType.HUNGER, "Hunger");
-+        effects.put(PotionEffectType.INCREASE_DAMAGE, "Strength");
-+        effects.put(PotionEffectType.INVISIBILITY, "Invisibility");
-+        effects.put(PotionEffectType.JUMP, "Jump Boost");
-+        effects.put(PotionEffectType.NIGHT_VISION, "Night Vision");
-+        effects.put(PotionEffectType.POISON, "Poison");
-+        effects.put(PotionEffectType.REGENERATION, "Regeneration");
-+        effects.put(PotionEffectType.SATURATION, "Saturation");
-+        effects.put(PotionEffectType.SLOW, "Slowness");
-+        effects.put(PotionEffectType.SLOW_DIGGING, "Mining Fatigue");
-+        effects.put(PotionEffectType.SPEED, "Speed");
-+        effects.put(PotionEffectType.WATER_BREATHING, "Water Breathing");
-+        effects.put(PotionEffectType.WEAKNESS, "Weakness");
-+        effects.put(PotionEffectType.WITHER, "Wither");
-+    }
-+
-+    /**
-+     * Turns an array of Strings into a sentence.
-+     * <p>
-+     * i.e. ['1', '2', '3', '4']
-+     * -> "1, 2, 3 and 4"
-+     *
-+     * @param array An array of words.
-+     * @return A sentence.
-+     */
-+    public String sentenceFormat(List<?> array) {
-+        if (array.size() == 0) return "None";
-+        StringBuilder format = new StringBuilder();
-+        if (array.size() == 1) return array.get(0).toString();
-+        int i = 1;
-+        while (i <= array.size()) {
-+            if (i == array.size())
-+                format.append(ChatColor.WHITE).append(" and ").append(array.get(i - 1).toString());
-+            else if (i == 1)
-+                format = new StringBuilder(array.get(0).toString());
-+            else
-+                format.append(", ").append(array.get(i - 1).toString());
-+            i++;
-+        }
-+        return format.toString();
-+    }
-+
-+    /**
-+     * Performs the same as above but outputs a TextComponent result.
-+     *
-+     * @param array Array of TextComponent.
-+     * @return The winner format.
-+     */
-+    public TextComponent winnerFormat(List<WarTeam> array) {
-+        if (array.size() == 0) return new TextComponent("No One");
-+        TextComponent result = new TextComponent();
-+        if (array.size() == 1) return array.get(0).getHoverInformation();
-+        int i = 1;
-+        while (i <= array.size()) {
-+            if (i == array.size()) {
-+                result.addExtra(ChatColor.WHITE + " and ");
-+                result.addExtra(array.get(i - 1).getHoverInformation());
-+            } else if (i == 1)
-+                result = new TextComponent(array.get(0).getHoverInformation());
-+            else {
-+                result.addExtra(ChatColor.WHITE + ", ");
-+                result.addExtra(array.get(i - 1).getHoverInformation());
-+            }
-+            i++;
-+        }
-+        return result;
-+    }
-+
-+    /**
-+     * Generates a 5-digit number.
-+     * While not intrinsically a String, it is treated
-+     * as one when manipulating the map world.
-+     *
-+     * @return A 5-digit number.
-+     */
-+    public long generateID() {
-+        long generated = new Random().nextInt(90000) + 10000;
-+        // Number between 11111-99999;
-+
-+        if (mira().match().getRawRoundID() == generated) return generateID();
-+        // Though a very small chance, regenerate if it is the same as the previous round.
-+        return generated;
-+    }
-+
-+    /**
-+     * Converts an integer into a digital clock formatted string.
-+     *
-+     * @param i The integer to convert, in number of seconds.
-+     * @return The converted string in a MM:SS format.
-+     */
-+    public String getDigitalTime(int i) {
-+        if (i < 0) i = -i;
-+        int remainder = i % 3600, minutes = remainder / 60, seconds = remainder % 60;
-+        String time = "";
-+        if (minutes > 0) {
-+            if (minutes < 10) time += "0";
-+            time += minutes + ":";
-+        } else {
-+            time += "00:";
-+        }
-+        if (seconds > 0) {
-+            if (seconds < 10) time += "0";
-+            time += seconds;
-+        } else {
-+            time += "00";
-+        }
-+        return time;
-+    }
-+
-+    /**
-+     * Is it second, or seconds?
-+     * Is it amount, or amounts?
-+     * <p>
-+     * i.e. 1 seconds -> 1 second,
-+     * 2 seconds -> 2 seconds.
-+     *
-+     * @param amount The amount.
-+     * @return The plural.
-+     */
-+    public String plural(int amount) {
-+        return amount == 1 ? " " : "s ";
-+    }
-+
-+    /**
-+     * Turns ChatColor into dye Color.
-+     * This may not be 100% accurate but it was as close as I could get.
-+     *
-+     * @param color The ChatColor to convert.
-+     * @return The matching Color.
-+     */
-+    public Color convertChatToDye(ChatColor color) {
-+        switch (color) {
-+            case AQUA:
-+                return Color.AQUA;
-+            case BLACK:
-+                return Color.BLACK;
-+            case BLUE:
-+                return Color.BLUE;
-+            case DARK_AQUA:
-+                return Color.TEAL;
-+            case DARK_BLUE:
-+                return Color.NAVY;
-+            case DARK_GRAY:
-+                return Color.GRAY;
-+            case DARK_GREEN:
-+                return Color.GREEN;
-+            case DARK_PURPLE:
-+                return Color.PURPLE;
-+            case DARK_RED:
-+                return Color.MAROON;
-+            case GOLD:
-+                return Color.ORANGE;
-+            case GRAY:
-+                return Color.GRAY;
-+            case GREEN:
-+                return Color.LIME;
-+            case LIGHT_PURPLE:
-+                return Color.FUCHSIA;
-+            case RED:
-+                return Color.RED;
-+            case YELLOW:
-+                return Color.YELLOW;
-+            case WHITE:
-+                return Color.WHITE;
-+            default:
-+                return Color.WHITE;
-+        }
-+    }
-+
-+    /**
-+     * Formats a potion effect into what it would normally be.
-+     *
-+     * @param effect Effect to pretty.
-+     * @return Normal-looking potion effect name.
-+     */
-+    String potionEffect(PotionEffect effect) {
-+        return effects.get(effect.getType()) + " " + quickNumerals(effect.getAmplifier() + 1);
-+    }
-+
-+    /**
-+     * Returns the numerals of 1 to 10 quickly.
-+     *
-+     * @param number The number to convert.
-+     * @return The conversion.
-+     */
-+    private String quickNumerals(int number) {
-+        switch (number) {
-+            case 10:
-+                return "X";
-+            case 9:
-+                return "IX";
-+            case 8:
-+                return "VIII";
-+            case 7:
-+                return "VII";
-+            case 6:
-+                return "VI";
-+            case 5:
-+                return "V";
-+            case 4:
-+                return "IV";
-+            case 3:
-+                return "III";
-+            case 2:
-+                return "II";
-+            case 1:
-+                return "II";
-+            default:
-+                return "X+";
-+        }
-+    }
-+}
-diff --git a/src/sbs/mira/pvp/framework/util/modules/WorldUtility.java b/src/sbs/mira/pvp/framework/util/modules/WorldUtility.java
-new file mode 100644
-index 0000000..2799b4f
---- /dev/null
-+++ b/src/sbs/mira/pvp/framework/util/modules/WorldUtility.java
-@@ -0,0 +1,194 @@
-+package sbs.mira.pvp.framework.util.modules;
-+
-+
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.framework.MiraModule;
-+import net.minecraft.server.v1_12_R1.WorldServer;
-+import org.apache.commons.io.FileUtils;
-+import org.bukkit.Bukkit;
-+import org.bukkit.Location;
-+import org.bukkit.World;
-+import org.bukkit.WorldCreator;
-+import org.bukkit.craftbukkit.v1_12_R1.CraftServer;
-+import org.bukkit.craftbukkit.v1_12_R1.CraftWorld;
-+import org.bukkit.generator.ChunkGenerator;
-+import org.bukkit.inventory.ItemStack;
-+
-+import java.io.*;
-+import java.lang.reflect.Field;
-+import java.util.Map;
-+import java.util.Random;
-+
-+/**
-+ * This class handles the moving, removal, and creation of
-+ * the physical worlds on the Minecraft server. This demonstrates
-+ * file handling, but also contains a lot of Spigot
-+ * <p>
-+ * Created by Josh on 18/04/2017.
-+ *
-+ * @author s101601828 @ Swin.
-+ * @version 1.0
-+ * @see ItemStack
-+ * @since 1.0
-+ */
-+public class WorldUtility extends MiraModule {
-+
-+    private String repo; // Holds the directory path to the map repository.
-+
-+    /**
-+     * World utility constructor.
-+     * We need to link back to the manager and plugin.
-+     *
-+     * @param main The supercontroller.
-+     */
-+    public WorldUtility(MiraPulse main) {
-+        super(main);
-+        repo = main.plugin().getConfig().getString("settings.maps_repo");
-+    }
-+
-+    /**
-+     * Takes the world file from the map directory, and pastes it
-+     * into the Bukkit directory so it can be loaded and used.
-+     * <p>
-+     * The map directory is located at $PLUGIN/maps/.
-+     * $PLUGIN is the directory created for the plugin by bukkit in $BUKKIT/plugins/$PLUGIN/.
-+     *
-+     * @param map The name of the map.
-+     * @param ID  The 5-digit ID that the world will be defined as.
-+     */
-+    public void loadMap(String map, long ID) {
-+        mira().plugin().log("Now attempting to load " + map + " to " + ID + "!"); // Debug.
-+        try {
-+            File path = new File(repo + File.separator + map);
-+            mira().plugin().log("Maps repo path: " + path);
-+            // Non-absolute paths will default to inside the plugin folder.
-+            copyFolder(path, new File(ID + ""));
-+            // Attempts to copy over the whole directory so it can be used.
-+        } catch (IOException e) {
-+            e.printStackTrace();
-+            mira().plugin().getServer().shutdown(); // Can't play without a world.
-+        }
-+
-+        // Calling upon the Spigot Gods to load our world.
-+        WorldCreator wc = new WorldCreator(ID + "").generator(new NullChunkGenerator());
-+        World world = Bukkit.createWorld(wc);
-+        world.setAutoSave(false); // Since it won't ever be used after the match, don't autosave.
-+        WorldServer handle = ((CraftWorld) world).getHandle();
-+        handle.keepSpawnInMemory = false; // Prevent minor memory leak.
-+
-+        world.getChunkAt(0, 0).load(); // Load the chunk so it's ready to be used!
-+    }
-+
-+    /**
-+     * Once the source file and destination file have been
-+     * determined, this procedure opens an input and output
-+     * stream to transfer the data over 1024 bytes at a time.
-+     *
-+     * @param src  Source directory.
-+     * @param dest Destination directory.
-+     * @throws java.io.IOException Thrown if an error occurs while trying to copy.
-+     */
-+    @SuppressWarnings("ResultOfMethodCallIgnored")
-+    private void copyFolder(File src, File dest) throws IOException {
-+        if (src.isDirectory()) {
-+            // If this file is a directory, copy the files within this directory.
-+            while (!dest.exists())
-+                dest.mkdir();
-+            String files[] = src.list();
-+            for (String file : files != null ? files : new String[0])
-+                copyFolder(new File(src, file), new File(dest, file));
-+        } else {
-+            // Otherwise copy this file.
-+            InputStream in = new FileInputStream(src);
-+            OutputStream out = new FileOutputStream(dest);
-+            byte[] buffer = new byte[1024];
-+            int length;
-+            while ((length = in.read(buffer)) > 0) // While the number of bytes to transfer is more than zero, transfer!
-+                out.write(buffer, 0, length);
-+            in.close();
-+            out.close();
-+        }
-+    }
-+
-+    /**
-+     * Once a match has finished and cycled, the world file
-+     * should be destroyed as it is no longer needed and a
-+     * fresh copy is used when the same map is played again.
-+     *
-+     * @param map The world to restore, using the 5-digit ID.
-+     */
-+    public void restoreMap(String map) {
-+        if (Bukkit.getWorld(map) != null) {
-+            // If the world is still loaded, unload it forcibly and get rid of it.
-+            mira().plugin().log("Unloading world " + map);
-+            forceUnloadWorld(Bukkit.getWorld(map));
-+        }
-+        try {
-+            delete(new File(map)); // Bye bye!
-+        } catch (IOException e) {
-+            e.printStackTrace();
-+        }
-+    }
-+
-+    /**
-+     * Forcibly unloads a world, even if it refuses to.
-+     *
-+     * @param world World to force unload
-+     */
-+    private void forceUnloadWorld(World world) {
-+        mira().plugin().log("Now attempting to forcibly unload world " + world.getName() + "!");
-+
-+        CraftServer server = (CraftServer) Bukkit.getServer(); // Returns an advanced handle of the Spigot server instance.
-+        Bukkit.unloadWorld(world, false); // Unload the world using Bukkit.
-+
-+        try {
-+            Field f = server.getClass().getDeclaredField("worlds"); // Use reflections to get the list of loaded worlds.
-+            f.setAccessible(true); // Let us access it.
-+            @SuppressWarnings("unchecked")
-+            Map<String, World> worlds = (Map<String, World>) f.get(server); // Extract the worlds key/value set.
-+            worlds.remove(world.getName().toLowerCase()); // Remove it from the list.
-+            f.setAccessible(false); // Make it private again.
-+        } catch (IllegalAccessException | NoSuchFieldException ex) { /* This can't happen. */}
-+    }
-+
-+    /**
-+     * Deletes a directory. This is called when a map
-+     * world is no longer needed and can be removed.
-+     * <p>
-+     * This demonstrates file I/O.
-+     *
-+     * @param path Directory to delete.
-+     */
-+    @SuppressWarnings("ConstantConditions")
-+    private void delete(File path) throws IOException {
-+        if (!path.exists())
-+            return;
-+        if (path.isDirectory()) {
-+            // If this is a directory, delete the files within it.
-+            File[] toDelete = path.listFiles();
-+            if (toDelete.length > 0)
-+                for (File f : toDelete)
-+                    delete(f); // Delete any files in the directory first.
-+        }
-+        // We can delete it now.
-+        FileUtils.forceDelete(path);
-+    }
-+
-+    /**
-+     * This class is a simple Minecraft world generator.
-+     * It generates nothing, as maps are built on air.
-+     * <p>
-+     * This is used when loading a map world with a generator.
-+     */
-+    private static class NullChunkGenerator extends ChunkGenerator {
-+
-+        public byte[] generate(World world, Random random, int cx, int cz) {
-+            return new byte[65536];
-+        }
-+
-+        @Override
-+        public Location getFixedSpawnLocation(World world, Random random) {
-+            return new Location(world, 0, 64, 0);
-+        }
-+    }
-+}
-\ No newline at end of file
-diff --git a/src/au/edu/swin/war/game/Gamemode.java b/src/sbs/mira/pvp/game/Gamemode.java
-similarity index 87%
-rename from src/au/edu/swin/war/game/Gamemode.java
-rename to src/sbs/mira/pvp/game/Gamemode.java
-index f56454c..598d758 100644
---- a/src/au/edu/swin/war/game/Gamemode.java
-+++ b/src/sbs/mira/pvp/game/Gamemode.java
-@@ -1,14 +1,15 @@
--package au.edu.swin.war.game;
--
--import au.edu.swin.war.event.MatchPlayerRespawnEvent;
--import au.edu.swin.war.event.PostMatchPlayerRespawnEvent;
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.event.MatchPlayerDeathEvent;
--import au.edu.swin.war.framework.game.WarMode;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.util.WarManager;
-+package sbs.mira.pvp.game;
-+
-+import sbs.mira.pvp.event.MatchPlayerRespawnEvent;
-+import sbs.mira.pvp.event.PostMatchPlayerRespawnEvent;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.event.MatchPlayerDeathEvent;
-+import sbs.mira.pvp.framework.game.WarMode;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.MiraPulse;
- import au.edu.swin.war.game.modes.*;
--import au.edu.swin.war.util.Manager;
-+import sbs.mira.pvp.game.modes.*;
-+import sbs.mira.pvp.MiraPvpMaster;
- import net.md_5.bungee.api.chat.ClickEvent;
- import net.md_5.bungee.api.chat.ComponentBuilder;
- import net.md_5.bungee.api.chat.HoverEvent;
-@@ -87,7 +88,7 @@ public abstract class Gamemode extends WarMode {
-      */
-     @SuppressWarnings("unchecked")
-     public void resetCommon() {
--        if (((Manager) main).conf().WEBSTATS_ENABLED) {
-+        if (((MiraPvpMaster) main).conf().WEBSTATS_ENABLED) {
-             JSONObject stats = new JSONObject();
-             if (getTimeElapsed() == 0)
-                 setTimeElapsed(1); // Elapse at least one second to prevent a divison by zero error.
-@@ -103,7 +104,7 @@ public abstract class Gamemode extends WarMode {
-                 totalDeaths += death;
- 
-             // Global Match Information
--            stats.put("matchid", ((Manager) main).conf().WEBSTATS_POS + 1);
-+            stats.put("matchid", ((MiraPvpMaster) main).conf().WEBSTATS_POS + 1);
-             stats.put("mapname", map().getMapName());
-             stats.put("gamemode", getFullName());
-             stats.put("duration", main.strings().getDigitalTime(getTimeElapsed()));
-@@ -122,7 +123,7 @@ public abstract class Gamemode extends WarMode {
-                 return;
-             }
- 
--            ((Manager) main).conf().incrementPosition(); // Increment to the next match ID.
-+            ((MiraPvpMaster) main).conf().incrementPosition(); // Increment to the next match ID.
- 
-             // Team Information
-             JSONObject teams = new JSONObject(); // JSON Object to store teams.
-@@ -161,7 +162,7 @@ public abstract class Gamemode extends WarMode {
-             // Run the HTTP request asynchronous to prevent lag..
-             main.plugin().getServer().getScheduler().runTaskAsynchronously(main.plugin(), () -> {
-                 try {
--                    URL url = new URL(((Manager) main).conf().WEBSTATS_ACTION);
-+                    URL url = new URL(((MiraPvpMaster) main).conf().WEBSTATS_ACTION);
-                     URLConnection con = url.openConnection();
-                     HttpURLConnection http = (HttpURLConnection) con;
-                     http.setRequestMethod("POST");
-@@ -169,7 +170,7 @@ public abstract class Gamemode extends WarMode {
- 
-                     Map<String, String> arguments = new HashMap<>();
-                     // Our HTTP POST arguments.
--                    arguments.put("secret", ((Manager) main).conf().WEBSTATS_SECRET);
-+                    arguments.put("secret", ((MiraPvpMaster) main).conf().WEBSTATS_SECRET);
-                     arguments.put("stats", stats.toJSONString());
- 
-                     // Encodes our request.
-@@ -190,7 +191,7 @@ public abstract class Gamemode extends WarMode {
-                     }
-                     // Log the response to the request to ensure it was successful.
-                     main.plugin().log("Stats HTTP POST request successful: " + IOUtils.toString(http.getInputStream(), StandardCharsets.UTF_8.name()));
--                    Bukkit.broadcastMessage("Full Match statistics recorded @ " + ChatColor.UNDERLINE + "https://rpg.solar/match/" + ((Manager) main).conf().WEBSTATS_POS);
-+                    Bukkit.broadcastMessage("Full Match statistics recorded @ " + ChatColor.UNDERLINE + "https://rpg.solar/match/" + ((MiraPvpMaster) main).conf().WEBSTATS_POS);
-                 } catch (IOException e) {
-                     // If anything goes wrong, just raw print the stats.
-                     e.printStackTrace();
-@@ -220,26 +221,26 @@ public abstract class Gamemode extends WarMode {
-      */
-     protected abstract HashMap<String, Object> getExtraTeamData(WarTeam team);
- 
--    public void onJoin(WarPlayer joined) {
--        logEvent(joined.getName() + " joined " + joined.getCurrentTeam().getTeamColor() + joined.getCurrentTeam().getTeamName());
--        kills.put(joined.getPlayer().getUniqueId(), 0);
--        deaths.put(joined.getPlayer().getUniqueId(), 0);
-+    public void onJoin(MiraPlayer joined) {
-+        logEvent(joined.name() + " joined " + joined.getCurrentTeam().getTeamColor() + joined.getCurrentTeam().getTeamName());
-+        kills.put(joined.crafter().getUniqueId(), 0);
-+        deaths.put(joined.crafter().getUniqueId(), 0);
-         //TODO: Maybe make this display what the player needs to do?
-     }
- 
-     @EventHandler
-     public void playerDeathHandle(PlayerDeathEvent event) {
--        WarPlayer dead = main.getWarPlayer(event.getEntity()); // Get the player who died.
--        inc(deaths, dead.getPlayer().getUniqueId()); // Increment their deaths this match.
--        WarPlayer killer = main.getWarPlayer(dead.getPlayer().getKiller()); // Get the player who killed the player.
-+        MiraPlayer dead = main.getWarPlayer(event.getEntity()); // Get the player who died.
-+        inc(deaths, dead.crafter().getUniqueId()); // Increment their deaths this match.
-+        MiraPlayer killer = main.getWarPlayer(dead.crafter().getKiller()); // Get the player who killed the player.
- 
--        ((Manager) main).respawn().onDeath(main.getWarPlayer(dead.getPlayer().getUniqueId()));
-+        ((MiraPvpMaster) main).respawn().onDeath(main.getWarPlayer(dead.crafter().getUniqueId()));
-         dead.getCurrentTeam().addDeath();
-         // Handle respawning for this player.
- 
-         if (dead.equals(killer)) killer = null; // Did they kill themselves?
-         if (killer == null) {
--            event.setDeathMessage(event.getDeathMessage().replaceAll(dead.getName(), dead.getDisplayName()));
-+            event.setDeathMessage(event.getDeathMessage().replaceAll(dead.name(), dead.display_name()));
-             logEvent(event.getDeathMessage()); // Log the death.
-             environmentalKills++;
-             onDeath(dead);
-@@ -249,16 +250,16 @@ public abstract class Gamemode extends WarMode {
- 
-         // Play a sound effect.
-         killer.getCurrentTeam().addKill();
--        dead.getPlayer().getWorld().playSound(dead.getPlayer().getLocation(), Sound.ENTITY_BLAZE_DEATH, 1L, 1L);
-+        dead.crafter().getWorld().playSound(dead.crafter().getLocation(), Sound.ENTITY_BLAZE_DEATH, 1L, 1L);
- 
-         // Format the death message to show display names instead.
-         event.setDeathMessage(event.getDeathMessage()
--                .replaceAll(dead.getName(), dead.getDisplayName())
--                .replaceAll(killer.getName(), killer.getDisplayName()));
-+                .replaceAll(dead.name(), dead.display_name())
-+                .replaceAll(killer.name(), killer.display_name()));
- 
-         // Call the onKill() procedure so the extended Gamemode can react to it.
-         logEvent(event.getDeathMessage()); // Log the event first.
--        inc(kills, killer.getPlayer().getUniqueId()); // Increment their kills this match.
-+        inc(kills, killer.crafter().getUniqueId()); // Increment their kills this match.
-         onKill(dead, killer);
-         main.plugin().getServer().getPluginManager().callEvent(new MatchPlayerDeathEvent(dead, killer));
-     }
-@@ -305,7 +306,7 @@ public abstract class Gamemode extends WarMode {
-     public void onRespawn(PlayerRespawnEvent event) {
-         event.getPlayer().setBedSpawnLocation(null); // No bed spawn locations.
- 
--        WarPlayer wp = main.getWarPlayer(event.getPlayer()); // Get their WarPlayer implement.
-+        MiraPlayer wp = main.getWarPlayer(event.getPlayer()); // Get their WarPlayer implement.
- 
-         // Change the respawn location to a random team spawn.
-         event.setRespawnLocation(randomSpawnFrom(
-@@ -322,12 +323,12 @@ public abstract class Gamemode extends WarMode {
- 
-     @EventHandler
-     public void onRespawn(MatchPlayerRespawnEvent event) {
--        WarPlayer wp = event.getPlayer(); // Get their WarPlayer implement.
-+        MiraPlayer wp = event.getPlayer(); // Get their WarPlayer implement.
- 
--        if (!wp.isPlaying()) return; // Ignore this if they aren't playing.
-+        if (!wp.is_member_of_team()) return; // Ignore this if they aren't playing.
- 
-         // Teleport them to their respawn location.
--        wp.getPlayer().teleport(randomSpawnFrom(
-+        wp.crafter().teleport(randomSpawnFrom(
-                 map().getTeamSpawns(
-                         wp.getCurrentTeam().getTeamName())).toLocation(
-                 main.match().getCurrentWorld(), true));
-@@ -336,7 +337,7 @@ public abstract class Gamemode extends WarMode {
-         map().applyInv(wp);
- 
-         // They're back in the match again!
--        wp.getPlayer().setGameMode(GameMode.SURVIVAL);
-+        wp.crafter().setGameMode(GameMode.SURVIVAL);
-         Bukkit.getPluginManager().callEvent(new PostMatchPlayerRespawnEvent(wp));
-     }
- 
-@@ -355,7 +356,7 @@ public abstract class Gamemode extends WarMode {
-      */
-     protected int getJoined() {
-         int joined = 0;
--        for (WarPlayer pl : main.getWarPlayers().values())
-+        for (MiraPlayer pl : main.getWarPlayers().values())
-             if (pl.isJoined()) joined++;
-         return joined;
-     }
-@@ -404,7 +405,7 @@ public abstract class Gamemode extends WarMode {
-          * @param array The array of modes to format.
-          * @return The formatted string.
-          */
--        public static TextComponent format(Mode[] array, WarManager main) {
-+        public static TextComponent format(Mode[] array, MiraPulse main) {
-             if (array.length == 0) return new TextComponent("None");
-             TextComponent result = new TextComponent();
-             if (array.length == 1) return new TextComponent(array[0].getDescriptionComponent(main, true));
-@@ -479,7 +480,7 @@ public abstract class Gamemode extends WarMode {
-          * @param withVoteClick Enable click this to vote?
-          * @return Resulting chat component.
-          */
--        public TextComponent getDescriptionComponent(WarManager main, boolean withVoteClick) {
-+        public TextComponent getDescriptionComponent(MiraPulse main, boolean withVoteClick) {
-             TextComponent msg = new TextComponent(ChatColor.GREEN + "[" + shortName + "]");
-             WarMode assoc = main.cache().getGamemode(getFullName());
-             msg.setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT,
-diff --git a/src/au/edu/swin/war/game/Map.java b/src/sbs/mira/pvp/game/Map.java
-similarity index 96%
-rename from src/au/edu/swin/war/game/Map.java
-rename to src/sbs/mira/pvp/game/Map.java
-index a11fcff..2ebcecd 100644
---- a/src/au/edu/swin/war/game/Map.java
-+++ b/src/sbs/mira/pvp/game/Map.java
-@@ -1,9 +1,9 @@
--package au.edu.swin.war.game;
-+package sbs.mira.pvp.game;
- 
--import au.edu.swin.war.framework.game.WarMap;
--import au.edu.swin.war.framework.stored.Activatable;
--import au.edu.swin.war.framework.stored.SerializedLocation;
--import au.edu.swin.war.util.Match;
-+import sbs.mira.pvp.framework.game.WarMap;
-+import sbs.mira.pvp.framework.stored.Activatable;
-+import sbs.mira.pvp.framework.stored.SerializedLocation;
-+import sbs.mira.pvp.util.Match;
- import org.bukkit.ChatColor;
- import org.bukkit.Location;
- import org.bukkit.Material;
-diff --git a/src/sbs/mira/pvp/game/modes/CTF.java b/src/sbs/mira/pvp/game/modes/CTF.java
-new file mode 100644
-index 0000000..f05d152
---- /dev/null
-+++ b/src/sbs/mira/pvp/game/modes/CTF.java
-@@ -0,0 +1,381 @@
-+package sbs.mira.pvp.game.modes;
-+
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.stored.SerializedLocation;
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.game.Gamemode;
-+import sbs.mira.pvp.MiraPvpMaster;
-+import sbs.mira.pvp.util.WoolColor;
-+import org.bukkit.*;
-+import org.bukkit.block.Block;
-+import org.bukkit.entity.Player;
-+import org.bukkit.event.EventHandler;
-+import org.bukkit.event.block.Action;
-+import org.bukkit.event.block.BlockBreakEvent;
-+import org.bukkit.event.entity.EntityPickupItemEvent;
-+import org.bukkit.event.player.PlayerInteractEvent;
-+import org.bukkit.scoreboard.DisplaySlot;
-+import org.bukkit.scoreboard.Objective;
-+
-+import java.util.ArrayList;
-+import java.util.HashMap;
-+import java.util.Iterator;
-+
-+/**
-+ * an extension to gamemode to implement ctf.
-+ * created on 2017-04-24.
-+ *
-+ * @author jj.mira.sbs
-+ * @author jd.mira.sbs
-+ * @version 1.0.1
-+ * @see MiraPulse
-+ * @since 1.0.0
-+ */
-+public class CTF extends Gamemode {
-+
-+    private HashMap<String, CTFInfo> info;
-+    private HashMap<String, String> capture;
-+    private boolean instantBreak;
-+    private int interval = 1;
-+
-+    public void reset() {
-+        if (capture != null)
-+            capture.clear();
-+        capture = null;
-+        if (info != null)
-+            info.clear();
-+        info = null;
-+        instantBreak = false;
-+    }
-+
-+    public void initialize() {
-+        interval = 1;
-+        info = new HashMap<>();
-+        capture = new HashMap<>();
-+
-+        for (WarTeam team : getTeams())
-+            info.put(team.getTeamName(), new CTFInfo(team));
-+
-+        autoAssign();
-+        restoreFlags();
-+        
-+        Objective obj = s().registerNewObjective("gm", "dummy");
-+        obj.setDisplaySlot(DisplaySlot.SIDEBAR);
-+        updateScoreboard();
-+
-+        for (Player online : Bukkit.getOnlinePlayers())
-+            online.setScoreboard(s());
-+    }
-+
-+    public void tick() {
-+        interval--;
-+        if (interval == 0) {
-+            interval = 4;
-+            doFireworks();
-+        }
-+        if (getTimeElapsed() > (150 * (Integer) map().attr().get("captureRequirement")) && !instantBreak) {
-+            instantBreak = true;
-+            Bukkit.broadcastMessage("This match is taking too long, Instant Break is now enabled!");
-+            logEvent("Instant break was enabled!");
-+        }
-+    }
-+
-+    public void onKill(MiraPlayer killed, MiraPlayer killer) {
-+        dropFlag(killed);
-+    }
-+
-+    public void onDeath(MiraPlayer dead) {
-+        dropFlag(dead);
-+    }
-+
-+    /**
-+     * if the player is holding a flag and they die,
-+     * drop the flag, restore it, and broadcast it.
-+     * this is called from both classes since they are
-+     * functionally identical except one has a killer.
-+     *
-+     * @param killed The player who died.
-+     */
-+    private void dropFlag(MiraPlayer killed) {
-+        for (CTFInfo inf : info.values()) {
-+            if (inf.getHolder() != null)
-+                if (inf.getHolder().equals(killed.name())) {
-+                    capture.remove(killed.name());
-+                    Bukkit.broadcastMessage(killed.display_name() + " dropped " + inf.getTeam().getDisplayName() + "'s flag!");
-+                    logEvent(killed.display_name() + " dropped " + inf.getTeam().getDisplayName() + "'s flag!");
-+                    for (Player target : Bukkit.getOnlinePlayers())
-+                        target.playSound(target.getLocation(), Sound.ENTITY_IRONGOLEM_HURT, 1F, 1F);
-+                    inf.setHolder(null);
-+                    restoreFlags();
-+                    updateScoreboard();
-+                }
-+        }
-+    }
-+
-+    public void decideWinner() {
-+        int highest = -1;
-+        ArrayList<WarTeam> winners = new ArrayList<>();
-+
-+        for (WarTeam team : getTeams()) {
-+            int count = info.get(team.getTeamName()).getCaptures();
-+            if (count == highest)
-+                winners.add(team);
-+            else if (count > highest) {
-+                highest = count;
-+                winners.clear();
-+                winners.add(team);
-+            }
-+        }
-+        broadcastWinner(winners, "captures", highest);
-+    }
-+
-+    public void onLeave(MiraPlayer left) {
-+        dropFlag(left);
-+    }
-+
-+    /**
-+     * spawns fireworks at each flag or flag holder location.
-+     */
-+    private void doFireworks() {
-+        for (CTFInfo inf : info.values())
-+            if (inf.getHolder() == null)
-+                ((MiraPvpMaster) main).entity().spawnFirework(inf.getFlag().clone().add(0.5, 1, 0.5), inf.getTeam().getTeamColor());
-+            else
-+                ((MiraPvpMaster) main).entity().spawnFirework(Bukkit.getPlayer(inf.getHolder()).getLocation(), inf.getTeam().getTeamColor());
-+    }
-+
-+    /**
-+     * restores any flags to their pedestals if
-+     * they are currently not being held.
-+     */
-+    private void restoreFlags() {
-+        for (CTFInfo inf : info.values())
-+            if (inf.getHolder() == null) {
-+                Block flag = inf.flag.getBlock();
-+                flag.setType(Material.WOOL);
-+                flag.setData(WoolColor.fromChatColor(inf.target.getTeamColor()).getColor());
-+            }
-+    }
-+
-+    public void updateScoreboard() {
-+        Objective obj = s().getObjective(DisplaySlot.SIDEBAR);
-+
-+        String dp = map().getMapName() + " (" + getName() + ")";
-+        if (dp.length() > 32) dp = dp.substring(0, 32);
-+        obj.setDisplayName(dp);
-+        obj.setDisplaySlot(DisplaySlot.SIDEBAR);
-+        
-+        obj.getScore(" ").setScore(info.size() + 2);
-+        obj.getScore("  Captures").setScore(info.size() + 1);
-+
-+        int rqmt = (int) map().attr().get("captureRequirement");
-+        Iterator<WarTeam> iterator = getTeams().iterator();
-+        for (int i = 0; i < info.size(); i++) {
-+            CTFInfo inf = info.get(iterator.next().getTeamName());
-+            if (inf.getHolder() == null) {
-+                obj.getScore(inf.getTeam().getTeamColor() + "    █ " + inf.getCaptures() + ChatColor.GRAY + "/" + rqmt).setScore(i + 1);
-+                s().resetScores(inf.getTeam().getTeamColor() + "    ▓ " + inf.getCaptures() + ChatColor.GRAY + "/" + rqmt);
-+                s().resetScores(inf.getTeam().getTeamColor() + "    █ " + (inf.getCaptures() - 1) + ChatColor.GRAY + "/" + rqmt);
-+                s().resetScores(inf.getTeam().getTeamColor() + "    ▓ " + (inf.getCaptures() - 1) + ChatColor.GRAY + "/" + rqmt);
-+            } else {
-+                obj.getScore(inf.getTeam().getTeamColor() + "    ▓ " + inf.getCaptures() + ChatColor.GRAY + "/" + rqmt).setScore(i + 1);
-+                s().resetScores(inf.getTeam().getTeamColor() + "    █ " + inf.getCaptures() + ChatColor.GRAY + "/" + rqmt);
-+            }
-+        }
-+        obj.getScore("  ").setScore(0);
-+    }
-+
-+
-+    public String getOffensive() {
-+        return "Steal the other enemy's flag and capture it by punching your flag!";
-+    }
-+
-+    public String getDefensive() {
-+        return "Stop the enemy from taking your flag!";
-+    }
-+
-+    public String getFullName() {
-+        return "Capture The Flag";
-+    }
-+
-+    public String getName() {
-+        return "CTF";
-+    }
-+
-+    public String getGrammar() {
-+        return "a";
-+    }
-+
-+    /**
-+     * check if a win has been attained after a capture.
-+     * if there is a win, onEnd should be called.
-+     *
-+     * @return whether or not any team has won.
-+     */
-+    private boolean checkWin() {
-+        for (CTFInfo inf : info.values())
-+            if (inf.getCaptures() >= (Integer) map().attr().get("captureRequirement"))
-+                return true;
-+        return false;
-+    }
-+
-+    @EventHandler
-+    public void onBreak(BlockBreakEvent event) {
-+        if (event.getBlock().getType() == Material.BEDROCK) return;
-+        MiraPlayer wp = main.getWarPlayer(event.getPlayer());
-+        if (checkBreak(wp, event.getBlock()))
-+            event.setCancelled(true);
-+    }
-+
-+    @EventHandler
-+    public void onPunch(PlayerInteractEvent event) {
-+        if (event.getClickedBlock() == null) return;
-+        MiraPlayer wp = main.getWarPlayer(event.getPlayer().getUniqueId());
-+        if (capture.containsKey(wp.name()))
-+            for (CTFInfo inf : info.values()) {
-+                if (inf.flag.equals(event.getClickedBlock().getLocation())) {
-+                    if (inf.target.getTeamName().equals(wp.getCurrentTeam().getTeamName())) {
-+                        if (inf.getHolder() == null) {
-+
-+                            for (Player target : Bukkit.getOnlinePlayers())
-+                                target.playSound(target.getLocation(), Sound.ENTITY_PLAYER_LEVELUP, 1F, 1F);
-+                            capture.remove(wp.name());
-+                            inf.addCapture();
-+                            for (CTFInfo inf2 : info.values())
-+                                if (inf2.getHolder() != null)
-+                                    if (inf2.getHolder().equals(wp.name())) {
-+                                        Bukkit.broadcastMessage(wp.display_name() + " captured " + inf2.getTeam().getDisplayName() + "'s flag!");
-+                                        logEvent(wp.display_name() + " captured " + inf2.getTeam().getDisplayName() + "'s flag");
-+                                        inf2.setHolder(null);
-+                                        break;
-+                                    }
-+                            restoreFlags();
-+                            updateScoreboard();
-+                            if (checkWin()) {
-+                                onEnd();
-+                                break;
-+                            }
-+                        } else
-+                            main.warn(wp.crafter(), inf.getHolder() + " is holding your team's flag. You cannot capture!");
-+                    }
-+                }
-+            }
-+        else if (instantBreak) {
-+            if (event.getAction() == Action.LEFT_CLICK_BLOCK) {
-+                checkBreak(wp, event.getClickedBlock());
-+            }
-+        }
-+    }
-+
-+    /**
-+     * checks if a block broken was a flag.
-+     * this also applies to instant capture mode.
-+     *
-+     * @param wp     the player who broke a block.
-+     * @param broken the block broken.
-+     * @return whether the event needs to be cancelled or not.
-+     */
-+    private boolean checkBreak(MiraPlayer wp, Block broken) {
-+        if (!wp.is_member_of_team()) return false;
-+        for (CTFInfo inf : info.values()) {
-+            if (inf.flag.equals(broken.getLocation())) {
-+                if (capture.containsKey(wp.name())) {
-+                    main.warn(wp.crafter(), "You can't steal more than one flag at once!");
-+                    return true;
-+                }
-+                if (wp.getCurrentTeam().getTeamName().equals(inf.target.getTeamName())) {
-+                    main.warn(wp.crafter(), "You can't steal your own flag! Defend it!");
-+                    return true;
-+                }
-+                inf.setHolder(wp.name());
-+
-+                capture.put(wp.name(), inf.target.getTeamColor() + inf.target.getTeamName());
-+                info.get(wp.getCurrentTeam().getTeamName()).addAttempt();
-+
-+                Bukkit.broadcastMessage(wp.display_name() + " has stolen " + inf.getTeam().getDisplayName() + "'s flag!");
-+                logEvent(wp.display_name() + " has stolen " + inf.getTeam().getDisplayName() + "'s flag");
-+
-+                for (Player target : Bukkit.getOnlinePlayers())
-+                    target.playSound(target.getLocation(), Sound.ENTITY_ARROW_HIT, 1F, 1F);
-+                broken.setType(Material.BEDROCK);
-+                updateScoreboard();
-+                return true;
-+            }
-+        }
-+        return false;
-+    }
-+
-+    @EventHandler
-+    public void onPickup(EntityPickupItemEvent event) {
-+        if (event.getItem().getItemStack().getType() == Material.WOOL) {
-+            event.setCancelled(true);
-+            event.getItem().remove();
-+        }
-+    }
-+
-+    @Override
-+    public HashMap<String, Object> getExtraTeamData(WarTeam team) {
-+        HashMap<String, Object> extra = new HashMap<>();
-+        extra.put("Flag Captures", info.get(team.getTeamName()).getCaptures());
-+        extra.put("Flag Steals", info.get(team.getTeamName()).getAttempts());
-+        return extra;
-+    }
-+
-+    /**
-+     * private record to hold a list of CTF information for a team.
-+     * this class holds:
-+     * -> the team associated with it.
-+     * -> the location of their flag.
-+     * -> the holder of their flag, if any.
-+     * -> the amount of captures they've made.
-+     * -> the amount of flag steals they've made.
-+     */
-+    private class CTFInfo {
-+        final WarTeam target;
-+        final Location flag;
-+        String holder;
-+        int captures;
-+        int attempts;
-+
-+        CTFInfo(WarTeam target) {
-+            this.target = target;
-+            flag = ((HashMap<String, SerializedLocation>) map().attr().get("flags")).get(target.getTeamName()).toLocation(main.match().getCurrentWorld(), false);
-+            holder = null;
-+            captures = 0;
-+            attempts = 0;
-+        }
-+
-+        void addCapture() {
-+            captures++;
-+        }
-+
-+        int getCaptures() {
-+            return captures;
-+        }
-+
-+        void addAttempt() {
-+            attempts++;
-+        }
-+
-+        int getAttempts() {
-+            return attempts;
-+        }
-+
-+        WarTeam getTeam() {
-+            return target;
-+        }
-+
-+        String getHolder() {
-+            return holder;
-+        }
-+
-+        void setHolder(String holder) {
-+            this.holder = holder;
-+        }
-+
-+        Location getFlag() {
-+            return flag;
-+        }
-+    }
-+}
-\ No newline at end of file
-diff --git a/src/sbs/mira/pvp/game/modes/DDM.java b/src/sbs/mira/pvp/game/modes/DDM.java
-new file mode 100644
-index 0000000..ab5bda4
---- /dev/null
-+++ b/src/sbs/mira/pvp/game/modes/DDM.java
-@@ -0,0 +1,231 @@
-+package sbs.mira.pvp.game.modes;
-+
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.stored.Activatable;
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.game.Gamemode;
-+import org.bukkit.Bukkit;
-+import org.bukkit.GameMode;
-+import org.bukkit.Location;
-+import org.bukkit.Sound;
-+import org.bukkit.entity.Player;
-+import org.bukkit.event.EventHandler;
-+import org.bukkit.event.HandlerList;
-+import org.bukkit.event.Listener;
-+import org.bukkit.event.player.PlayerMoveEvent;
-+import org.bukkit.scoreboard.DisplaySlot;
-+import org.bukkit.scoreboard.Objective;
-+
-+import java.util.ArrayList;
-+import java.util.HashMap;
-+import java.util.Iterator;
-+import java.util.Random;
-+
-+/**
-+ * an extension to gamemode to implement ddm.
-+ * created on 2017-04-26.
-+ *
-+ * @author jj.mira.sbs
-+ * @author jd.mira.sbs
-+ * @version 1.0.1
-+ * @see MiraPulse
-+ * @since 1.0.0
-+ */
-+public class DDM extends Gamemode {
-+
-+    private HashMap<String, Integer> scores;
-+
-+    public void reset() {
-+        if (scores != null)
-+            scores.clear();
-+        scores = null;
-+    }
-+
-+    public void initialize() {
-+        scores = new HashMap<>();
-+
-+        for (WarTeam team : getTeams())
-+            scores.put(team.getTeamName(), Bukkit.getOnlinePlayers().size() * 3);
-+        autoAssign();
-+        
-+        Objective obj = s().registerNewObjective("gm", "dummy");
-+        obj.setDisplaySlot(DisplaySlot.SIDEBAR);
-+        updateScoreboard();
-+
-+        for (Player online : Bukkit.getOnlinePlayers())
-+            online.setScoreboard(s());
-+    }
-+
-+    public void tick() {
-+    }
-+
-+    public void onKill(MiraPlayer killed, MiraPlayer killer) {
-+    }
-+
-+    public void onDeath(MiraPlayer killed) {
-+    }
-+
-+    public void onLeave(MiraPlayer left) {
-+    }
-+
-+    public String getOffensive() {
-+        return "Run into the enemy's \"territory\" to score a lot of points!";
-+    }
-+
-+    public String getDefensive() {
-+        return "Stop the enemy from getting into your \"territory\"!";
-+    }
-+
-+    public String getFullName() {
-+        return "District Death Match";
-+    }
-+
-+    public String getName() {
-+        return "DDM";
-+    }
-+
-+    public String getGrammar() {
-+        return "a";
-+    }
-+
-+    public void decideWinner() {
-+        int lowest = 999;
-+        ArrayList<WarTeam> winners = new ArrayList<>(); // Keep a temporary list of winners.
-+
-+        for (WarTeam team : getTeams()) {
-+            int count = scores.get(team.getTeamName());
-+            if (count == lowest)
-+                winners.add(team);
-+            else if (count < lowest) {
-+                lowest = count;
-+                winners.clear();
-+                winners.add(team);
-+            }
-+        }
-+        broadcastWinner(winners, "run-ins remaining", lowest);
-+    }
-+
-+    public void updateScoreboard() {
-+        Objective obj = s().getObjective(DisplaySlot.SIDEBAR);
-+
-+        String dp = map().getMapName() + " (" + getName() + ")";
-+        if (dp.length() > 32) dp = dp.substring(0, 32);
-+        obj.setDisplayName(dp);
-+        obj.setDisplaySlot(DisplaySlot.SIDEBAR);
-+
-+        obj.getScore(" ").setScore(scores.size() + 2);
-+        obj.getScore("  Run-ins Remaining").setScore(scores.size() + 1);
-+
-+        Iterator<WarTeam> iterator = getTeams().iterator();
-+        for (int i = 0; i < getTeams().size(); i++) {
-+            WarTeam target = iterator.next();
-+            obj.getScore(target.getTeamColor() + "    " + scores.get(target.getTeamName())).setScore(i + 1);
-+            s().resetScores(target.getTeamColor() + "    " + (scores.get(target.getTeamName()) + 1));
-+        }
-+        obj.getScore("  ").setScore(0);
-+    }
-+
-+    @Override
-+    protected HashMap<String, Object> getExtraTeamData(WarTeam team) {
-+        HashMap<String, Object> extra = new HashMap<>();
-+        extra.put("Remaining Score", scores.get(team.getTeamName()));
-+        return extra;
-+    }
-+
-+    /**
-+     * a territory is a cuboid, in which if an
-+     * opposing player runs into, scores a lot
-+     * of points for their team on DDM. Alongside
-+     * killing enemy players, they must also
-+     * protect their territory from being entered.
-+     */
-+    public static class Territory implements Listener, Activatable {
-+        final int x1;
-+        final int y1;
-+        final int z1;
-+        final int x2;
-+        final int y2;
-+        final int z2;
-+        final String belongsTo;
-+        final MiraPulse main;
-+
-+        public Territory(int x1, int y1, int z1, int x2, int y2, int z2, WarTeam belongsTo, MiraPulse main) {
-+            this.x1 = Math.min(x1, x2);
-+            this.y1 = Math.min(y1, y2);
-+            this.z1 = Math.min(z1, z2);
-+            this.x2 = Math.max(x1, x2);
-+            this.y2 = Math.max(y1, y2);
-+            this.z2 = Math.max(z1, z2);
-+            this.belongsTo = belongsTo.getDisplayName();
-+            this.main = main;
-+        }
-+
-+        /**
-+         * awaken this territory cuboid for the match.
-+         */
-+        public void activate() {
-+            if (!main.match().getCurrentMode().getFullName().equals("District Death Match"))
-+                return;
-+
-+            main.plugin().getServer().getPluginManager().registerEvents(this, main.plugin());
-+        }
-+
-+        /**
-+         * put this territory cuboid to sleep until it is needed again.
-+         */
-+        public void deactivate() {
-+            HandlerList.unregisterAll(this);
-+        }
-+
-+        /**
-+         * checks if a location is inside the cuboid.
-+         * this is used to check if a player has entered
-+         * this territory and needs to be acted upon.
-+         *
-+         * @param loc the location to compare.
-+         * @return are they inside the territory?
-+         */
-+        boolean isInside(Location loc) {
-+            return loc.getBlockX() >= x1 && loc.getBlockX() <= x2 && loc.getBlockY() >= y1 && loc.getBlockY() <= y2 && loc.getBlockZ() >= z1 && loc.getBlockZ() <= z2;
-+        }
-+
-+        @EventHandler
-+        public void nmv(PlayerMoveEvent event) {
-+            if (isInside(event.getTo()) && !event.getPlayer().isDead()) {
-+                if (!event.getPlayer().getGameMode().equals(GameMode.SURVIVAL)) return;
-+                MiraPlayer wp = main.getWarPlayer(event.getPlayer());
-+                if (wp.getCurrentTeam() == null) return;
-+
-+                WarTeam target = wp.getCurrentTeam();
-+                if (!target.getDisplayName().equals(belongsTo)) {
-+                    DDM ddm = (DDM) main.cache().getGamemode("District Death Match");
-+                    for (MiraPlayer wp2 : main.getWarPlayers().values()) {
-+                        if (wp2.getCurrentTeam() == null) continue;
-+                        if (!wp2.getCurrentTeam().getTeamName().equals(target.getTeamName()))
-+                            wp2.crafter().playSound(wp2.crafter().getLocation(), Sound.ENTITY_GHAST_SCREAM, 1F, 1F);
-+                        else
-+                            wp2.crafter().playSound(wp2.crafter().getLocation(), Sound.ENTITY_PLAYER_LEVELUP, 1F, 1F);
-+                    }
-+
-+                    Bukkit.broadcastMessage(wp.display_name() + " scored a point");
-+                    ddm.logEvent(wp.display_name() + " scored a point");
-+
-+                    int capsToGo = ddm.scores.get(target.getTeamName());
-+                    ddm.scores.put(target.getTeamName(), capsToGo - 1);
-+
-+                    ddm.updateScoreboard();
-+                    if (capsToGo == 1)
-+                        ddm.onEnd();
-+                    else
-+                        event.setTo(ddm.map().getTeamSpawns(target.getTeamName()).get(new Random().nextInt(ddm
-+                                .map().getTeamSpawns(target.getTeamName()).size())).toLocation(main.match().getCurrentWorld(), true));
-+                } else {
-+                    main.warn(event.getPlayer(), "You're supposed to stop the enemy from getting into here!");
-+                    event.setTo(event.getFrom());
-+                }
-+            }
-+        }
-+
-+    }
-+}
-\ No newline at end of file
-diff --git a/src/au/edu/swin/war/game/modes/DTM.java b/src/sbs/mira/pvp/game/modes/DTM.java
-similarity index 57%
-rename from src/au/edu/swin/war/game/modes/DTM.java
-rename to src/sbs/mira/pvp/game/modes/DTM.java
-index 3da0dc5..2f1d92e 100644
---- a/src/au/edu/swin/war/game/modes/DTM.java
-+++ b/src/sbs/mira/pvp/game/modes/DTM.java
-@@ -1,10 +1,10 @@
--package au.edu.swin.war.game.modes;
-+package sbs.mira.pvp.game.modes;
- 
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.stored.Activatable;
--import au.edu.swin.war.framework.util.WarManager;
--import au.edu.swin.war.game.Gamemode;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.stored.Activatable;
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.game.Gamemode;
- import org.bukkit.Bukkit;
- import org.bukkit.Location;
- import org.bukkit.Material;
-@@ -23,22 +23,19 @@ import org.bukkit.scoreboard.Objective;
- import java.util.*;
- 
- /**
-- * An extension to gamemode to implement DTM.
-- * Destroy The Monument objectives have been defined
-- * in my design brief, so I will assume you
-- * know what you are expecting to look at here.
-+ * an extension to gamemode to implement dtm.
-+ * created on 2017-04-26.
-  *
-- * @author s101601828 @ Swin.
-- * @version 1.0
-- * @see WarManager
-- * <p>
-- * Created by Josh on 26/04/2017.
-- * @since 1.0
-+ * @author jj.mira.sbs
-+ * @author jd.mira.sbs
-+ * @version 1.0.1
-+ * @see MiraPulse
-+ * @since 1.0.0
-  */
- public class DTM extends Gamemode {
- 
--    private List<Monument> monuments; // Keeps a temporary list of the monuments applicable for this match.
--    private boolean weak = false; // Are monuments weakened?
-+    private List<Monument> monuments;
-+    private boolean weak = false;
- 
-     public void reset() {
-         monuments.clear();
-@@ -47,7 +44,7 @@ public class DTM extends Gamemode {
-     }
- 
-     public void initialize() {
--        monuments = new ArrayList<>(); // Keep an array list of the monuments.
-+        monuments = new ArrayList<>();
-         for (Activatable objective : map().objectives())
-             if (objective instanceof Monument)
-                 monuments.add((Monument) objective);
-@@ -63,9 +60,7 @@ public class DTM extends Gamemode {
-     }
- 
-     public void tick() {
--        // If the amount of time remaining is 60 seconds,
-         if (map().getMatchDuration() - getTimeElapsed() <= 60 && !weak) {
--            // Enable "weak monument".
-             weak = true;
-             Bukkit.broadcastMessage("This match is about to end, Monuments have been weakened!");
-             logEvent("Monuments were weakened!");
-@@ -74,15 +69,15 @@ public class DTM extends Gamemode {
-         }
-     }
- 
--    public void onKill(WarPlayer killed, WarPlayer killer) {
-+    public void onKill(MiraPlayer killed, MiraPlayer killer) {
-     }
- 
--    public void onDeath(WarPlayer dead) {
-+    public void onDeath(MiraPlayer dead) {
-     }
- 
-     public void decideWinner() {
--        int highest = -1; // Highest is lower than zero since teams start off as zero.
--        ArrayList<WarTeam> winners = new ArrayList<>(); // Keep a temporary list of winners.
-+        int highest = -1;
-+        ArrayList<WarTeam> winners = new ArrayList<>();
- 
-         for (WarTeam team : getTeams()) {
-             // We will need to reassociate the WarTeam with this monument for dumb reasons.
-@@ -113,10 +108,10 @@ public class DTM extends Gamemode {
-     }
- 
-     /**
--     * Checks if one or less monuments are remaining.
--     * If true, end the round and decide the winner.
-+     * checks if one or less monuments are remaining.
-+     * if true, end the round and decide the winner.
-      *
--     * @return Whether or not someone has won.
-+     * @return whether or not someone has won.
-      */
-     private boolean checkWin() {
-         int monuments = 0;
-@@ -145,42 +140,35 @@ public class DTM extends Gamemode {
-         return "a";
-     }
- 
--    public void onLeave(WarPlayer left) {
--        //Nothing happens when a player leaves on DTM.
-+    public void onLeave(MiraPlayer left) {
-     }
- 
-     public void updateScoreboard() {
--        // Get the "objective" on the scoreboard, where data goes.
-         Objective obj = s().getObjective(DisplaySlot.SIDEBAR);
- 
--        // The title of the scoreboard, which displays the map and gamemode playing this match.
-         String dp = map().getMapName() + " (" + getName() + ")";
--        if (dp.length() > 32) dp = dp.substring(0, 32); // Titles cannot be longer than 32 characters.
--        obj.setDisplayName(dp); // Set the title of the scoreboard.
--        obj.setDisplaySlot(DisplaySlot.SIDEBAR); // Ensure it is on the sidebar.
--
--        // Format it pretty for the players.
--        obj.getScore(" ").setScore(getMonuments().size() + 2); // Top spacer.
--        obj.getScore("  Monuments").setScore(getMonuments().size() + 1); // 'Points' denoter.
--
--        Iterator<Monument> iterator = getMonuments().iterator(); // An iterator to iterate through the monuments.
--        for (int i = 0; i < getTeams().size(); i++) { // Only iterate the number of teams needed.
--            // For each monument, display their their damage colored respectively.
--            Monument target = iterator.next(); // Get the next monument to be iterated.
--            // Set the new score value.
--            int calc = target.calculatePercentage(0); // Calculate the percent remaining.
--            // Remove the old value from the board since it is not needed.
--            if (calc < 100) // Only reset it if it is below 100%.
-+        if (dp.length() > 32) dp = dp.substring(0, 32);
-+        obj.setDisplayName(dp);
-+        obj.setDisplaySlot(DisplaySlot.SIDEBAR);
-+
-+        obj.getScore(" ").setScore(getMonuments().size() + 2);
-+        obj.getScore("  Monuments").setScore(getMonuments().size() + 1);
-+
-+        Iterator<Monument> iterator = getMonuments().iterator();
-+        for (int i = 0; i < getTeams().size(); i++) {
-+            Monument target = iterator.next();
-+            int calc = target.calculatePercentage(0);
-+            if (calc < 100)
-                 s().resetScores(target.owner.getTeamColor() + "    " + target.calculatePercentage(1) + "%");
-             obj.getScore(target.owner.getTeamColor() + "    " + calc + "%").setScore(i + 1);
-         }
--        obj.getScore("  ").setScore(0); // Bottom spacer.
-+        obj.getScore("  ").setScore(0);
-     }
- 
-     /**
--     * Returns the map's list of monuments.
-+     * returns the map's list of monuments.
-      *
--     * @return List of monuments.
-+     * @return list of monuments.
-      */
-     private List<Monument> getMonuments() {
-         return monuments;
-@@ -189,19 +177,19 @@ public class DTM extends Gamemode {
-     @Override
-     public HashMap<String, Object> getExtraTeamData(WarTeam team) {
-         HashMap<String, Object> extra = new HashMap<>();
--        for (Monument mon : getMonuments()) { // We need to find the monument associated with the team...
--            if (!mon.owner.getDisplayName().equals(team.getDisplayName())) continue; // It's not this team...
--            List<String> footprint = new ArrayList<>(); // Keep a list of the footprint to format...
-+        for (Monument mon : getMonuments()) {
-+            if (!mon.owner.getDisplayName().equals(team.getDisplayName())) continue;
-+            List<String> footprint = new ArrayList<>();
-             for (Map.Entry<UUID, Integer> entry : mon.footprint.entrySet()) {
--                double contribution = Math.abs(Math.ceil((entry.getValue() * 100) / mon.origSize)); // Their contribution to the destruction.
--                WarPlayer wp = main.getWarPlayer(entry.getKey()); // Get their WarPlayer implement.
-+                double contribution = Math.abs(Math.ceil((entry.getValue() * 100) / mon.origSize));
-+                MiraPlayer wp = main.getWarPlayer(entry.getKey());
-                 if (wp != null)
--                    footprint.add(wp.getDisplayName() + " (" + contribution + "%)");
-+                    footprint.add(wp.display_name() + " (" + contribution + "%)");
-                 else
-                     footprint.add(Bukkit.getOfflinePlayer(entry.getKey()).getName() + " (" + contribution + "%)");
-             }
--            extra.put("Monument State", mon.calculatePercentage(0) + "%"); // Push the state of their monument.
--            if (footprint.size() != 0) // If applicable, push the footprint of the monument too.
-+            extra.put("Monument State", mon.calculatePercentage(0) + "%");
-+            if (footprint.size() != 0)
-                 extra.put("Damagers", main.strings().sentenceFormat(footprint));
-             break;
-         }
-@@ -209,34 +197,32 @@ public class DTM extends Gamemode {
-     }
- 
-     /**
--     * This class fully defines and operates a Monument.
--     * It can calculate the current damage to itself, the
-+     * this class fully defines and operates a Monument.
-+     * it can calculate the current damage to itself, the
-      * footprint of its damage, and the region in which
-      * can be broken further.
--     *
--     * @since 1.0
-      */
-     public static class Monument implements Listener, Activatable {
-         final int x1;
-         final int y1;
--        final int z1; // Bottom left applicable coordinates.
-+        final int z1;
-         final int x2;
-         final int y2;
--        final int z2; // Top right applicable coordinates.
--        final ArrayList<Material> composure; // What blocks are this monument made of?
--        final WarTeam owner; // What team owns this monument?
--        final List<Block> region = new ArrayList<>(); // The blocks associated with this monument.
--        final HashMap<UUID, Integer> footprint; // Track who's broken what amount of this monument.
--        final WarManager main; // A running instance of the WarManager class.
--        final boolean isVisible; // Is this monument visible if DTM is not playing?
--        int origSize; // The original size of the monument.
--        int blocksBroken; // The amount of blocks broken off the monument.
--
--        boolean destroyed = false; // Is this monument destroyed?
--        boolean weak = false; // Is this monument weak?
--        boolean active = false; // Should we do anything?
--
--        public Monument(int x1, int y1, int z1, int x2, int y2, int z2, WarTeam owner, WarManager main, boolean isVisible, Material... composure) {
-+        final int z2;
-+        final ArrayList<Material> composure;
-+        final WarTeam owner;
-+        final List<Block> region = new ArrayList<>();
-+        final HashMap<UUID, Integer> footprint;
-+        final MiraPulse main;
-+        final boolean isVisible;
-+        int origSize;
-+        int blocksBroken;
-+
-+        boolean destroyed = false;
-+        boolean weak = false;
-+        boolean active = false;
-+
-+        public Monument(int x1, int y1, int z1, int x2, int y2, int z2, WarTeam owner, MiraPulse main, boolean isVisible, Material... composure) {
-             this.x1 = Math.min(x1, x2);
-             this.y1 = Math.min(y1, y2);
-             this.z1 = Math.min(z1, z2);
-@@ -252,27 +238,24 @@ public class DTM extends Gamemode {
-         }
- 
-         /**
--         * Awaken this Monument for the round.
-+         * awaken this monument for the round.
-          */
-         public void activate() {
-             if (!isVisible)
-                 if (!main.match().getCurrentMode().getFullName().equals("Destroy The Monument")) {
--                    // Remove the monument if DTM is not being played on a map that supports monuments.
-                     for (Block bl : getBlocks())
-                         bl.setType(Material.AIR);
-                     return;
-                 }
- 
--            active = true; // We're active!
-+            active = true;
- 
--            // Calculate the monument region and activate listeners.
-             region.addAll(getBlocks());
-             main.plugin().getServer().getPluginManager().registerEvents(this, main.plugin());
-             origSize = region.size();
-             main.plugin().log("Activated monument with size of " + origSize);
-             blocksBroken = 0;
- 
--            // Incorrect/unexpected definition failsafe.
-             if (origSize == 0) {
-                 Bukkit.broadcastMessage("Warning: This match is invalid and will end in 3 seconds");
-                 Bukkit.getScheduler().runTaskLater(main.plugin(), () -> main.match().matchEnd(), 100L);
-@@ -280,7 +263,7 @@ public class DTM extends Gamemode {
-         }
- 
-         /**
--         * Put this Monument to sleep until it is needed again.
-+         * put this monument to sleep until it is needed again.
-          */
-         public void deactivate() {
-             HandlerList.unregisterAll(this);
-@@ -294,9 +277,9 @@ public class DTM extends Gamemode {
-         }
- 
-         /**
--         * Calculates current percentage of monument remaining.
-+         * calculates current percentage of monument remaining.
-          *
--         * @param diff Use this parameter to calculate a previous percentage.
-+         * @param diff use this parameter to calculate a previous percentage.
-          * @return The remaining percent.
-          */
-         int calculatePercentage(int diff) {
-@@ -328,24 +311,24 @@ public class DTM extends Gamemode {
-         }
- 
-         /**
--         * Checks if a location is inside the cuboid.
--         * This is used to check if a block has been
-+         * checks if a location is inside the cuboid.
-+         * this is used to check if a block has been
-          * broken inside this monument and needs to
-          * be checked.
-          *
--         * @param loc The location to compare.
--         * @return Is it inside the monument?
-+         * @param loc the location to compare.
-+         * @return is it inside the monument?
-          */
-         boolean isInside(Location loc) {
-             return loc.getX() >= x1 && loc.getX() <= x2 && loc.getY() >= y1 && loc.getY() <= y2 && loc.getZ() >= z1 && loc.getZ() <= z2;
-         }
- 
-         /**
--         * Checks for composure.
--         * Checks specifically for gold and glass if weak.
-+         * checks for composure.
-+         * checks specifically for gold and glass if weak.
-          *
--         * @param type Type to check.
--         * @return Is this a monument block?
-+         * @param type type to check.
-+         * @return is this a monument block?
-          */
-         boolean isComposed(Material type) {
-             if (!weak)
-@@ -354,35 +337,33 @@ public class DTM extends Gamemode {
-         }
- 
-         /**
--         * Get the blocks associated with this monument.
--         * Loops through x,y,z from bottom left to top
-+         * get the blocks associated with this monument.
-+         * loops through x,y,z from bottom left to top
-          * right to get the composure blocks.
-          *
-          * @return The monument region.
-          */
-         ArrayList<Block> getBlocks() {
-             ArrayList<Block> blocks = new ArrayList<>();
--            // For x,y,z... (a 3d cuboid)
-             for (int x = this.x1; x <= this.x2; x++)
-                 for (int y = this.y1; y <= this.y2; y++)
-                     for (int z = this.z1; z <= this.z2; z++)
--                        if (isComposed(main.match().getCurrentWorld().getBlockAt(x, y, z).getType())) // If this block matches the target composure..
--                            blocks.add(main.match().getCurrentWorld().getBlockAt(x, y, z)); // Add this as part of the monument region.
-+                        if (isComposed(main.match().getCurrentWorld().getBlockAt(x, y, z).getType()))
-+                            blocks.add(main.match().getCurrentWorld().getBlockAt(x, y, z));
-             return blocks;
-         }
- 
-         @EventHandler
-         public void onBreak(BlockBreakEvent event) {
-             if (!active) return;
--            if (isComposed(event.getBlock().getType())) // Is it the material we're tracking?
--                if (isInside(event.getBlock().getLocation())) // Was the block a part of the monument?
-+            if (isComposed(event.getBlock().getType()))
-+                if (isInside(event.getBlock().getLocation()))
-                     event.setCancelled(onBreak(event.getBlock(), main.getWarPlayer(event.getPlayer())));
-         }
- 
-         @EventHandler
-         public void onPlace(BlockPlaceEvent event) {
-             if (!active) return;
--            // Don't allow composure blocks to be placed inside the monument region.
-             if (isInside(event.getBlockPlaced().getLocation()))
-                 if (isComposed(event.getBlock().getType())) event.setCancelled(true);
-         }
-@@ -392,68 +373,61 @@ public class DTM extends Gamemode {
-             if (!active) return;
-             ArrayList<Block> toRemove = new ArrayList<>();
-             if (event.getEntity() instanceof TNTPrimed && ((TNTPrimed) event.getEntity()).getSource() instanceof Player) {
--                // If explosion was a player primed TNT...
--                WarPlayer source = main.getWarPlayer(((TNTPrimed) event.getEntity()).getSource().getUniqueId());
-+                MiraPlayer source = main.getWarPlayer(((TNTPrimed) event.getEntity()).getSource().getUniqueId());
-                 if (owner.getTeamName().equals(source.getCurrentTeam().getTeamName())) {
--                    // If they're griefing their own monument, cancel the explosion damage
-                     for (Block block : event.blockList())
-                         if (isComposed(block.getType()))
-                             if (isInside(block.getLocation()))
-                                 toRemove.add(block);
-                 } else
--                    // If this is a proper monument, do the damage
-                     for (Block block : event.blockList())
-                         if (isComposed(block.getType()))
-                             if (isInside(block.getLocation()))
-                                 onBreak(block, source);
--            } else // Any non-player explosion, cancel
-+            } else
-                 for (Block block : event.blockList())
-                     if (isComposed(block.getType()))
-                         if (isInside(block.getLocation()))
-                             toRemove.add(block);
--            // Don't allow explosions to damage the monument.
-             event.blockList().removeAll(toRemove);
-         }
- 
-         /**
--         * Returns true if block should be reverted.
--         * Returns false if block is broken.
-+         * returns true if block should be reverted.
-+         * returns false if block is broken.
-          *
--         * @param block Block that was broken.
--         * @param wp    Player who broke it.
-+         * @param block block that was broken.
-+         * @param wp    player who broke it.
-          * @return See above.
-          */
--        private boolean onBreak(Block block, WarPlayer wp) {
--            if (wp.getCurrentTeam() == null) return true; // Are they even playing?
--            if (wp.getCurrentTeam().getDisplayName().equals(owner.getDisplayName()))  // Did they break their own monument?
-+        private boolean onBreak(Block block, MiraPlayer wp) {
-+            if (wp.getCurrentTeam() == null) return true;
-+            if (wp.getCurrentTeam().getDisplayName().equals(owner.getDisplayName()))
-                 return true;
--            region.remove(block); // They did, let's remove it from the monument blocks.
--            blocksBroken++; // Increment the amount of blocks remaining.
--
--            // Increment a player's footprint on the monument.
--            // Footprint being how much % they've destroyed.
--            if (!footprint.containsKey(wp.getPlayer().getUniqueId()))
--                footprint.put(wp.getPlayer().getUniqueId(), 1);
--            else footprint.put(wp.getPlayer().getUniqueId(), footprint.get(wp.getPlayer().getUniqueId()) + 1);
-+            region.remove(block);
-+            blocksBroken++;
- 
--            int calc = calculatePercentage(0); // Calculate the percentage of the monument remaining.
-+            if (!footprint.containsKey(wp.crafter().getUniqueId()))
-+                footprint.put(wp.crafter().getUniqueId(), 1);
-+            else footprint.put(wp.crafter().getUniqueId(), footprint.get(wp.crafter().getUniqueId()) + 1);
- 
--            DTM dtm = (DTM) main.cache().getGamemode("Destroy The Monument"); // Get the DTM running instance.
-+            int calc = calculatePercentage(0);
-+            DTM dtm = (DTM) main.cache().getGamemode("Destroy The Monument");
- 
--            if (calculatePercentage(2) == 101) { // Has this monument initially taken damage?
-+            if (calculatePercentage(2) == 101) {
-                 Bukkit.broadcastMessage(owner + "'s monument has been damaged!");
--                dtm.logEvent(wp.getDisplayName() + " damaged " + owner + "'s monument");
-+                dtm.logEvent(wp.display_name() + " damaged " + owner + "'s monument");
-             }
- 
--            if (calc <= 0) { // Has this monument been destroyed?
-+            if (calc <= 0) {
-                 destroy();
-                 Bukkit.broadcastMessage(owner + "'s monument has been destroyed!");
--                dtm.logEvent(wp.getDisplayName() + " destroyed " + owner + "'s monument");
-+                dtm.logEvent(wp.display_name() + " destroyed " + owner + "'s monument");
-             }
- 
-             dtm.updateScoreboard();
--            if (dtm.checkWin()) // Has someone won?
--                dtm.onEnd(); // Good game!
-+            if (dtm.checkWin())
-+                dtm.onEnd();
-             return false;
-         }
-     }
-diff --git a/src/sbs/mira/pvp/game/modes/FFA.java b/src/sbs/mira/pvp/game/modes/FFA.java
-new file mode 100644
-index 0000000..89ba309
---- /dev/null
-+++ b/src/sbs/mira/pvp/game/modes/FFA.java
-@@ -0,0 +1,173 @@
-+package sbs.mira.pvp.game.modes;
-+
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.game.Gamemode;
-+import org.bukkit.Bukkit;
-+import org.bukkit.ChatColor;
-+import org.bukkit.entity.Player;
-+import org.bukkit.scoreboard.DisplaySlot;
-+import org.bukkit.scoreboard.Objective;
-+
-+import java.util.ArrayList;
-+import java.util.HashMap;
-+import java.util.Map;
-+import java.util.UUID;
-+
-+/**
-+ * an extension to gamemode to implement ffa.
-+ * created on 2017-04-26.
-+ *
-+ * @author jj.mira.sbs
-+ * @author jd.mira.sbs
-+ * @version 1.0.1
-+ * @see MiraPulse
-+ * @since 1.0.0
-+ */
-+public class FFA extends Gamemode {
-+
-+    private HashMap<UUID, Integer> kills;
-+    private int leadKills;
-+    private UUID leader;
-+
-+    public void reset() {
-+        kills.clear();
-+        kills = null;
-+    }
-+
-+    public void initialize() {
-+        kills = new HashMap<>();
-+
-+        for (WarTeam team : getTeams())
-+            team.getBukkitTeam().setAllowFriendlyFire(true);
-+
-+        leadKills = 0;
-+
-+        autoAssign();
-+
-+        Objective obj = s().registerNewObjective("gm", "dummy");
-+        obj.setDisplaySlot(DisplaySlot.SIDEBAR);
-+        updateScoreboard();
-+
-+        for (Player online : Bukkit.getOnlinePlayers())
-+            online.setScoreboard(s());
-+    }
-+
-+    public void tick() {
-+    }
-+
-+    public void onKill(MiraPlayer killed, MiraPlayer killer) {
-+        if (kills.containsKey(killer.crafter().getUniqueId()))
-+            kills.put(killer.crafter().getUniqueId(), kills.get(killer.crafter().getUniqueId()) + 1);
-+        else
-+            kills.put(killer.crafter().getUniqueId(), 1);
-+        int cKills = kills.get(killer.crafter().getUniqueId());
-+        if (cKills > leadKills) {
-+            leadKills = cKills;
-+            if (!killer.crafter().getUniqueId().equals(leader)) {
-+                leader = killer.crafter().getUniqueId();
-+                Bukkit.broadcastMessage(killer.display_name() + " is now the leader");
-+                logEvent(killer.display_name() + " is now the leader");
-+            }
-+        }
-+        killer.dm("You now have " + cKills + "/" + getFFAKills() + " kills");
-+        updateScoreboard();
-+        checkWin(killer.crafter().getUniqueId());
-+    }
-+
-+    public void onDeath(MiraPlayer dead) {
-+    }
-+
-+    public void decideWinner() {
-+        int highest = -1;
-+        ArrayList<String> winners = new ArrayList<>();
-+
-+        for (Map.Entry<UUID, Integer> entry : kills.entrySet()) {
-+            MiraPlayer found = main.getWarPlayer(entry.getKey());
-+            if (found == null) continue;
-+            int count = entry.getValue();
-+            if (count == highest)
-+                winners.add(found.display_name());
-+            else if (count > highest) {
-+                highest = count;
-+                winners.clear();
-+                winners.add(found.display_name());
-+            }
-+        }
-+
-+        if (winners.size() > 1) {
-+            Bukkit.broadcastMessage("It's a " + winners.size() + "-way tie! " + main.strings().sentenceFormat(winners) + " tied!");
-+            tempWinner = main.strings().sentenceFormat(winners);
-+        } else if (winners.size() == 1) {
-+            String winner = winners.get(0);
-+            Bukkit.broadcastMessage(winner + ChatColor.WHITE + " is the winner with " + highest + " points!");
-+            tempWinner = main.strings().sentenceFormat(winners);
-+        }
-+    }
-+
-+    public String getOffensive() {
-+        return "Kill players to score points for yourself!";
-+    }
-+
-+    public String getDefensive() {
-+        return "Don't let other players kill you!";
-+    }
-+
-+    public String getFullName() {
-+        return "Free For All";
-+    }
-+
-+    public String getName() {
-+        return "FFA";
-+    }
-+
-+    public String getGrammar() {
-+        return "an";
-+    }
-+
-+    public void onLeave(MiraPlayer left) {
-+    }
-+
-+    public void updateScoreboard() {
-+        Objective obj = s().getObjective(DisplaySlot.SIDEBAR);
-+
-+        String dp = map().getMapName() + " (" + getName() + ")";
-+        if (dp.length() > 32) dp = dp.substring(0, 32);
-+        obj.setDisplayName(dp);
-+        obj.setDisplaySlot(DisplaySlot.SIDEBAR);
-+
-+        obj.getScore(" ").setScore(3);
-+        obj.getScore("  Leader's Kills").setScore(2);
-+        obj.getScore("    " + leadKills + "/" + getFFAKills()).setScore(1);
-+        obj.getScore("  ").setScore(0);
-+        s().resetScores("    " + (leadKills - 1) + "/" + getFFAKills());
-+
-+    }
-+
-+    /**
-+     * if the player reaches the kill cap, this
-+     * procedure will automatically end the round.
-+     *
-+     * @param player player to check.
-+     */
-+    private void checkWin(UUID player) {
-+        if (kills.get(player) >= getFFAKills())
-+            onEnd();
-+    }
-+
-+    /**
-+     * returns the map's defined score cap for FFA.
-+     * ny default, this score cap is set to 20.
-+     *
-+     * @return FFA score cap.
-+     */
-+    private Integer getFFAKills() {
-+        return (Integer) map().attr().get("ffaKills");
-+    }
-+
-+    @Override
-+    public HashMap<String, Object> getExtraTeamData(WarTeam team) {
-+        return new HashMap<>();
-+    }
-+}
-diff --git a/src/sbs/mira/pvp/game/modes/KoTH.java b/src/sbs/mira/pvp/game/modes/KoTH.java
-new file mode 100644
-index 0000000..d896802
---- /dev/null
-+++ b/src/sbs/mira/pvp/game/modes/KoTH.java
-@@ -0,0 +1,219 @@
-+package sbs.mira.pvp.game.modes;
-+
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.stored.SerializedLocation;
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.game.Gamemode;
-+import sbs.mira.pvp.MiraPvpMaster;
-+import sbs.mira.pvp.util.WoolColor;
-+import org.bukkit.*;
-+import org.bukkit.entity.Player;
-+import org.bukkit.event.EventHandler;
-+import org.bukkit.event.block.BlockBreakEvent;
-+import org.bukkit.event.entity.EntityExplodeEvent;
-+import org.bukkit.event.player.PlayerPickupItemEvent;
-+import org.bukkit.scoreboard.DisplaySlot;
-+import org.bukkit.scoreboard.Objective;
-+
-+import java.util.ArrayList;
-+import java.util.HashMap;
-+import java.util.Iterator;
-+
-+/**
-+ * an extension to gamemode to implement koth.
-+ * created on 2017-04-23.
-+ *
-+ * @author jj.mira.sbs
-+ * @author jd.mira.sbs
-+ * @version 1.0.1
-+ * @see MiraPulse
-+ * @since 1.0.0
-+ */
-+public class KoTH extends Gamemode {
-+
-+    private WarTeam holder;
-+    private HashMap<String, Integer> captureTime;
-+    private HashMap<String, Integer> captures;
-+    private Location flag;
-+    private int interval;
-+
-+    public void reset() {
-+        flag = null;
-+        holder = null;
-+        if (captureTime != null)
-+            captureTime.clear();
-+        captureTime = null;
-+    }
-+
-+    public void initialize() {
-+        interval = 1;
-+        captureTime = new HashMap<>();
-+        captures = new HashMap<>();
-+        flag = ((SerializedLocation) map().attr().get("kothFlag")).toLocation(main.match().getCurrentWorld(), false);
-+
-+        for (WarTeam team : getTeams()) {
-+            captureTime.put(team.getTeamName(), (Integer) map().attr().get("captureTime"));
-+            captures.put(team.getTeamName(), 0);
-+        }
-+
-+        main.match().getCurrentWorld().getBlockAt(flag).setType(Material.WOOL);
-+
-+        autoAssign();
-+
-+        Objective obj = s().registerNewObjective("gm", "dummy");
-+        obj.setDisplaySlot(DisplaySlot.SIDEBAR);
-+        updateScoreboard();
-+
-+        for (Player online : Bukkit.getOnlinePlayers())
-+            online.setScoreboard(s());
-+    }
-+
-+    public void tick() {
-+        if (holder != null) {
-+            int holdTime = captureTime.get(holder.getTeamName());
-+            captureTime.put(holder.getTeamName(), holdTime - 1);
-+            updateScoreboard();
-+            holdTime--;
-+            if (holdTime == 5) {
-+                logEvent(holder.getDisplayName() + " will win in 5 seconds!");
-+                Bukkit.broadcastMessage(holder.getDisplayName() + " will win in 5 seconds!");
-+            } else if (holdTime == 0) {
-+                onEnd();
-+                return;
-+            }
-+        }
-+        interval--;
-+        if (interval == 0) {
-+            interval = 4;
-+            doFireworks();
-+        }
-+    }
-+
-+    public void onKill(MiraPlayer killed, MiraPlayer killer) {
-+    }
-+
-+    public void onLeave(MiraPlayer left) {
-+    }
-+
-+    public void onDeath(MiraPlayer killed) {
-+    }
-+
-+    public void decideWinner() {
-+        int lowest = 999;
-+        ArrayList<WarTeam> winners = new ArrayList<>();
-+
-+        for (WarTeam team : getTeams()) {
-+            int time = captureTime.get(team.getTeamName());
-+            if (time == lowest)
-+                winners.add(team);
-+            else if (time < lowest) {
-+                lowest = time;
-+                winners.clear();
-+                winners.add(team);
-+            }
-+        }
-+        broadcastWinner(winners, "seconds remaining", lowest);
-+    }
-+
-+    /**
-+     * koth-specific procedure to spawn a firework at the flag.
-+     * if no one is holding it, spawn a white firework.
-+     * if a team is holding it, spawn a holding-team-colored firework.
-+     */
-+    private void doFireworks() {
-+        if (holder == null) // Spawn white.
-+            ((MiraPvpMaster) main).entity().spawnFirework(flag.clone().add(0.5, 1, 0.5), ChatColor.WHITE);
-+        else
-+            ((MiraPvpMaster) main).entity().spawnFirework(flag.clone().add(0.5, 1, 0.5), holder.getTeamColor());
-+    }
-+
-+    public void updateScoreboard() {
-+        Objective obj = s().getObjective(DisplaySlot.SIDEBAR);
-+
-+        String dp = map().getMapName() + " (" + getName() + ")";
-+        if (dp.length() > 32) dp = dp.substring(0, 32);
-+        obj.setDisplayName(dp);
-+        obj.setDisplaySlot(DisplaySlot.SIDEBAR);
-+
-+        obj.getScore(" ").setScore(captureTime.size() + 2);
-+        obj.getScore("  Time Remaining").setScore(captureTime.size() + 1);
-+
-+        Iterator<WarTeam> iterator = getTeams().iterator();
-+        for (int i = 0; i < captureTime.size(); i++) {
-+            WarTeam target = iterator.next();
-+            obj.getScore(target.getTeamColor() + "    " + main.strings().getDigitalTime(captureTime.get(target.getTeamName()))).setScore(i + 1);
-+            s().resetScores(target.getTeamColor() + "    " + main.strings().getDigitalTime(captureTime.get(target.getTeamName()) + 1));
-+        }
-+        obj.getScore("  ").setScore(0);
-+    }
-+
-+    public String getOffensive() {
-+        return "Break the wool in the middle of the map to control the flag!";
-+    }
-+
-+    public String getDefensive() {
-+        return "Stop the enemy from controlling the flag if you have control!";
-+    }
-+
-+    public String getFullName() {
-+        return "King of The Hill";
-+    }
-+
-+    public String getName() {
-+        return "KoTH";
-+    }
-+
-+    public String getGrammar() {
-+        return "a";
-+    }
-+
-+    @EventHandler
-+    public void onBreak(BlockBreakEvent event) {
-+        MiraPlayer wp = main.getWarPlayer(event.getPlayer());
-+        if (event.getBlock().getLocation().equals(flag)) {
-+            event.setCancelled(true);
-+            WarTeam target = wp.getCurrentTeam();
-+            if (target == null) return;
-+            if (holder == target)
-+                wp.crafter().sendMessage("You already have control of the flag!");
-+            else {
-+                Bukkit.broadcastMessage(wp.display_name() + " took the flag for " + target.getDisplayName() + "!");
-+                if (holder == null)
-+                    logEvent(wp.display_name() + " captured the flag first!");
-+                else
-+                    logEvent(wp.display_name() + " captured the flag for " + target.getDisplayName());
-+                holder = target;
-+
-+                for (Player online : Bukkit.getOnlinePlayers())
-+                    online.playSound(online.getLocation(), Sound.ENTITY_ENDERDRAGON_HURT, 1F, 1F);
-+                updateScoreboard();
-+                captures.put(target.getTeamName(), captures.get(target.getTeamName()) + 1);
-+
-+                event.getBlock().getLocation().getBlock().setType(Material.WOOL);
-+                event.getBlock().getLocation().getBlock().setData(WoolColor.fromChatColor(target.getTeamColor()).getColor());
-+            }
-+        }
-+    }
-+
-+    @EventHandler
-+    public void onExplode(EntityExplodeEvent event) {
-+        event.blockList().remove(flag.getBlock());
-+    }
-+
-+    @EventHandler
-+    public void onPickup(PlayerPickupItemEvent event) {
-+        if (event.getItem().getItemStack().getType() == Material.WOOL) {
-+            event.setCancelled(true);
-+            event.getItem().remove();
-+        }
-+    }
-+
-+    @Override
-+    public HashMap<String, Object> getExtraTeamData(WarTeam team) {
-+        HashMap<String, Object> extra = new HashMap<>();
-+        extra.put("Capture Time", main.strings().getDigitalTime(captureTime.get(team.getTeamName())));
-+        extra.put("Flag Captures", captures.get(team.getTeamName()));
-+        return extra;
-+    }
-+}
-\ No newline at end of file
-diff --git a/src/sbs/mira/pvp/game/modes/LMS.java b/src/sbs/mira/pvp/game/modes/LMS.java
-new file mode 100644
-index 0000000..4498a00
---- /dev/null
-+++ b/src/sbs/mira/pvp/game/modes/LMS.java
-@@ -0,0 +1,195 @@
-+package sbs.mira.pvp.game.modes;
-+
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.game.Gamemode;
-+import org.bukkit.Bukkit;
-+import org.bukkit.entity.Player;
-+import org.bukkit.event.EventHandler;
-+import org.bukkit.event.player.PlayerToggleSneakEvent;
-+import org.bukkit.scoreboard.DisplaySlot;
-+import org.bukkit.scoreboard.Objective;
-+
-+import java.util.ArrayList;
-+import java.util.HashMap;
-+import java.util.UUID;
-+
-+/**
-+ * an extension to gamemode to implement lms.
-+ * created on 2017-04-26.
-+ *
-+ * @author jj.mira.sbs
-+ * @author jd.mira.sbs
-+ * @version 1.0.1
-+ * @see MiraPulse
-+ * @since 1.0.0
-+ */
-+public class LMS extends Gamemode {
-+
-+    private ArrayList<UUID> participated;
-+    private ArrayList<UUID> alive;
-+
-+    public void reset() {
-+        if (participated != null)
-+            while (participated.size() > 0) {
-+                MiraPlayer wp = main.getWarPlayer(participated.get(0));
-+                if (wp != null)
-+                    wp.setJoined(true);
-+                participated.remove(participated.get(0));
-+            }
-+        participated = null;
-+        
-+        if (alive != null)
-+            alive.clear();
-+        alive = null;
-+    }
-+
-+    public void initialize() {
-+        alive = new ArrayList<>();
-+        participated = new ArrayList<>();
-+
-+        if (getJoined() < 2) {
-+            // LMS requires 2 players at the least to play.
-+            Bukkit.broadcastMessage("There needs to be 2 or more participating players!");
-+            logEvent("Match cancelled as there was not enough players");
-+            onEnd();
-+            return;
-+        }
-+
-+        for (WarTeam team : getTeams())
-+            team.getBukkitTeam().setAllowFriendlyFire(true);
-+
-+        autoAssign();
-+
-+        for (MiraPlayer check : main.getWarPlayers().values())
-+            if (check.is_member_of_team()) {
-+                alive.add(check.crafter().getUniqueId());
-+                participated.add(check.crafter().getUniqueId());
-+            }
-+
-+        permaDeath = true;
-+
-+        Objective obj = s().registerNewObjective("gm", "dummy");
-+        obj.setDisplaySlot(DisplaySlot.SIDEBAR);
-+        updateScoreboard();
-+
-+        for (Player online : Bukkit.getOnlinePlayers())
-+            online.setScoreboard(s());
-+    }
-+
-+    public void tick() {
-+    }
-+
-+    public void onKill(MiraPlayer killed, MiraPlayer killer) {
-+        dead(killed);
-+    }
-+
-+    public void onDeath(MiraPlayer dead) {
-+        dead(dead);
-+    }
-+
-+    /**
-+     * common code is shared by onKill and onDeath,
-+     * both call to this procedure to prevent duplication.
-+     *
-+     * @param dead the player who died.
-+     */
-+    private void dead(MiraPlayer dead) {
-+        alive.remove(dead.crafter().getUniqueId());
-+
-+        updateScoreboard();
-+
-+        dead.setJoined(false);
-+        entryHandle(dead);
-+
-+        checkWin();
-+    }
-+
-+    public void decideWinner() {
-+        if (alive.size() == 1) {
-+            MiraPlayer winner = main.getWarPlayer(alive.get(0));
-+            if (winner != null) {
-+                tempWinner = winner.display_name();
-+                Bukkit.broadcastMessage(winner.display_name() + " is the last man standing!");
-+                return;
-+            }
-+        }
-+        Bukkit.broadcastMessage("There was no winner this match!");
-+        tempWinner = "No one";
-+    }
-+
-+    public String getOffensive() {
-+        return "Kill other players!";
-+    }
-+
-+    public String getDefensive() {
-+        return "Don't get yourself killed!";
-+    }
-+
-+    public String getFullName() {
-+        return "Last Man Standing";
-+    }
-+
-+    public String getName() {
-+        return "LMS";
-+    }
-+
-+    public String getGrammar() {
-+        return "an";
-+    }
-+
-+    public void onLeave(MiraPlayer left) {
-+        if (!alive.contains(left.crafter().getUniqueId())) return;
-+
-+        alive.remove(left.crafter().getUniqueId());
-+
-+        updateScoreboard();
-+        checkWin();
-+    }
-+
-+    public void updateScoreboard() {
-+        Objective obj = s().getObjective(DisplaySlot.SIDEBAR);
-+
-+        String dp = map().getMapName() + " (" + getName() + ")";
-+        if (dp.length() > 32) dp = dp.substring(0, 32);
-+        obj.setDisplayName(dp);
-+        obj.setDisplaySlot(DisplaySlot.SIDEBAR);
-+
-+        obj.getScore(" ").setScore(3);
-+        obj.getScore("  Still Standing").setScore(2);
-+        obj.getScore("    " + alive.size() + "/" + participated.size()).setScore(1);
-+        obj.getScore("  ").setScore(0);
-+        s().resetScores("    " + (alive.size() + 1) + "/" + participated.size());
-+
-+    }
-+
-+    /**
-+     * if there is 1 or less players remaining,
-+     * the match is over since it is a last man
-+     * standing match.
-+     */
-+    private void checkWin() {
-+        if (alive.size() <= 1 && active)
-+            onEnd();
-+    }
-+
-+    /**
-+     * sneaking is a strategy often used to hide
-+     * on maps, so sneaking will not allow you to
-+     * hide your name tag behind walls.
-+     *
-+     * @param event an event called by Spigot.
-+     */
-+    @EventHandler
-+    public void onSneak(PlayerToggleSneakEvent event) {
-+        event.setCancelled(true);
-+    }
-+
-+    @Override
-+    public HashMap<String, Object> getExtraTeamData(WarTeam team) {
-+        HashMap<String, Object> extra = new HashMap<>();
-+        extra.put("Participants", participated.size());
-+        return extra;
-+    }
-+}
-diff --git a/src/sbs/mira/pvp/game/modes/LP.java b/src/sbs/mira/pvp/game/modes/LP.java
-new file mode 100644
-index 0000000..fee0ae8
---- /dev/null
-+++ b/src/sbs/mira/pvp/game/modes/LP.java
-@@ -0,0 +1,149 @@
-+package sbs.mira.pvp.game.modes;
-+
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.game.Gamemode;
-+import org.bukkit.Bukkit;
-+import org.bukkit.entity.Player;
-+import org.bukkit.scoreboard.DisplaySlot;
-+import org.bukkit.scoreboard.Objective;
-+
-+import java.util.ArrayList;
-+import java.util.HashMap;
-+import java.util.Iterator;
-+
-+/**
-+ * an extension to gamemode to implement lp.
-+ * created on 2017-04-21.
-+ *
-+ * @author jj.mira.sbs
-+ * @author jd.mira.sbs
-+ * @version 1.0.1
-+ * @see MiraPulse
-+ * @since 1.0.0
-+ */
-+public class LP extends Gamemode {
-+
-+    private final HashMap<String, Integer> lives = new HashMap<>();
-+
-+    public void reset() {
-+        lives.clear();
-+    }
-+
-+    public void initialize() {
-+        for (WarTeam team : getTeams())
-+            lives.put(team.getTeamName(), (Bukkit.getOnlinePlayers().size() * 5) + 3);
-+
-+        autoAssign();
-+
-+        Objective obj = s().registerNewObjective("gm", "dummy");
-+        obj.setDisplaySlot(DisplaySlot.SIDEBAR);
-+        updateScoreboard();
-+
-+        for (Player online : Bukkit.getOnlinePlayers())
-+            online.setScoreboard(s());
-+    }
-+
-+    public void tick() {
-+    }
-+
-+    public void onKill(MiraPlayer killed, MiraPlayer killer) {
-+        death(killed);
-+    }
-+
-+    public void onDeath(MiraPlayer killed) {
-+        death(killed);
-+    }
-+
-+    /**
-+     * procedure that handles death within a round.
-+     * a life is decremented from the dead player's
-+     * team's life pool.
-+     *
-+     * @param killed player who died.
-+     */
-+    private void death(MiraPlayer killed) {
-+        int lives = this.lives.get(killed.getCurrentTeam().getTeamName());
-+        if (lives == 0) return;
-+        this.lives.put(killed.getCurrentTeam().getTeamName(), lives - 1);
-+        updateScoreboard();
-+        checkWin();
-+    }
-+
-+    public void decideWinner() {
-+        int highest = -1;
-+        ArrayList<WarTeam> winners = new ArrayList<>();
-+
-+        for (WarTeam team : getTeams()) {
-+            int count = lives.get(team.getTeamName());
-+            if (count == highest)
-+                winners.add(team);
-+            else if (count > highest) {
-+                highest = count;
-+                winners.clear();
-+                winners.add(team);
-+            }
-+        }
-+        broadcastWinner(winners, "lives remaining", highest);
-+    }
-+
-+    private void checkWin() {
-+        int aliveTeams = 0;
-+        for (WarTeam team : getTeams())
-+            if (lives.get(team.getTeamName()) >= 1)
-+                aliveTeams++;
-+        if (aliveTeams <= 1)
-+            onEnd();
-+    }
-+
-+    public String getOffensive() {
-+        return "Kill enemies to deplete their lifepool!";
-+    }
-+
-+    public String getDefensive() {
-+        return "Protect your team and your lives!";
-+    }
-+
-+    public String getName() {
-+        return "LP";
-+    }
-+
-+    public String getFullName() {
-+        return "Lifepool";
-+    }
-+
-+    public String getGrammar() {
-+        return "an";
-+    }
-+
-+    public void onLeave(MiraPlayer left) {
-+    }
-+
-+    public void updateScoreboard() {
-+        Objective obj = s().getObjective(DisplaySlot.SIDEBAR);
-+
-+        String dp = map().getMapName() + " (" + getName() + ")";
-+        if (dp.length() > 32) dp = dp.substring(0, 32);
-+        obj.setDisplayName(dp);
-+        obj.setDisplaySlot(DisplaySlot.SIDEBAR);
-+
-+        obj.getScore(" ").setScore(lives.size() + 2);
-+        obj.getScore("  Lives Remaining").setScore(lives.size() + 1);
-+
-+        Iterator<WarTeam> iterator = getTeams().iterator();
-+        for (int i = 0; i < lives.size(); i++) {
-+            WarTeam target = iterator.next();
-+            obj.getScore(target.getTeamColor() + "    " + lives.get(target.getTeamName())).setScore(i + 1);
-+            s().resetScores(target.getTeamColor() + "    " + (lives.get(target.getTeamName()) + 1));
-+        }
-+        obj.getScore("  ").setScore(0);
-+    }
-+
-+    @Override
-+    public HashMap<String, Object> getExtraTeamData(WarTeam team) {
-+        HashMap<String, Object> extra = new HashMap<>();
-+        extra.put("Lives Remaining", lives.get(team.getTeamName()));
-+        return extra;
-+    }
-+}
-diff --git a/src/sbs/mira/pvp/game/modes/LTS.java b/src/sbs/mira/pvp/game/modes/LTS.java
-new file mode 100644
-index 0000000..3246993
---- /dev/null
-+++ b/src/sbs/mira/pvp/game/modes/LTS.java
-@@ -0,0 +1,194 @@
-+package sbs.mira.pvp.game.modes;
-+
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.game.Gamemode;
-+import org.bukkit.Bukkit;
-+import org.bukkit.entity.Player;
-+import org.bukkit.event.EventHandler;
-+import org.bukkit.event.player.PlayerToggleSneakEvent;
-+import org.bukkit.scoreboard.DisplaySlot;
-+import org.bukkit.scoreboard.Objective;
-+
-+import java.util.ArrayList;
-+import java.util.HashMap;
-+import java.util.Iterator;
-+import java.util.UUID;
-+
-+/**
-+ * an extension to gamemode to implement lts.
-+ * created on 2017-04-26.
-+ *
-+ * @author jj.mira.sbs
-+ * @author jd.mira.sbs
-+ * @version 1.0.1
-+ * @since 1.0.0
-+ */
-+public class LTS extends Gamemode {
-+
-+    private ArrayList<UUID> participated;
-+    private HashMap<String, Integer> original;
-+
-+    public void reset() {
-+        if (participated != null)
-+            while (participated.size() > 0) {
-+                MiraPlayer wp = main.getWarPlayer(participated.get(0));
-+                if (wp != null)
-+                    wp.setJoined(true);
-+                participated.remove(participated.get(0));
-+            }
-+        participated = null;
-+        original.clear();
-+        original = null;
-+    }
-+
-+    public void initialize() {
-+        participated = new ArrayList<>();
-+        original = new HashMap<>();
-+
-+        if (getJoined() < 2) {
-+            Bukkit.broadcastMessage("There needs to be 2 or more participating players!");
-+            logEvent("Match cancelled as there was not enough players");
-+            onEnd();
-+            return;
-+        }
-+
-+        autoAssign();
-+
-+        for (MiraPlayer check : main.getWarPlayers().values())
-+            if (check.is_member_of_team())
-+                participated.add(check.crafter().getUniqueId());
-+
-+        for (WarTeam team : getTeams())
-+            original.put(team.getTeamName(), team.getBukkitTeam().getEntries().size());
-+
-+        permaDeath = true;
-+
-+        Objective obj = s().registerNewObjective("gm", "dummy");
-+        obj.setDisplaySlot(DisplaySlot.SIDEBAR);
-+        updateScoreboard();
-+
-+        for (Player online : Bukkit.getOnlinePlayers())
-+            online.setScoreboard(s());
-+    }
-+
-+    public void tick() {
-+    }
-+
-+    public void onKill(MiraPlayer killed, MiraPlayer killer) {
-+        dead(killed);
-+    }
-+
-+    public void onDeath(MiraPlayer dead) {
-+        dead(dead);
-+    }
-+
-+    /**
-+     * common code is shared by onKill and onDeath,
-+     * both call to this procedure to prevent duplication.
-+     *
-+     * @param dead the player who died.
-+     */
-+    private void dead(MiraPlayer dead) {
-+        dead.setJoined(false);
-+        entryHandle(dead);
-+    }
-+
-+    public void decideWinner() {
-+        int highest = 0;
-+        ArrayList<WarTeam> winners = new ArrayList<>();
-+
-+        for (WarTeam team : getTeams()) {
-+            int count = team.getBukkitTeam().getSize();
-+            if (count == highest)
-+                winners.add(team);
-+            else if (count > highest) {
-+                highest = count;
-+                winners.clear();
-+                winners.add(team);
-+            }
-+        }
-+        broadcastWinner(winners, "members remaining", highest);
-+    }
-+
-+    public String getOffensive() {
-+        return "Kill other players!";
-+    }
-+
-+    public String getDefensive() {
-+        return "Don't get yourself killed!";
-+    }
-+
-+    public String getFullName() {
-+        return "Last Team Standing";
-+    }
-+
-+    public String getName() {
-+        return "LTS";
-+    }
-+
-+    public String getGrammar() {
-+        return "an";
-+    }
-+
-+    public void onLeave(MiraPlayer left) {
-+        updateScoreboard();
-+        checkWin();
-+    }
-+
-+    public void updateScoreboard() {
-+        Objective obj = s().getObjective(DisplaySlot.SIDEBAR);
-+
-+        String dp = map().getMapName() + " (" + getName() + ")";
-+        if (dp.length() > 32) dp = dp.substring(0, 32);
-+        obj.setDisplayName(dp);
-+        obj.setDisplaySlot(DisplaySlot.SIDEBAR);
-+
-+        obj.getScore(" ").setScore(getTeams().size() + 2);
-+        obj.getScore("  Players Remaining").setScore(getTeams().size() + 1);
-+
-+        Iterator<WarTeam> iterator = getTeams().iterator();
-+        for (int i = 0; i < getTeams().size(); i++) {
-+            WarTeam target = iterator.next();
-+            obj.getScore(target.getTeamColor() + "    " + target.getBukkitTeam().getEntries().size()).setScore(i + 1);
-+            s().resetScores(target.getTeamColor() + "    " + (target.getBukkitTeam().getEntries().size() + 1));
-+        }
-+        obj.getScore("  ").setScore(0);
-+    }
-+
-+    /**
-+     * check if there is 1 or less teams with 1
-+     * or more players remaining. if that is the
-+     * case, end the round.
-+     */
-+    private void checkWin() {
-+        if (!active) return;
-+        int remainingTeams = 0;
-+        for (WarTeam team : getTeams())
-+            if (team.getBukkitTeam().getEntries().size() >= 1) remainingTeams++;
-+
-+        if (remainingTeams <= 1)
-+            onEnd();
-+
-+    }
-+
-+    /**
-+     * sneaking is a strategy often used to hide
-+     * on maps, so sneaking will not allow you to
-+     * hide your name tag behind walls.
-+     *
-+     * @param event an event called by Spigot.
-+     */
-+    @EventHandler
-+    public void onSneak(PlayerToggleSneakEvent event) {
-+        event.setCancelled(true);
-+    }
-+
-+    @Override
-+    public HashMap<String, Object> getExtraTeamData(WarTeam team) {
-+        HashMap<String, Object> extra = new HashMap<>();
-+        extra.put("Participants", original.get(team.getTeamName()));
-+        return extra;
-+    }
-+}
-diff --git a/src/sbs/mira/pvp/game/modes/TDM.java b/src/sbs/mira/pvp/game/modes/TDM.java
-new file mode 100644
-index 0000000..66ffec2
---- /dev/null
-+++ b/src/sbs/mira/pvp/game/modes/TDM.java
-@@ -0,0 +1,130 @@
-+package sbs.mira.pvp.game.modes;
-+
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.game.Gamemode;
-+import org.bukkit.Bukkit;
-+import org.bukkit.entity.Player;
-+import org.bukkit.scoreboard.DisplaySlot;
-+import org.bukkit.scoreboard.Objective;
-+
-+import java.util.ArrayList;
-+import java.util.HashMap;
-+import java.util.Iterator;
-+
-+/**
-+ * an extension to gamemode to implement tdm.
-+ * created on 2017-04-21.
-+ *
-+ * @author jj.mira.sbs
-+ * @author jd.mira.sbs
-+ * @version 1.0.1
-+ * @see MiraPulse
-+ * @since 1.0.0
-+ */
-+public class TDM extends Gamemode {
-+
-+    private final HashMap<String, Integer> kills = new HashMap<>();
-+
-+    public void reset() {
-+        kills.clear();
-+    }
-+
-+    public void initialize() {
-+        for (WarTeam team : getTeams())
-+            kills.put(team.getTeamName(), 0);
-+
-+        autoAssign();
-+
-+        Objective obj = s().registerNewObjective("gm", "dummy");
-+        obj.setDisplaySlot(DisplaySlot.SIDEBAR);
-+        updateScoreboard();
-+
-+        for (Player online : Bukkit.getOnlinePlayers())
-+            online.setScoreboard(s());
-+    }
-+
-+    public void tick() {
-+    }
-+
-+    public void onKill(MiraPlayer killed, MiraPlayer killer) {
-+        kills.put(killer.getCurrentTeam().getTeamName(), kills.get(killer.getCurrentTeam().getTeamName()) + 1);
-+        updateScoreboard();
-+    }
-+
-+    public void onDeath(MiraPlayer killed) {
-+        for (WarTeam awarded : getTeams()) {
-+            if (!awarded.getTeamName().equals(killed.getCurrentTeam().getTeamName()))
-+                kills.put(awarded.getTeamName(), kills.get(awarded.getTeamName()) + 1);
-+        }
-+        updateScoreboard();
-+    }
-+
-+    public void decideWinner() {
-+        int highest = -1;
-+        ArrayList<WarTeam> winners = new ArrayList<>();
-+
-+        for (WarTeam team : getTeams()) {
-+            int count = kills.get(team.getTeamName());
-+            if (count == highest)
-+                winners.add(team);
-+            else if (count > highest) {
-+                highest = count;
-+                winners.clear();
-+                winners.add(team);
-+            }
-+        }
-+        broadcastWinner(winners, "points", highest);
-+    }
-+
-+    public String getOffensive() {
-+        return "Kill players to score points!";
-+    }
-+
-+    public String getDefensive() {
-+        return "Don't let the enemy kill you! They will get points!";
-+    }
-+
-+    public String getName() {
-+        return "TDM";
-+    }
-+
-+    public String getFullName() {
-+        return "Team Death Match";
-+    }
-+
-+    public String getGrammar() {
-+        return "a";
-+    }
-+
-+    public void onLeave(MiraPlayer left) {
-+    }
-+
-+    public void updateScoreboard() {
-+        Objective obj = s().getObjective(DisplaySlot.SIDEBAR);
-+
-+        String dp = map().getMapName() + " (" + getName() + ")";
-+        if (dp.length() > 32) dp = dp.substring(0, 32);
-+        obj.setDisplayName(dp);
-+        obj.setDisplaySlot(DisplaySlot.SIDEBAR);
-+
-+        obj.getScore(" ").setScore(kills.size() + 2);
-+        obj.getScore("  Points").setScore(kills.size() + 1);
-+
-+        Iterator<WarTeam> iterator = getTeams().iterator();
-+        for (int i = 0; i < kills.size(); i++) {
-+            WarTeam target = iterator.next();
-+            obj.getScore(target.getTeamColor() + "    " + kills.get(target.getTeamName())).setScore(i + 1);
-+            s().resetScores(target.getTeamColor() + "    " + (kills.get(target.getTeamName()) - 1));
-+        }
-+        obj.getScore("  ").setScore(0);
-+    }
-+
-+    @Override
-+    public HashMap<String, Object> getExtraTeamData(WarTeam team) {
-+        HashMap<String, Object> extra = new HashMap<>();
-+        extra.put("Points", kills.get(team.getTeamName()));
-+        return extra;
-+    }
-+}
-diff --git a/src/au/edu/swin/war/game/util/AntiTeamGrief.java b/src/sbs/mira/pvp/game/util/AntiTeamGrief.java
-similarity index 77%
-rename from src/au/edu/swin/war/game/util/AntiTeamGrief.java
-rename to src/sbs/mira/pvp/game/util/AntiTeamGrief.java
-index 6f55105..3495f2b 100644
---- a/src/au/edu/swin/war/game/util/AntiTeamGrief.java
-+++ b/src/sbs/mira/pvp/game/util/AntiTeamGrief.java
-@@ -1,8 +1,8 @@
--package au.edu.swin.war.game.util;
-+package sbs.mira.pvp.game.util;
- 
--import au.edu.swin.war.framework.stored.Activatable;
--import au.edu.swin.war.framework.util.WarManager;
--import au.edu.swin.war.framework.util.WarModule;
-+import sbs.mira.pvp.framework.stored.Activatable;
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.framework.MiraModule;
- import org.bukkit.ChatColor;
- import org.bukkit.Location;
- import org.bukkit.Material;
-@@ -20,7 +20,7 @@ import org.bukkit.event.block.BlockPlaceEvent;
-  * @version 1.1
-  * @since 1.1
-  */
--public class AntiTeamGrief extends WarModule implements Activatable, Listener {
-+public class AntiTeamGrief extends MiraModule implements Activatable, Listener {
- 
-     private final int x1;
-     private final int z2;
-@@ -39,7 +39,7 @@ public class AntiTeamGrief extends WarModule implements Activatable, Listener {
-      * @param z2       Top right Z.
-      * @param penalize Penalize whoever tries to team-grief.
-      */
--    public AntiTeamGrief(WarManager main, ChatColor teamColor, int x1, int z1, int x2, int z2, boolean penalize) {
-+    public AntiTeamGrief(MiraPulse main, ChatColor teamColor, int x1, int z1, int x2, int z2, boolean penalize) {
-         super(main);
-         this.teamColor = teamColor;
-         this.x1 = Math.min(x1, x2);
-@@ -61,7 +61,7 @@ public class AntiTeamGrief extends WarModule implements Activatable, Listener {
- 
-     @Override
-     public void activate() {
--        main().plugin().getServer().getPluginManager().registerEvents(this, main().plugin());
-+        mira().plugin().getServer().getPluginManager().registerEvents(this, mira().plugin());
-     }
- 
-     @Override
-@@ -73,8 +73,8 @@ public class AntiTeamGrief extends WarModule implements Activatable, Listener {
-     public void onPlace(BlockPlaceEvent event) {
-         if (event.getBlock().getType() == Material.TNT)
-             if (isInside(event.getBlock().getLocation()))
--                if (main().getWarPlayer(event.getPlayer().getUniqueId()).getCurrentTeam().getTeamColor().equals(teamColor)) {
--                    main().warn(event.getPlayer(), "Place TNT inside the enemy area!");
-+                if (mira().getWarPlayer(event.getPlayer().getUniqueId()).getCurrentTeam().getTeamColor().equals(teamColor)) {
-+                    mira().warn(event.getPlayer(), "Place TNT inside the enemy area!");
-                     event.setCancelled(true);
-                     if (penalize)
-                         event.getPlayer().damage(event.getPlayer().getHealth() <= 5 ? event.getPlayer().getHealth() - 1 : 5);
-diff --git a/src/au/edu/swin/war/game/util/RadialSpawnPoint.java b/src/sbs/mira/pvp/game/util/RadialSpawnPoint.java
-similarity index 96%
-rename from src/au/edu/swin/war/game/util/RadialSpawnPoint.java
-rename to src/sbs/mira/pvp/game/util/RadialSpawnPoint.java
-index 73039e5..553fd8a 100644
---- a/src/au/edu/swin/war/game/util/RadialSpawnPoint.java
-+++ b/src/sbs/mira/pvp/game/util/RadialSpawnPoint.java
-@@ -1,6 +1,6 @@
--package au.edu.swin.war.game.util;
-+package sbs.mira.pvp.game.util;
- 
--import au.edu.swin.war.framework.stored.SerializedLocation;
-+import sbs.mira.pvp.framework.stored.SerializedLocation;
- import org.bukkit.Location;
- import org.bukkit.World;
- 
-diff --git a/src/au/edu/swin/war/game/util/SpawnArea.java b/src/sbs/mira/pvp/game/util/SpawnArea.java
-similarity index 77%
-rename from src/au/edu/swin/war/game/util/SpawnArea.java
-rename to src/sbs/mira/pvp/game/util/SpawnArea.java
-index 97e03e4..da38cda 100644
---- a/src/au/edu/swin/war/game/util/SpawnArea.java
-+++ b/src/sbs/mira/pvp/game/util/SpawnArea.java
-@@ -1,11 +1,11 @@
--package au.edu.swin.war.game.util;
--
--import au.edu.swin.war.event.PostMatchPlayerRespawnEvent;
--import au.edu.swin.war.framework.event.MatchPlayerJoinEvent;
--import au.edu.swin.war.framework.event.MatchPlayerLeaveEvent;
--import au.edu.swin.war.framework.stored.Activatable;
--import au.edu.swin.war.framework.util.WarManager;
--import au.edu.swin.war.framework.util.WarModule;
-+package sbs.mira.pvp.game.util;
-+
-+import sbs.mira.pvp.event.PostMatchPlayerRespawnEvent;
-+import sbs.mira.pvp.framework.event.MatchPlayerJoinEvent;
-+import sbs.mira.pvp.framework.event.MatchPlayerLeaveEvent;
-+import sbs.mira.pvp.framework.stored.Activatable;
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.framework.MiraModule;
- import org.bukkit.GameMode;
- import org.bukkit.Location;
- import org.bukkit.block.Block;
-@@ -39,7 +39,7 @@ import java.util.UUID;
-  * @version 1.1
-  * @since 1.1
-  */
--public class SpawnArea extends WarModule implements Activatable, Listener {
-+public class SpawnArea extends MiraModule implements Activatable, Listener {
- 
-     private final int x1;
-     private final int z2;
-@@ -61,7 +61,7 @@ public class SpawnArea extends WarModule implements Activatable, Listener {
-      * @param allowArrowsWhilstProtected Allows protected players to shoot arrows.
-      * @param allowReEntry               Allows players to (re)enter this area.
-      */
--    public SpawnArea(WarManager main, int x1, int z1, int x2, int z2, boolean allowArrowsWhilstProtected, boolean allowReEntry) {
-+    public SpawnArea(MiraPulse main, int x1, int z1, int x2, int z2, boolean allowArrowsWhilstProtected, boolean allowReEntry) {
-         super(main);
-         this.x1 = Math.min(x1, x2);
-         this.z1 = Math.min(z1, z2);
-@@ -85,7 +85,7 @@ public class SpawnArea extends WarModule implements Activatable, Listener {
- 
-     @Override
-     public void activate() {
--        main().plugin().getServer().getPluginManager().registerEvents(this, main().plugin());
-+        mira().plugin().getServer().getPluginManager().registerEvents(this, mira().plugin());
-     }
- 
-     @Override
-@@ -97,26 +97,26 @@ public class SpawnArea extends WarModule implements Activatable, Listener {
- 
-     @EventHandler
-     public void onCustomRespawn(PostMatchPlayerRespawnEvent event) {
--        if (isInside(event.getPlayer().getPlayer().getLocation())) {
--            invincible.add(event.getPlayer().getPlayer().getUniqueId());
--            if (!notified.contains(event.getPlayer().getPlayer().getUniqueId()))
--                event.getPlayer().sendMessage("TIP: You are now spawn protected.");
-+        if (isInside(event.getPlayer().crafter().getLocation())) {
-+            invincible.add(event.getPlayer().crafter().getUniqueId());
-+            if (!notified.contains(event.getPlayer().crafter().getUniqueId()))
-+                event.getPlayer().dm("TIP: You are now spawn protected.");
-         }
-     }
- 
-     @EventHandler
-     public void onJoin(MatchPlayerJoinEvent event) {
--        if (isInside(event.getPlayer().getPlayer().getLocation())) {
--            invincible.add(event.getPlayer().getPlayer().getUniqueId());
--            if (!notified.contains(event.getPlayer().getPlayer().getUniqueId()))
--                event.getPlayer().sendMessage("TIP: You are now spawn protected.");
-+        if (isInside(event.getPlayer().crafter().getLocation())) {
-+            invincible.add(event.getPlayer().crafter().getUniqueId());
-+            if (!notified.contains(event.getPlayer().crafter().getUniqueId()))
-+                event.getPlayer().dm("TIP: You are now spawn protected.");
-         }
-     }
- 
-     @EventHandler
-     public void onLeave(MatchPlayerLeaveEvent event) {
--        if (invincible.contains(event.getPlayer().getPlayer().getUniqueId()))
--            invincible.remove(event.getPlayer().getPlayer().getUniqueId());
-+        if (invincible.contains(event.getPlayer().crafter().getUniqueId()))
-+            invincible.remove(event.getPlayer().crafter().getUniqueId());
-     }
- 
-     @EventHandler
-@@ -132,7 +132,7 @@ public class SpawnArea extends WarModule implements Activatable, Listener {
-         } else if (!reEntry && event.getPlayer().getGameMode() == GameMode.SURVIVAL) {
-             if (isInside(event.getFrom())) return;
-             event.setCancelled(true);
--            main().warn(event.getPlayer(), "You cannot enter here.");
-+            mira().warn(event.getPlayer(), "You cannot enter here.");
-         }
-     }
- 
-diff --git a/src/au/edu/swin/war/maps/BattleRoyale.java b/src/sbs/mira/pvp/maps/BattleRoyale.java
-similarity index 86%
-rename from src/au/edu/swin/war/maps/BattleRoyale.java
-rename to src/sbs/mira/pvp/maps/BattleRoyale.java
-index c707757..30ab1de 100644
---- a/src/au/edu/swin/war/maps/BattleRoyale.java
-+++ b/src/sbs/mira/pvp/maps/BattleRoyale.java
-@@ -1,12 +1,12 @@
--package au.edu.swin.war.maps;
--
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.stored.SerializedLocation;
--import au.edu.swin.war.game.Gamemode;
--import au.edu.swin.war.game.Map;
--import au.edu.swin.war.game.util.RadialSpawnPoint;
--import au.edu.swin.war.game.util.SpawnArea;
-+package sbs.mira.pvp.maps;
-+
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.stored.SerializedLocation;
-+import sbs.mira.pvp.game.Gamemode;
-+import sbs.mira.pvp.game.Map;
-+import sbs.mira.pvp.game.util.RadialSpawnPoint;
-+import sbs.mira.pvp.game.util.SpawnArea;
- import net.minecraft.server.v1_12_R1.EntityLiving;
- import net.minecraft.server.v1_12_R1.EntityTNTPrimed;
- import org.bukkit.ChatColor;
-@@ -69,17 +69,17 @@ public class BattleRoyale extends Map {
-     }
- 
-     @Override
--    public void applyInventory(WarPlayer target) {
-+    public void applyInventory(MiraPlayer target) {
-     }
- 
-     private interface Apply {
--        void apply(WarPlayer pl);
-+        void apply(MiraPlayer pl);
-     }
- 
-     private enum Class {
-         Hero(
-                 pl -> {
--                    PlayerInventory inv = pl.getPlayer().getInventory();
-+                    PlayerInventory inv = pl.crafter().getInventory();
-                     inv.setItem(0, new ItemStack(Material.IRON_SWORD));
-                     inv.setItem(1, new ItemStack(Material.COOKED_BEEF, 16));
-                 },
-@@ -87,39 +87,39 @@ public class BattleRoyale extends Map {
-         ),
-         Tank(
-                 pl -> {
--                    PlayerInventory inv = pl.getPlayer().getInventory();
-+                    PlayerInventory inv = pl.crafter().getInventory();
-                     inv.setItem(0, new ItemStack(Material.WOOD_SWORD));
-                     inv.setItem(1, new ItemStack(Material.COOKED_BEEF, 16));
-                     inv.setItem(8, new ItemStack(Material.SHIELD));
--                    pl.getPlayer().addPotionEffect(new PotionEffect(PotionEffectType.SLOW, 20 * 600, 0));
-+                    pl.crafter().addPotionEffect(new PotionEffect(PotionEffectType.SLOW, 20 * 600, 0));
-                 },
-                 new Material[]{Material.IRON_HELMET, Material.DIAMOND_CHESTPLATE, Material.LEATHER_LEGGINGS, Material.IRON_BOOTS}
-         ),
-         Scout(
-                 pl -> {
--                    PlayerInventory inv = pl.getPlayer().getInventory();
-+                    PlayerInventory inv = pl.crafter().getInventory();
-                     inv.setItem(0, new ItemStack(Material.STONE_SWORD));
-                     inv.setItem(1, new ItemStack(Material.COOKED_BEEF, 16));
-                     inv.setItem(2, new ItemStack(Material.GOLDEN_APPLE, 2));
--                    pl.getPlayer().addPotionEffect(new PotionEffect(PotionEffectType.SPEED, 20 * 600, 1));
--                    pl.getPlayer().addPotionEffect(new PotionEffect(PotionEffectType.JUMP, 20 * 600, 1));
-+                    pl.crafter().addPotionEffect(new PotionEffect(PotionEffectType.SPEED, 20 * 600, 1));
-+                    pl.crafter().addPotionEffect(new PotionEffect(PotionEffectType.JUMP, 20 * 600, 1));
-                 },
-                 new Material[]{Material.LEATHER_CHESTPLATE, Material.CHAINMAIL_LEGGINGS}
-         ),
-         Assassin(
-                 pl -> {
--                    PlayerInventory inv = pl.getPlayer().getInventory();
-+                    PlayerInventory inv = pl.crafter().getInventory();
-                     ItemStack SWORD = new ItemStack(Material.IRON_SWORD);
-                     SWORD.addEnchantment(Enchantment.DAMAGE_ALL, 4);
-                     inv.setItem(0, SWORD);
-                     inv.setItem(1, new ItemStack(Material.COOKED_BEEF, 16));
--                    pl.getPlayer().addPotionEffect(new PotionEffect(PotionEffectType.INVISIBILITY, 20 * 600, 0));
-+                    pl.crafter().addPotionEffect(new PotionEffect(PotionEffectType.INVISIBILITY, 20 * 600, 0));
-                 },
-                 new Material[0]
-         ),
-         Medic(
-                 pl -> {
--                    PlayerInventory inv = pl.getPlayer().getInventory();
-+                    PlayerInventory inv = pl.crafter().getInventory();
-                     inv.setItem(0, new ItemStack(Material.GOLD_SWORD));
-                     inv.setItem(1, new ItemStack(Material.COOKED_BEEF, 16));
- 
-@@ -145,7 +145,7 @@ public class BattleRoyale extends Map {
-         ),
-         Sniper(
-                 pl -> {
--                    PlayerInventory inv = pl.getPlayer().getInventory();
-+                    PlayerInventory inv = pl.crafter().getInventory();
-                     inv.setItem(0, new ItemStack(Material.STONE_AXE));
- 
-                     ItemStack BOW = new ItemStack(Material.BOW);
-@@ -159,7 +159,7 @@ public class BattleRoyale extends Map {
-         ),
-         Demolition(
-                 pl -> {
--                    PlayerInventory inv = pl.getPlayer().getInventory();
-+                    PlayerInventory inv = pl.crafter().getInventory();
-                     inv.setItem(0, new ItemStack(Material.IRON_AXE));
-                     inv.setItem(1, new ItemStack(Material.COOKED_BEEF, 16));
-                     inv.setItem(2, new ItemStack(Material.TNT, 32));
-@@ -176,7 +176,7 @@ public class BattleRoyale extends Map {
-         }
-     }
- 
--    private void apply(WarPlayer pl, Class clazz) {
-+    private void apply(MiraPlayer pl, Class clazz) {
-         main.items().clear(pl);
-         main.items().applyArmorAcccordingToTeam(pl, clazz.armor);
-         clazz.apply.apply(pl);
-@@ -231,8 +231,8 @@ public class BattleRoyale extends Map {
-     @EventHandler
-     public void onClick(PlayerInteractEvent event) {
-         if (event.getClickedBlock() == null) return;
--        WarPlayer wp = main.getWarPlayer(event.getPlayer());
--        if (!wp.isPlaying()) return;
-+        MiraPlayer wp = main.getWarPlayer(event.getPlayer());
-+        if (!wp.is_member_of_team()) return;
-         Block block = event.getClickedBlock();
-         if (block.getType() == Material.SIGN_POST || block.getType() == Material.WALL_SIGN) {
-             Sign sign = (Sign) block.getState();
-diff --git a/src/au/edu/swin/war/maps/Battlement.java b/src/sbs/mira/pvp/maps/Battlement.java
-similarity index 87%
-rename from src/au/edu/swin/war/maps/Battlement.java
-rename to src/sbs/mira/pvp/maps/Battlement.java
-index 5e7701b..24c9ae1 100644
---- a/src/au/edu/swin/war/maps/Battlement.java
-+++ b/src/sbs/mira/pvp/maps/Battlement.java
-@@ -1,11 +1,11 @@
--package au.edu.swin.war.maps;
-+package sbs.mira.pvp.maps;
- 
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.stored.SerializedLocation;
--import au.edu.swin.war.game.Gamemode;
--import au.edu.swin.war.game.Map;
--import au.edu.swin.war.game.util.RadialSpawnPoint;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.stored.SerializedLocation;
-+import sbs.mira.pvp.game.Gamemode;
-+import sbs.mira.pvp.game.Map;
-+import sbs.mira.pvp.game.util.RadialSpawnPoint;
- import org.bukkit.ChatColor;
- import org.bukkit.Material;
- import org.bukkit.inventory.ItemStack;
-@@ -67,8 +67,8 @@ public class Battlement extends Map {
-     }
- 
-     @Override
--    public void applyInventory(WarPlayer target) {
--        PlayerInventory inv = target.getPlayer().getInventory();
-+    public void applyInventory(MiraPlayer target) {
-+        PlayerInventory inv = target.crafter().getInventory();
- 
-         main.items().applyArmorAcccordingToTeam(target, new Material[]{Material.IRON_HELMET, Material.LEATHER_CHESTPLATE, Material.IRON_LEGGINGS, Material.IRON_BOOTS});
- 
-@@ -79,6 +79,6 @@ public class Battlement extends Map {
-         inv.setItem(4, new ItemStack(Material.EXP_BOTTLE, 2));
-         inv.setItem(27, new ItemStack(Material.ARROW, 28));
- 
--        target.getPlayer().addPotionEffect(new PotionEffect(PotionEffectType.DAMAGE_RESISTANCE, 40, 4));
-+        target.crafter().addPotionEffect(new PotionEffect(PotionEffectType.DAMAGE_RESISTANCE, 40, 4));
-     }
- }
-diff --git a/src/au/edu/swin/war/maps/ClashOfClay.java b/src/sbs/mira/pvp/maps/ClashOfClay.java
-similarity index 84%
-rename from src/au/edu/swin/war/maps/ClashOfClay.java
-rename to src/sbs/mira/pvp/maps/ClashOfClay.java
-index 6c434b5..74b209b 100644
---- a/src/au/edu/swin/war/maps/ClashOfClay.java
-+++ b/src/sbs/mira/pvp/maps/ClashOfClay.java
-@@ -1,11 +1,11 @@
--package au.edu.swin.war.maps;
-+package sbs.mira.pvp.maps;
- 
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.stored.SerializedLocation;
--import au.edu.swin.war.game.Gamemode;
--import au.edu.swin.war.game.Map;
--import au.edu.swin.war.game.util.SpawnArea;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.stored.SerializedLocation;
-+import sbs.mira.pvp.game.Gamemode;
-+import sbs.mira.pvp.game.Map;
-+import sbs.mira.pvp.game.util.SpawnArea;
- import org.bukkit.ChatColor;
- import org.bukkit.Material;
- import org.bukkit.inventory.ItemStack;
-@@ -44,8 +44,8 @@ public class ClashOfClay extends Map {
-     }
- 
-     @Override
--    public void applyInventory(WarPlayer target) {
--        PlayerInventory inv = target.getPlayer().getInventory();
-+    public void applyInventory(MiraPlayer target) {
-+        PlayerInventory inv = target.crafter().getInventory();
- 
-         main.items().applyArmorAcccordingToTeam(target, new Material[]{Material.DIAMOND_HELMET, Material.LEATHER_CHESTPLATE});
- 
-diff --git a/src/au/edu/swin/war/maps/ConvenienceWars.java b/src/sbs/mira/pvp/maps/ConvenienceWars.java
-similarity index 90%
-rename from src/au/edu/swin/war/maps/ConvenienceWars.java
-rename to src/sbs/mira/pvp/maps/ConvenienceWars.java
-index 8156251..3b81a84 100644
---- a/src/au/edu/swin/war/maps/ConvenienceWars.java
-+++ b/src/sbs/mira/pvp/maps/ConvenienceWars.java
-@@ -1,11 +1,11 @@
--package au.edu.swin.war.maps;
-+package sbs.mira.pvp.maps;
- 
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.stored.SerializedLocation;
--import au.edu.swin.war.game.Gamemode;
--import au.edu.swin.war.game.Map;
--import au.edu.swin.war.game.modes.DDM;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.stored.SerializedLocation;
-+import sbs.mira.pvp.game.Gamemode;
-+import sbs.mira.pvp.game.Map;
-+import sbs.mira.pvp.game.modes.DDM;
- import org.bukkit.ChatColor;
- import org.bukkit.Material;
- import org.bukkit.entity.Player;
-@@ -66,8 +66,8 @@ public class ConvenienceWars extends Map {
-     }
- 
-     @Override
--    public void applyInventory(WarPlayer target) {
--        PlayerInventory inv = target.getPlayer().getInventory();
-+    public void applyInventory(MiraPlayer target) {
-+        PlayerInventory inv = target.crafter().getInventory();
- 
-         main.items().applyArmorAcccordingToTeam(target, new Material[]{Material.LEATHER_HELMET, Material.IRON_CHESTPLATE, Material.LEATHER_LEGGINGS, Material.CHAINMAIL_BOOTS});
- 
-diff --git a/src/au/edu/swin/war/maps/ExoticPastures.java b/src/sbs/mira/pvp/maps/ExoticPastures.java
-similarity index 90%
-rename from src/au/edu/swin/war/maps/ExoticPastures.java
-rename to src/sbs/mira/pvp/maps/ExoticPastures.java
-index cb58d8f..d2a0423 100644
---- a/src/au/edu/swin/war/maps/ExoticPastures.java
-+++ b/src/sbs/mira/pvp/maps/ExoticPastures.java
-@@ -1,12 +1,12 @@
--package au.edu.swin.war.maps;
--
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.stored.SerializedLocation;
--import au.edu.swin.war.game.Gamemode;
--import au.edu.swin.war.game.Map;
--import au.edu.swin.war.game.modes.DTM;
--import au.edu.swin.war.game.util.SpawnArea;
-+package sbs.mira.pvp.maps;
-+
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.stored.SerializedLocation;
-+import sbs.mira.pvp.game.Gamemode;
-+import sbs.mira.pvp.game.Map;
-+import sbs.mira.pvp.game.modes.DTM;
-+import sbs.mira.pvp.game.util.SpawnArea;
- import org.bukkit.ChatColor;
- import org.bukkit.Effect;
- import org.bukkit.Material;
-@@ -58,8 +58,8 @@ public class ExoticPastures extends Map {
-     }
- 
-     @Override
--    public void applyInventory(WarPlayer target) {
--        PlayerInventory inv = target.getPlayer().getInventory();
-+    public void applyInventory(MiraPlayer target) {
-+        PlayerInventory inv = target.crafter().getInventory();
- 
-         main.items().applyArmorAcccordingToTeam(target, new Material[]{Material.LEATHER_HELMET, Material.GOLD_CHESTPLATE, Material.LEATHER_LEGGINGS, Material.IRON_BOOTS});
- 
-diff --git a/src/au/edu/swin/war/maps/FairwickVillage.java b/src/sbs/mira/pvp/maps/FairwickVillage.java
-similarity index 88%
-rename from src/au/edu/swin/war/maps/FairwickVillage.java
-rename to src/sbs/mira/pvp/maps/FairwickVillage.java
-index 3395484..51e17b7 100644
---- a/src/au/edu/swin/war/maps/FairwickVillage.java
-+++ b/src/sbs/mira/pvp/maps/FairwickVillage.java
-@@ -1,11 +1,10 @@
--package au.edu.swin.war.maps;
-+package sbs.mira.pvp.maps;
- 
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.stored.SerializedLocation;
--import au.edu.swin.war.game.Gamemode;
--import au.edu.swin.war.game.Map;
--import org.bukkit.Bukkit;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.stored.SerializedLocation;
-+import sbs.mira.pvp.game.Gamemode;
-+import sbs.mira.pvp.game.Map;
- import org.bukkit.ChatColor;
- import org.bukkit.Material;
- import org.bukkit.entity.Player;
-@@ -54,8 +53,8 @@ public class FairwickVillage extends Map {
-     }
- 
-     @Override
--    public void applyInventory(WarPlayer target) {
--        PlayerInventory inv = target.getPlayer().getInventory();
-+    public void applyInventory(MiraPlayer target) {
-+        PlayerInventory inv = target.crafter().getInventory();
- 
-         main.items().applyArmorAcccordingToTeam(target, new Material[]{Material.IRON_HELMET, Material.LEATHER_CHESTPLATE, Material.IRON_LEGGINGS, Material.IRON_BOOTS});
- 
-diff --git a/src/au/edu/swin/war/maps/GibsonDesertWars.java b/src/sbs/mira/pvp/maps/GibsonDesertWars.java
-similarity index 87%
-rename from src/au/edu/swin/war/maps/GibsonDesertWars.java
-rename to src/sbs/mira/pvp/maps/GibsonDesertWars.java
-index d3a898c..9742e55 100644
---- a/src/au/edu/swin/war/maps/GibsonDesertWars.java
-+++ b/src/sbs/mira/pvp/maps/GibsonDesertWars.java
-@@ -1,11 +1,11 @@
--package au.edu.swin.war.maps;
-+package sbs.mira.pvp.maps;
- 
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.stored.SerializedLocation;
--import au.edu.swin.war.game.Gamemode;
--import au.edu.swin.war.game.Map;
--import au.edu.swin.war.game.modes.DTM;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.stored.SerializedLocation;
-+import sbs.mira.pvp.game.Gamemode;
-+import sbs.mira.pvp.game.Map;
-+import sbs.mira.pvp.game.modes.DTM;
- import org.bukkit.ChatColor;
- import org.bukkit.Material;
- import org.bukkit.inventory.ItemStack;
-@@ -48,8 +48,8 @@ public class GibsonDesertWars extends Map {
-     }
- 
-     @Override
--    public void applyInventory(WarPlayer target) {
--        PlayerInventory inv = target.getPlayer().getInventory();
-+    public void applyInventory(MiraPlayer target) {
-+        PlayerInventory inv = target.crafter().getInventory();
- 
-         main.items().applyArmorAcccordingToTeam(target, new Material[]{Material.LEATHER_HELMET, Material.DIAMOND_CHESTPLATE, Material.GOLD_BOOTS});
- 
-diff --git a/src/au/edu/swin/war/maps/MaplebankWoods.java b/src/sbs/mira/pvp/maps/MaplebankWoods.java
-similarity index 84%
-rename from src/au/edu/swin/war/maps/MaplebankWoods.java
-rename to src/sbs/mira/pvp/maps/MaplebankWoods.java
-index f99b248..af23c78 100644
---- a/src/au/edu/swin/war/maps/MaplebankWoods.java
-+++ b/src/sbs/mira/pvp/maps/MaplebankWoods.java
-@@ -1,12 +1,12 @@
--package au.edu.swin.war.maps;
-+package sbs.mira.pvp.maps;
- 
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.stored.SerializedLocation;
--import au.edu.swin.war.game.Gamemode;
--import au.edu.swin.war.game.Map;
--import au.edu.swin.war.game.modes.DTM;
--import au.edu.swin.war.game.util.SpawnArea;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.stored.SerializedLocation;
-+import sbs.mira.pvp.game.Gamemode;
-+import sbs.mira.pvp.game.Map;
-+import sbs.mira.pvp.game.modes.DTM;
-+import sbs.mira.pvp.game.util.SpawnArea;
- import org.bukkit.ChatColor;
- import org.bukkit.Material;
- import org.bukkit.inventory.ItemStack;
-@@ -48,8 +48,8 @@ public class MaplebankWoods extends Map {
-     }
- 
-     @Override
--    public void applyInventory(WarPlayer target) {
--        PlayerInventory inv = target.getPlayer().getInventory();
-+    public void applyInventory(MiraPlayer target) {
-+        PlayerInventory inv = target.crafter().getInventory();
- 
-         main.items().applyArmorAcccordingToTeam(target, new Material[]{Material.LEATHER_HELMET, Material.IRON_CHESTPLATE, Material.DIAMOND_LEGGINGS, Material.IRON_BOOTS});
- 
-diff --git a/src/au/edu/swin/war/maps/Mutiny.java b/src/sbs/mira/pvp/maps/Mutiny.java
-similarity index 86%
-rename from src/au/edu/swin/war/maps/Mutiny.java
-rename to src/sbs/mira/pvp/maps/Mutiny.java
-index bfe928d..fb8e54a 100644
---- a/src/au/edu/swin/war/maps/Mutiny.java
-+++ b/src/sbs/mira/pvp/maps/Mutiny.java
-@@ -1,12 +1,12 @@
--package au.edu.swin.war.maps;
-+package sbs.mira.pvp.maps;
- 
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.stored.SerializedLocation;
--import au.edu.swin.war.game.Gamemode;
--import au.edu.swin.war.game.Map;
--import au.edu.swin.war.game.util.AntiTeamGrief;
--import au.edu.swin.war.game.util.SpawnArea;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.stored.SerializedLocation;
-+import sbs.mira.pvp.game.Gamemode;
-+import sbs.mira.pvp.game.Map;
-+import sbs.mira.pvp.game.util.AntiTeamGrief;
-+import sbs.mira.pvp.game.util.SpawnArea;
- import org.bukkit.ChatColor;
- import org.bukkit.Material;
- import org.bukkit.inventory.ItemStack;
-@@ -55,8 +55,8 @@ public class Mutiny extends Map {
-     }
- 
-     @Override
--    public void applyInventory(WarPlayer target) {
--        PlayerInventory inv = target.getPlayer().getInventory();
-+    public void applyInventory(MiraPlayer target) {
-+        PlayerInventory inv = target.crafter().getInventory();
- 
-         main.items().applyArmorAcccordingToTeam(target, new Material[]{Material.LEATHER_BOOTS, Material.LEATHER_LEGGINGS, Material.LEATHER_CHESTPLATE, Material.LEATHER_HELMET});
- 
-diff --git a/src/au/edu/swin/war/maps/Roseley.java b/src/sbs/mira/pvp/maps/Roseley.java
-similarity index 88%
-rename from src/au/edu/swin/war/maps/Roseley.java
-rename to src/sbs/mira/pvp/maps/Roseley.java
-index e9a91dc..0cb6d3d 100644
---- a/src/au/edu/swin/war/maps/Roseley.java
-+++ b/src/sbs/mira/pvp/maps/Roseley.java
-@@ -1,12 +1,12 @@
--package au.edu.swin.war.maps;
-+package sbs.mira.pvp.maps;
- 
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.stored.SerializedLocation;
--import au.edu.swin.war.game.Gamemode;
--import au.edu.swin.war.game.Map;
--import au.edu.swin.war.game.util.RadialSpawnPoint;
--import au.edu.swin.war.game.util.SpawnArea;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.stored.SerializedLocation;
-+import sbs.mira.pvp.game.Gamemode;
-+import sbs.mira.pvp.game.Map;
-+import sbs.mira.pvp.game.util.RadialSpawnPoint;
-+import sbs.mira.pvp.game.util.SpawnArea;
- import org.bukkit.ChatColor;
- import org.bukkit.Location;
- import org.bukkit.Material;
-@@ -56,8 +56,8 @@ public class Roseley extends Map {
-     }
- 
-     @Override
--    public void applyInventory(WarPlayer target) {
--        PlayerInventory inv = target.getPlayer().getInventory();
-+    public void applyInventory(MiraPlayer target) {
-+        PlayerInventory inv = target.crafter().getInventory();
- 
-         main.items().applyArmorAcccordingToTeam(target, new Material[]{Material.IRON_HELMET, Material.LEATHER_CHESTPLATE, Material.IRON_LEGGINGS, Material.IRON_BOOTS});
- 
-diff --git a/src/au/edu/swin/war/maps/SanguineShores.java b/src/sbs/mira/pvp/maps/SanguineShores.java
-similarity index 83%
-rename from src/au/edu/swin/war/maps/SanguineShores.java
-rename to src/sbs/mira/pvp/maps/SanguineShores.java
-index 6bb14d8..a6ce31a 100644
---- a/src/au/edu/swin/war/maps/SanguineShores.java
-+++ b/src/sbs/mira/pvp/maps/SanguineShores.java
-@@ -1,11 +1,11 @@
--package au.edu.swin.war.maps;
--
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.stored.SerializedLocation;
--import au.edu.swin.war.game.Gamemode;
--import au.edu.swin.war.game.Map;
--import au.edu.swin.war.game.util.SpawnArea;
-+package sbs.mira.pvp.maps;
-+
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.stored.SerializedLocation;
-+import sbs.mira.pvp.game.Gamemode;
-+import sbs.mira.pvp.game.Map;
-+import sbs.mira.pvp.game.util.SpawnArea;
- import org.bukkit.ChatColor;
- import org.bukkit.Material;
- import org.bukkit.inventory.ItemStack;
-@@ -45,8 +45,8 @@ public class SanguineShores extends Map {
-     }
- 
-     @Override
--    public void applyInventory(WarPlayer target) {
--        PlayerInventory inv = target.getPlayer().getInventory();
-+    public void applyInventory(MiraPlayer target) {
-+        PlayerInventory inv = target.crafter().getInventory();
- 
-         main.items().applyArmorAcccordingToTeam(target, new Material[]{Material.CHAINMAIL_HELMET, Material.LEATHER_CHESTPLATE, Material.IRON_LEGGINGS, Material.CHAINMAIL_BOOTS});
- 
-diff --git a/src/au/edu/swin/war/maps/SanguineShoresII.java b/src/sbs/mira/pvp/maps/SanguineShoresII.java
-similarity index 84%
-rename from src/au/edu/swin/war/maps/SanguineShoresII.java
-rename to src/sbs/mira/pvp/maps/SanguineShoresII.java
-index 294c2c2..778feb3 100644
---- a/src/au/edu/swin/war/maps/SanguineShoresII.java
-+++ b/src/sbs/mira/pvp/maps/SanguineShoresII.java
-@@ -1,12 +1,12 @@
--package au.edu.swin.war.maps;
-+package sbs.mira.pvp.maps;
- 
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.stored.SerializedLocation;
--import au.edu.swin.war.game.Gamemode;
--import au.edu.swin.war.game.Map;
--import au.edu.swin.war.game.util.RadialSpawnPoint;
--import au.edu.swin.war.game.util.SpawnArea;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.stored.SerializedLocation;
-+import sbs.mira.pvp.game.Gamemode;
-+import sbs.mira.pvp.game.Map;
-+import sbs.mira.pvp.game.util.RadialSpawnPoint;
-+import sbs.mira.pvp.game.util.SpawnArea;
- import org.bukkit.ChatColor;
- import org.bukkit.Material;
- import org.bukkit.inventory.ItemStack;
-@@ -48,8 +48,8 @@ public class SanguineShoresII extends Map {
-     }
- 
-     @Override
--    public void applyInventory(WarPlayer target) {
--        PlayerInventory inv = target.getPlayer().getInventory();
-+    public void applyInventory(MiraPlayer target) {
-+        PlayerInventory inv = target.crafter().getInventory();
- 
-         main.items().applyArmorAcccordingToTeam(target, new Material[]{Material.IRON_HELMET, Material.IRON_CHESTPLATE, Material.IRON_LEGGINGS, Material.IRON_BOOTS});
- 
-diff --git a/src/au/edu/swin/war/maps/Squared.java b/src/sbs/mira/pvp/maps/Squared.java
-similarity index 85%
-rename from src/au/edu/swin/war/maps/Squared.java
-rename to src/sbs/mira/pvp/maps/Squared.java
-index 380f2e0..d84e742 100644
---- a/src/au/edu/swin/war/maps/Squared.java
-+++ b/src/sbs/mira/pvp/maps/Squared.java
-@@ -1,12 +1,12 @@
--package au.edu.swin.war.maps;
-+package sbs.mira.pvp.maps;
- 
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.stored.SerializedLocation;
--import au.edu.swin.war.game.Gamemode;
--import au.edu.swin.war.game.Map;
--import au.edu.swin.war.game.modes.DTM;
--import au.edu.swin.war.game.util.SpawnArea;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.stored.SerializedLocation;
-+import sbs.mira.pvp.game.Gamemode;
-+import sbs.mira.pvp.game.Map;
-+import sbs.mira.pvp.game.modes.DTM;
-+import sbs.mira.pvp.game.util.SpawnArea;
- import org.bukkit.ChatColor;
- import org.bukkit.Material;
- import org.bukkit.inventory.ItemStack;
-@@ -50,8 +50,8 @@ public class Squared extends Map {
-     }
- 
-     @Override
--    public void applyInventory(WarPlayer target) {
--        PlayerInventory inv = target.getPlayer().getInventory();
-+    public void applyInventory(MiraPlayer target) {
-+        PlayerInventory inv = target.crafter().getInventory();
- 
-         main.items().applyArmorAcccordingToTeam(target, new Material[]{Material.CHAINMAIL_HELMET, Material.LEATHER_CHESTPLATE, Material.LEATHER_LEGGINGS, Material.LEATHER_BOOTS});
- 
-diff --git a/src/au/edu/swin/war/maps/TheRebellion.java b/src/sbs/mira/pvp/maps/TheRebellion.java
-similarity index 87%
-rename from src/au/edu/swin/war/maps/TheRebellion.java
-rename to src/sbs/mira/pvp/maps/TheRebellion.java
-index 59ead18..e9cdbe4 100644
---- a/src/au/edu/swin/war/maps/TheRebellion.java
-+++ b/src/sbs/mira/pvp/maps/TheRebellion.java
-@@ -1,12 +1,12 @@
--package au.edu.swin.war.maps;
-+package sbs.mira.pvp.maps;
- 
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.stored.SerializedLocation;
--import au.edu.swin.war.game.Gamemode;
--import au.edu.swin.war.game.Map;
--import au.edu.swin.war.game.modes.DTM;
--import au.edu.swin.war.game.util.SpawnArea;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.stored.SerializedLocation;
-+import sbs.mira.pvp.game.Gamemode;
-+import sbs.mira.pvp.game.Map;
-+import sbs.mira.pvp.game.modes.DTM;
-+import sbs.mira.pvp.game.util.SpawnArea;
- import org.bukkit.ChatColor;
- import org.bukkit.Material;
- import org.bukkit.inventory.ItemStack;
-@@ -53,8 +53,8 @@ public class TheRebellion extends Map {
-     }
- 
-     @Override
--    public void applyInventory(WarPlayer target) {
--        PlayerInventory inv = target.getPlayer().getInventory();
-+    public void applyInventory(MiraPlayer target) {
-+        PlayerInventory inv = target.crafter().getInventory();
- 
-         main.items().applyArmorAcccordingToTeam(target, new Material[]{Material.DIAMOND_HELMET, Material.LEATHER_CHESTPLATE, Material.LEATHER_LEGGINGS, Material.DIAMOND_BOOTS});
- 
-diff --git a/src/au/edu/swin/war/maps/Xenon.java b/src/sbs/mira/pvp/maps/Xenon.java
-similarity index 92%
-rename from src/au/edu/swin/war/maps/Xenon.java
-rename to src/sbs/mira/pvp/maps/Xenon.java
-index 57d6e91..0f52e2b 100644
---- a/src/au/edu/swin/war/maps/Xenon.java
-+++ b/src/sbs/mira/pvp/maps/Xenon.java
-@@ -1,10 +1,10 @@
--package au.edu.swin.war.maps;
-+package sbs.mira.pvp.maps;
- 
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.stored.SerializedLocation;
--import au.edu.swin.war.game.Gamemode;
--import au.edu.swin.war.game.Map;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.stored.SerializedLocation;
-+import sbs.mira.pvp.game.Gamemode;
-+import sbs.mira.pvp.game.Map;
- import org.bukkit.ChatColor;
- import org.bukkit.Location;
- import org.bukkit.Material;
-@@ -70,8 +70,8 @@ public class Xenon extends Map {
-     }
- 
-     @Override
--    public void applyInventory(WarPlayer target) {
--        PlayerInventory inv = target.getPlayer().getInventory();
-+    public void applyInventory(MiraPlayer target) {
-+        PlayerInventory inv = target.crafter().getInventory();
- 
-         main.items().applyArmorAcccordingToTeam(target, new Material[]{Material.LEATHER_BOOTS, Material.IRON_LEGGINGS, Material.LEATHER_CHESTPLATE, Material.IRON_HELMET});
- 
-diff --git a/src/au/edu/swin/war/stats/Database.java b/src/sbs/mira/pvp/stats/Database.java
-similarity index 96%
-rename from src/au/edu/swin/war/stats/Database.java
-rename to src/sbs/mira/pvp/stats/Database.java
-index 29f95eb..c609ce3 100644
---- a/src/au/edu/swin/war/stats/Database.java
-+++ b/src/sbs/mira/pvp/stats/Database.java
-@@ -1,6 +1,6 @@
--package au.edu.swin.war.stats;
-+package sbs.mira.pvp.stats;
- 
--import au.edu.swin.war.framework.WarPlugin;
-+import sbs.mira.pvp.framework.MiraPlugin;
- import org.bukkit.Bukkit;
- import org.bukkit.configuration.ConfigurationSection;
- 
-@@ -19,9 +19,9 @@ public class Database {
-     private final String pass;
-     private final String url;
-     private Connection connection;
--    private final WarPlugin plugin;
-+    private final MiraPlugin plugin;
- 
--    public Database(WarPlugin instance) {
-+    public Database(MiraPlugin instance) {
-         ConfigurationSection config = instance.getConfig().getConfigurationSection("database");
-         this.user = config.getString("username");
-         this.pass = config.getString("password");
-diff --git a/src/au/edu/swin/war/stats/Preparable.java b/src/sbs/mira/pvp/stats/Preparable.java
-similarity index 75%
-rename from src/au/edu/swin/war/stats/Preparable.java
-rename to src/sbs/mira/pvp/stats/Preparable.java
-index ade517e..5d201d3 100644
---- a/src/au/edu/swin/war/stats/Preparable.java
-+++ b/src/sbs/mira/pvp/stats/Preparable.java
-@@ -1,4 +1,4 @@
--package au.edu.swin.war.stats;
-+package sbs.mira.pvp.stats;
- 
- /**
-  * Runs a preparable thing.
-diff --git a/src/au/edu/swin/war/stats/WarStats.java b/src/sbs/mira/pvp/stats/WarStats.java
-similarity index 91%
-rename from src/au/edu/swin/war/stats/WarStats.java
-rename to src/sbs/mira/pvp/stats/WarStats.java
-index 5ace047..f3c7e09 100644
---- a/src/au/edu/swin/war/stats/WarStats.java
-+++ b/src/sbs/mira/pvp/stats/WarStats.java
-@@ -1,6 +1,7 @@
--package au.edu.swin.war.stats;
-+package sbs.mira.pvp.stats;
- 
--import au.edu.swin.war.util.Manager;
-+import sbs.mira.pvp.MiraPvpMaster;
-+import sbs.mira.pvp.framework.MiraPlayer;
- 
- import java.sql.PreparedStatement;
- import java.sql.SQLException;
-@@ -10,11 +11,11 @@ import java.util.UUID;
-  * An object designed to record, modify,
-  * and retrieve stats for a designated player.
-  *
-- * @see au.edu.swin.war.framework.WarPlayer
-+ * @see MiraPlayer
-  */
- public class WarStats {
- 
--    private final Manager main;
-+    private final MiraPvpMaster main;
-     private final UUID owner;
- 
-     private int kills, deaths, highestStreak, currentStreak, matchesPlayed, revives;
-@@ -29,7 +30,7 @@ public class WarStats {
-      * @param matchesWon    Current killstreak.
-      * @param revives       Amount of revives remaining.
-      */
--    public WarStats(Manager main, UUID owner, int kills, int deaths, int highestStreak, int matchesWon, int revives) {
-+    public WarStats(MiraPvpMaster main, UUID owner, int kills, int deaths, int highestStreak, int matchesWon, int revives) {
-         this.main = main;
-         this.owner = owner;
-         this.kills = kills;
-@@ -45,7 +46,7 @@ public class WarStats {
-      *
-      * @param owner Owner of this stats record.
-      */
--    public WarStats(Manager main, UUID owner) {
-+    public WarStats(MiraPvpMaster main, UUID owner) {
-         this.main = main;
-         this.owner = owner;
-         this.kills = 0;
-diff --git a/src/au/edu/swin/war/util/Cache.java b/src/sbs/mira/pvp/util/Cache.java
-similarity index 87%
-rename from src/au/edu/swin/war/util/Cache.java
-rename to src/sbs/mira/pvp/util/Cache.java
-index 717cf08..170531f 100644
---- a/src/au/edu/swin/war/util/Cache.java
-+++ b/src/sbs/mira/pvp/util/Cache.java
-@@ -1,11 +1,14 @@
--package au.edu.swin.war.util;
-+package sbs.mira.pvp.util;
- 
--import au.edu.swin.war.framework.util.WarCache;
--import au.edu.swin.war.framework.util.WarManager;
--import au.edu.swin.war.game.Gamemode;
--import au.edu.swin.war.game.Map;
-+import sbs.mira.pvp.MiraPvpMaster;
-+import sbs.mira.pvp.framework.util.WarCache;
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.game.Gamemode;
-+import sbs.mira.pvp.game.Map;
- import au.edu.swin.war.game.modes.*;
- import au.edu.swin.war.maps.*;
-+import sbs.mira.pvp.game.modes.*;
-+import sbs.mira.pvp.maps.*;
- 
- /**
-  * An extension to WarCache.
-@@ -13,7 +16,7 @@ import au.edu.swin.war.maps.*;
-  *
-  * @author s101601828 @ Swin.
-  * @version 1.0
-- * @see WarManager
-+ * @see MiraPulse
-  * <p>
-  * Created by Josh on 20/04/2017.
-  * @since 1.0
-@@ -27,7 +30,7 @@ public class Cache extends WarCache {
-      *
-      * @param main The supercontroller.
-      */
--    Cache(Manager main) {
-+    Cache(MiraPvpMaster main) {
-         super(main);
-     }
- 
-@@ -77,9 +80,9 @@ public class Cache extends WarCache {
-         try {
-             // Load this class as if it were a Map.
-             Map result = toLoad.newInstance(); // Initialise it.
--            result.init(main()); // Call init() before anything else!
-+            result.init(mira()); // Call init() before anything else!
-             maps.put(result.getMapName(), result); // Register it in the maps key/value set.
--            main().plugin().log("Map initialised and stored: " + result.getMapName()); // Log it?
-+            mira().plugin().log("Map initialised and stored: " + result.getMapName()); // Log it?
-         } catch (InstantiationException | IllegalAccessException e) {
-             e.printStackTrace();
-         }
-@@ -95,7 +98,7 @@ public class Cache extends WarCache {
-         try {
-             // Load this class as if it were a Gamemode.
-             Gamemode result = toLoad.newInstance(); // Initialise it.
--            result.init(main()); // Call init() before anything else!
-+            result.init(mira()); // Call init() before anything else!
-             gamemodes.put(result.getFullName(), result); // Register it in the key/value set.
-         } catch (InstantiationException | IllegalAccessException e) {
-             e.printStackTrace();
-diff --git a/src/au/edu/swin/war/util/Guard.java b/src/sbs/mira/pvp/util/Guard.java
-similarity index 82%
-rename from src/au/edu/swin/war/util/Guard.java
-rename to src/sbs/mira/pvp/util/Guard.java
-index d7cf472..6221221 100644
---- a/src/au/edu/swin/war/util/Guard.java
-+++ b/src/sbs/mira/pvp/util/Guard.java
-@@ -1,9 +1,10 @@
--package au.edu.swin.war.util;
-+package sbs.mira.pvp.util;
- 
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.util.WarManager;
--import au.edu.swin.war.framework.util.WarMatch;
--import au.edu.swin.war.framework.util.WarModule;
-+import sbs.mira.pvp.MiraPvpMaster;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.framework.util.WarMatch;
-+import sbs.mira.pvp.framework.MiraModule;
- import com.google.common.io.ByteArrayDataOutput;
- import com.google.common.io.ByteStreams;
- import io.netty.buffer.ByteBuf;
-@@ -58,11 +59,11 @@ import java.util.List;
-  * @version 1.0
-  * @since 1.0
-  */
--public class Guard extends WarModule implements Listener {
-+public class Guard extends MiraModule implements Listener {
- 
--    Guard(WarManager main) {
-+    Guard(MiraPulse main) {
-         super(main);
--        main().plugin().getServer().getPluginManager().registerEvents(this, main().plugin());
-+        mira().plugin().getServer().getPluginManager().registerEvents(this, mira().plugin());
-     }
- 
-     /*
-@@ -71,17 +72,17 @@ public class Guard extends WarModule implements Listener {
- 
-     @EventHandler
-     public void onBreak(BlockBreakEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getPlayer(), true));
-+        event.setCancelled(!mira().match().canInteract(event.getPlayer(), true));
-     }
- 
-     @EventHandler
-     public void onPlace(BlockPlaceEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getPlayer(), true));
-+        event.setCancelled(!mira().match().canInteract(event.getPlayer(), true));
-     }
- 
-     @EventHandler
-     public void onPlace(BlockDamageEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getPlayer(), true));
-+        event.setCancelled(!mira().match().canInteract(event.getPlayer(), true));
-     }
- 
-     //TODO: projectile launch event
-@@ -91,52 +92,52 @@ public class Guard extends WarModule implements Listener {
-      */
-     @EventHandler
-     public void onArmorStandChange(PlayerArmorStandManipulateEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getPlayer(), true));
-+        event.setCancelled(!mira().match().canInteract(event.getPlayer(), true));
-     }
- 
-     @EventHandler
-     public void onBedEnter(PlayerBedEnterEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getPlayer(), false));
-+        event.setCancelled(!mira().match().canInteract(event.getPlayer(), false));
-     }
- 
-     @EventHandler
-     public void onBucketEmpty(PlayerBucketEmptyEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getPlayer(), true));
-+        event.setCancelled(!mira().match().canInteract(event.getPlayer(), true));
-     }
- 
-     @EventHandler
-     public void onBucketFill(PlayerBucketFillEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getPlayer(), true));
-+        event.setCancelled(!mira().match().canInteract(event.getPlayer(), true));
-     }
- 
-     @EventHandler
-     public void onDropItem(PlayerDropItemEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getPlayer(), false));
-+        event.setCancelled(!mira().match().canInteract(event.getPlayer(), false));
-     }
- 
-     @EventHandler
-     public void onInteractAtEntity(PlayerInteractAtEntityEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getPlayer(), true));
-+        event.setCancelled(!mira().match().canInteract(event.getPlayer(), true));
-     }
- 
-     @EventHandler
-     public void onInteractEntity(PlayerInteractEntityEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getPlayer(), true));
-+        event.setCancelled(!mira().match().canInteract(event.getPlayer(), true));
-     }
- 
-     @EventHandler
-     public void onInteract(PlayerInteractEvent event) {
--        if (!main().match().canInteract(event.getPlayer(), true)) {
-+        if (!mira().match().canInteract(event.getPlayer(), true)) {
-             event.setCancelled(true);
-             if (event.getPlayer().getItemInHand().getType() == Material.WRITTEN_BOOK)
-                 openBook(event.getPlayer());
-         }
--        if (event.getPlayer().getItemInHand().equals(((Manager) main()).SKYBLOCK)) {
-+        if (event.getPlayer().getItemInHand().equals(((MiraPvpMaster) mira()).SKYBLOCK)) {
-             ByteArrayDataOutput out = ByteStreams.newDataOutput();
-             out.writeUTF("Connect");
-             out.writeUTF("skyblock");
--            event.getPlayer().sendPluginMessage(main().plugin(), "BungeeCord", out.toByteArray());
--        } else if (event.getPlayer().getItemInHand().equals(((Manager) main()).VOTE)) {
-+            event.getPlayer().sendPluginMessage(mira().plugin(), "BungeeCord", out.toByteArray());
-+        } else if (event.getPlayer().getItemInHand().equals(((MiraPvpMaster) mira()).VOTE)) {
-             TextComponent cmp = new TextComponent("   \n    " + ChatColor.GREEN + "[Voting Link 1]");
-             cmp.setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, new ComponentBuilder("**click me**").create()));
-             cmp.setClickEvent(new ClickEvent(ClickEvent.Action.OPEN_URL, "http://bit.ly/2CC6zF4"));
-@@ -163,12 +164,12 @@ public class Guard extends WarModule implements Listener {
- 
-     @EventHandler
-     public void onConsume(PlayerItemConsumeEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getPlayer(), true));
-+        event.setCancelled(!mira().match().canInteract(event.getPlayer(), true));
-     }
- 
-     @EventHandler
-     public void onPickupArrow(PlayerPickupArrowEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getPlayer(), false));
-+        event.setCancelled(!mira().match().canInteract(event.getPlayer(), false));
-     }
- 
-     @EventHandler
-@@ -178,7 +179,7 @@ public class Guard extends WarModule implements Listener {
- 
-     @EventHandler
-     public void onShear(PlayerShearEntityEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getPlayer(), true));
-+        event.setCancelled(!mira().match().canInteract(event.getPlayer(), true));
-     }
- 
-     /*
-@@ -187,17 +188,17 @@ public class Guard extends WarModule implements Listener {
- 
-     @EventHandler
-     public void onLinger(AreaEffectCloudApplyEvent event) {
--        event.getAffectedEntities().removeIf(livingEntity -> !main().match().canInteract(livingEntity, false));
-+        event.getAffectedEntities().removeIf(livingEntity -> !mira().match().canInteract(livingEntity, false));
-     }
- 
-     @EventHandler
-     public void onAir(EntityAirChangeEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getEntity(), false));
-+        event.setCancelled(!mira().match().canInteract(event.getEntity(), false));
-     }
- 
-     @EventHandler
-     public void onCombust(EntityCombustEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getEntity(), false));
-+        event.setCancelled(!mira().match().canInteract(event.getEntity(), false));
-     }
- 
-     @EventHandler
-@@ -212,54 +213,54 @@ public class Guard extends WarModule implements Listener {
-                 event.setCancelled(true);
-                 return;
-             }
--        event.setCancelled(!main().match().canInteract(event.getEntity(), false));
-+        event.setCancelled(!mira().match().canInteract(event.getEntity(), false));
-     }
- 
-     @EventHandler
-     public void onDamageByEntity(EntityDamageByEntityEvent event) {
-         if (event.getDamager() instanceof Projectile && ((Projectile) event.getDamager()).getShooter() instanceof Player)
--            event.setCancelled(!main().match().canInteract((Player) ((Projectile) event.getDamager()).getShooter(), true));
-+            event.setCancelled(!mira().match().canInteract((Player) ((Projectile) event.getDamager()).getShooter(), true));
-         else
--            event.setCancelled(!main().match().canInteract(event.getDamager(), true));
-+            event.setCancelled(!mira().match().canInteract(event.getDamager(), true));
-     }
- 
-     @EventHandler
-     public void onExplode(EntityExplodeEvent event) {
--        if (main().match().getStatus() != WarMatch.Status.PLAYING)
-+        if (mira().match().getStatus() != WarMatch.Status.PLAYING)
-             event.setCancelled(true);
-     }
- 
-     @EventHandler
-     public void onPickupItem(EntityPickupItemEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getEntity(), false));
--        if (event.getEntity() instanceof Player && !event.isCancelled() && (boolean) main().cache().getCurrentMap().attr().get("itemMerging"))
-+        event.setCancelled(!mira().match().canInteract(event.getEntity(), false));
-+        if (event.getEntity() instanceof Player && !event.isCancelled() && (boolean) mira().cache().getCurrentMap().attr().get("itemMerging"))
-             tryItemMerge(event);
-     }
- 
-     @EventHandler
-     public void onClick(InventoryClickEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getWhoClicked(), true));
-+        event.setCancelled(!mira().match().canInteract(event.getWhoClicked(), true));
-     }
- 
-     @EventHandler
-     public void onTarget(EntityTargetEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getTarget(), false));
-+        event.setCancelled(!mira().match().canInteract(event.getTarget(), false));
-     }
- 
-     @EventHandler
-     public void onLaunch(ProjectileLaunchEvent event) {
-         if (event.getEntity().getShooter() instanceof Entity)
--            event.setCancelled(!main().match().canInteract((Entity) event.getEntity().getShooter(), true));
-+            event.setCancelled(!mira().match().canInteract((Entity) event.getEntity().getShooter(), true));
-     }
- 
-     @EventHandler
-     public void onSplash(PotionSplashEvent event) {
--        event.getAffectedEntities().removeIf(livingEntity -> !main().match().canInteract(livingEntity, false));
-+        event.getAffectedEntities().removeIf(livingEntity -> !mira().match().canInteract(livingEntity, false));
-     }
- 
-     @EventHandler
-     public void onLeash(PlayerLeashEntityEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getEntity(), false));
-+        event.setCancelled(!mira().match().canInteract(event.getEntity(), false));
-     }
- 
-     @EventHandler
-@@ -288,11 +289,11 @@ public class Guard extends WarModule implements Listener {
-     @EventHandler
-     public void onPotionSplash(PotionSplashEvent event) {
-         if (!(event.getEntity().getShooter() instanceof Player)) return;
--        WarPlayer source = main().getWarPlayer(((Player) event.getEntity().getShooter()).getUniqueId());
-+        MiraPlayer source = mira().getWarPlayer(((Player) event.getEntity().getShooter()).getUniqueId());
-         for (LivingEntity target : event.getAffectedEntities())
-             if (target instanceof Player) {
--                WarPlayer pl = main().getWarPlayer(target.getUniqueId());
--                if (pl.isPlaying() && pl.getCurrentTeam().getTeamName().equals(source.getCurrentTeam().getTeamName()))
-+                MiraPlayer pl = mira().getWarPlayer(target.getUniqueId());
-+                if (pl.is_member_of_team() && pl.getCurrentTeam().getTeamName().equals(source.getCurrentTeam().getTeamName()))
-                     for (PotionEffect effect : event.getEntity().getEffects())
-                         if (harmful.contains(effect.getType()))
-                             event.setIntensity(target, 0); // Block harmful effects
-@@ -305,12 +306,12 @@ public class Guard extends WarModule implements Listener {
- 
-     @EventHandler
-     public void on(HangingBreakByEntityEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getEntity(), true));
-+        event.setCancelled(!mira().match().canInteract(event.getEntity(), true));
-     }
- 
-     @EventHandler
-     public void on(HangingPlaceEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getPlayer(), true));
-+        event.setCancelled(!mira().match().canInteract(event.getPlayer(), true));
-     }
- 
-     /*
-@@ -319,17 +320,17 @@ public class Guard extends WarModule implements Listener {
- 
-     @EventHandler
-     public void onVehicleDamage(VehicleEnterEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getEntered(), true));
-+        event.setCancelled(!mira().match().canInteract(event.getEntered(), true));
-     }
- 
-     @EventHandler
-     public void onVehicleDestroy(VehicleDestroyEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getAttacker(), true));
-+        event.setCancelled(!mira().match().canInteract(event.getAttacker(), true));
-     }
- 
-     @EventHandler
-     public void onVehicleDamage(VehicleDamageEvent event) {
--        event.setCancelled(!main().match().canInteract(event.getAttacker(), true));
-+        event.setCancelled(!mira().match().canInteract(event.getAttacker(), true));
-     }
- 
-     @EventHandler
-diff --git a/src/au/edu/swin/war/util/Match.java b/src/sbs/mira/pvp/util/Match.java
-similarity index 82%
-rename from src/au/edu/swin/war/util/Match.java
-rename to src/sbs/mira/pvp/util/Match.java
-index 95fd198..712af17 100644
---- a/src/au/edu/swin/war/util/Match.java
-+++ b/src/sbs/mira/pvp/util/Match.java
-@@ -1,10 +1,11 @@
--package au.edu.swin.war.util;
--
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarMap;
--import au.edu.swin.war.framework.util.WarMatch;
--import au.edu.swin.war.game.Gamemode;
--import au.edu.swin.war.game.Map;
-+package sbs.mira.pvp.util;
-+
-+import sbs.mira.pvp.MiraPvpMaster;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarMap;
-+import sbs.mira.pvp.framework.util.WarMatch;
-+import sbs.mira.pvp.game.Gamemode;
-+import sbs.mira.pvp.game.Map;
- import org.bukkit.*;
- import org.bukkit.entity.Player;
- import org.bukkit.scheduler.BukkitRunnable;
-@@ -49,7 +50,7 @@ public class Match extends WarMatch {
-      *
-      * @param main Running instance of Manager.
-      */
--    Match(Manager main) {
-+    Match(MiraPvpMaster main) {
-         super(main);
-         this.votes = new HashMap<>();
-         this.voted = new ArrayList<>();
-@@ -71,7 +72,7 @@ public class Match extends WarMatch {
-      * @return Map instance.
-      */
-     private Map getRunningMap() {
--        return (Map) main().cache().getCurrentMap();
-+        return (Map) mira().cache().getCurrentMap();
-     }
- 
-     /**
-@@ -167,7 +168,7 @@ public class Match extends WarMatch {
-                         int count2 = 8;
-                         if (count2 > Bukkit.getOnlinePlayers().size()) count2 = Bukkit.getOnlinePlayers().size();
-                         while (count2 > 0) {
--                            ((Manager) main()).entity().spawnFirework(getCurrentWorld().getPlayers().get(
-+                            ((MiraPvpMaster) mira()).entity().spawnFirework(getCurrentWorld().getPlayers().get(
-                                     new Random().nextInt(getCurrentWorld().getPlayers().size())).getLocation());
-                             // Spawn a random firework at 8 people's locations.
-                             // If there is less than 8 people online, then the amount of people online instead.
-@@ -188,7 +189,7 @@ public class Match extends WarMatch {
-                     preMatch();
-                 }
-             }
--        }.runTaskTimer(main().plugin(), 0L, 20L);
-+        }.runTaskTimer(mira().plugin(), 0L, 20L);
-     }
- 
-     /**
-@@ -203,7 +204,7 @@ public class Match extends WarMatch {
-     public void firstMatch() {
-         setStatus(Status.VOTING); // Change match cycle state.
-         setCurrentMap(getRotationList().get(rotationPoint)); // Get the next map on the rotation.
--        setRoundID(main().strings().generateID()); // Generates a new match world ID..
-+        setRoundID(mira().strings().generateID()); // Generates a new match world ID..
-         votes.put(getRunningMap().getGamemodes()[0], 1); // Give the map's first preferred gamemode 1 vote on startup.
-         continuePreMatch(); // Continue the pre-match cycle once the time is up.
-         gScore.registerNewTeam("PostSpectators").setPrefix(ChatColor.LIGHT_PURPLE + ""); // Create a post-spectator scoreboard team.
-@@ -223,7 +224,7 @@ public class Match extends WarMatch {
-             setNext = null;
-         }
- 
--        setRoundID(main().strings().generateID()); // Generates a new match world ID..
-+        setRoundID(mira().strings().generateID()); // Generates a new match world ID..
-         for (Gamemode.Mode mode : getRunningMap().getGamemodes()) // Give the votable modes a default score of zero.
-             votes.put(mode, 0);
-         new BukkitRunnable() {
-@@ -231,16 +232,16 @@ public class Match extends WarMatch {
- 
-             public void run() {
-                 if (time == voteTime) {
--                    Bukkit.broadcastMessage(main()._("votes.starting"));
--                    for (WarPlayer online : main().getWarPlayers().values())
--                        online.getPlayer().spigot().sendMessage(Gamemode.Mode.format(getRunningMap().getGamemodes(), main()));
-+                    Bukkit.broadcastMessage(mira().message("votes.starting"));
-+                    for (MiraPlayer online : mira().getWarPlayers().values())
-+                        online.crafter().spigot().sendMessage(Gamemode.Mode.format(getRunningMap().getGamemodes(), mira()));
-                 } else if (time == 0) {
-                     this.cancel();
-                     continuePreMatch(); // Continue the pre-match cycle once the time is up.
-                 }
-                 time--;
-             }
--        }.runTaskTimer(main().plugin(), 0L, 20L);
-+        }.runTaskTimer(mira().plugin(), 0L, 20L);
-     }
- 
-     /**
-@@ -265,29 +266,29 @@ public class Match extends WarMatch {
-         // Announce, set and clean vote results.
-         votes.clear();
-         voted.clear();
--        setCurrentMode(main().cache().getGamemode(winningVote.getFullName()));
-+        setCurrentMode(mira().cache().getGamemode(winningVote.getFullName()));
- 
--        Bukkit.broadcastMessage(main()._("votes.next", getCurrentMode().getGrammar(), getCurrentMode().getName(), getCurrentMap()));
-+        Bukkit.broadcastMessage(mira().message("votes.next", getCurrentMode().getGrammar(), getCurrentMode().getName(), getCurrentMap()));
- 
-         // Set the state to starting and perform starting logic.
--        main().world().loadMap(getCurrentMap(), getRawRoundID());
-+        mira().world().loadMap(getCurrentMap(), getRawRoundID());
-         setStatus(Status.STARTING);
- 
-         // Pre-round attribute assignment
--        if (main().cache().getCurrentMap().attr().containsKey("timeLock")) {
-+        if (mira().cache().getCurrentMap().attr().containsKey("timeLock")) {
-             World world = getCurrentWorld();
-             world.setGameRuleValue("doDaylightCycle", "false");
--            world.setFullTime((Long) main().cache().getCurrentMap().attr().get("timeLockTime"));
-+            world.setFullTime((Long) mira().cache().getCurrentMap().attr().get("timeLockTime"));
-         }
- 
-         // Teleport all online WarPlayers into the map.
--        for (WarPlayer online : main().getWarPlayers().values()) {
-+        for (MiraPlayer online : mira().getWarPlayers().values()) {
-             online.update();
--            online.getPlayer().teleport(getRunningMap().getSpectatorSpawn());
-+            online.crafter().teleport(getRunningMap().getSpectatorSpawn());
-         }
- 
-         // Completely eliminate all traces of the previous match world.
--        main().world().restoreMap(previousID + "");
-+        mira().world().restoreMap(previousID + "");
- 
-         // Create a temporary scoreboard for everyone.
-         gScore = Bukkit.getScoreboardManager().getNewScoreboard();
-@@ -297,8 +298,8 @@ public class Match extends WarMatch {
-         temp.setPrefix(ChatColor.LIGHT_PURPLE + "");
- 
-         // Add everyone to this new scoreboard.
--        for (WarPlayer pl : main().getWarPlayers().values())
--            temp.addEntry(pl.getPlayer().getName());
-+        for (MiraPlayer pl : mira().getWarPlayers().values())
-+            temp.addEntry(pl.crafter().getName());
- 
-         // Create a scoreboard objective, which actually puts data on the scoreboard.
-         final Objective obj = gScore.registerNewObjective("vote", "dummy");
-@@ -323,12 +324,12 @@ public class Match extends WarMatch {
- 
-                 // Format the objective to display pretty scores.
-                 obj.getScore("  ").setScore(3);
--                gScore.resetScores("     " + (time + 1) + " second" + main().strings().plural(time + 1));
-+                gScore.resetScores("     " + (time + 1) + " second" + mira().strings().plural(time + 1));
-                 obj.getScore("     Starting in").setScore(2);
--                obj.getScore("     " + time + " second" + main().strings().plural(time)).setScore(1);
-+                obj.getScore("     " + time + " second" + mira().strings().plural(time)).setScore(1);
-                 obj.getScore(" ").setScore(0);
-             }
--        }.runTaskTimer(main().plugin(), 0L, 20L);
-+        }.runTaskTimer(mira().plugin(), 0L, 20L);
-     }
- 
-     @Override
-@@ -358,9 +359,9 @@ public class Match extends WarMatch {
-                 team.removeEntry(entry);
- 
-         // Add all online players to the post spectator team.
--        for (WarPlayer pl : main().getWarPlayers().values()) {
--            pl.getPlayer().setScoreboard(gScore); // Let them see this scoreboard too!
--            temp.addEntry(pl.getPlayer().getName());
-+        for (MiraPlayer pl : mira().getWarPlayers().values()) {
-+            pl.crafter().setScoreboard(gScore); // Let them see this scoreboard too!
-+            temp.addEntry(pl.crafter().getName());
-         }
- 
-         startCycle(); // Start the cycle.
-@@ -371,22 +372,22 @@ public class Match extends WarMatch {
-         // Set the match state to cycling.
-         setStatus(Status.CYCLE);
- 
--        ((Manager) main()).respawn().clear();
-+        ((MiraPvpMaster) mira()).respawn().clear();
-         // Fix everyone back up.
--        for (WarPlayer pl : main().getWarPlayers().values()) {
-+        for (MiraPlayer pl : mira().getWarPlayers().values()) {
-             // Force respawn everyone using the Spigot entity API.
--            if (pl.getPlayer().isDead())
--                pl.getPlayer().spigot().respawn();
-+            if (pl.crafter().isDead())
-+                pl.crafter().spigot().respawn();
- 
-             // Finalise match cycling for this player.
--            pl.getPlayer().playSound(pl.getPlayer().getLocation(), Sound.ENTITY_WITHER_DEATH, 1L, 1L);
-+            pl.crafter().playSound(pl.crafter().getLocation(), Sound.ENTITY_WITHER_DEATH, 1L, 1L);
-             pl.setCurrentTeam(null);
--            pl.getPlayer().setGameMode(GameMode.CREATIVE);
--            main().items().clear(pl);
-+            pl.crafter().setGameMode(GameMode.CREATIVE);
-+            mira().items().clear(pl);
-         }
--        Bukkit.getScheduler().runTaskLater(main().plugin(), () -> {
--            for (WarPlayer pl : main().getWarPlayers().values())
--                main().giveSpectatorKit(pl);
-+        Bukkit.getScheduler().runTaskLater(mira().plugin(), () -> {
-+            for (MiraPlayer pl : mira().getWarPlayers().values())
-+                mira().giveSpectatorKit(pl);
-         }, 1L);
-         endCycle(); // Start the match cycle countdown.
-     }
-diff --git a/src/au/edu/swin/war/util/StatsListener.java b/src/sbs/mira/pvp/util/StatsListener.java
-similarity index 70%
-rename from src/au/edu/swin/war/util/StatsListener.java
-rename to src/sbs/mira/pvp/util/StatsListener.java
-index a5fe011..950ceab 100644
---- a/src/au/edu/swin/war/util/StatsListener.java
-+++ b/src/sbs/mira/pvp/util/StatsListener.java
-@@ -1,14 +1,15 @@
--package au.edu.swin.war.util;
--
--import au.edu.swin.war.WarPlayerPlus;
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.event.MatchEndEvent;
--import au.edu.swin.war.framework.event.MatchPlayerDeathEvent;
--import au.edu.swin.war.framework.util.WarManager;
--import au.edu.swin.war.framework.util.WarMatch;
--import au.edu.swin.war.framework.util.WarModule;
--import au.edu.swin.war.game.Map;
--import au.edu.swin.war.stats.WarStats;
-+package sbs.mira.pvp.util;
-+
-+import sbs.mira.pvp.MiraPvpMaster;
-+import sbs.mira.pvp.MiraPvpPlayer;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.event.MatchEndEvent;
-+import sbs.mira.pvp.framework.event.MatchPlayerDeathEvent;
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.framework.util.WarMatch;
-+import sbs.mira.pvp.framework.MiraModule;
-+import sbs.mira.pvp.game.Map;
-+import sbs.mira.pvp.stats.WarStats;
- import com.vexsoftware.votifier.model.VotifierEvent;
- import org.bukkit.*;
- import org.bukkit.attribute.Attribute;
-@@ -39,19 +40,19 @@ import static org.bukkit.ChatColor.*;
-  * @version 1.0
-  * @since 1.0
-  */
--public class StatsListener extends WarModule implements Listener {
-+public class StatsListener extends MiraModule implements Listener {
- 
--    StatsListener(WarManager main) {
-+    StatsListener(MiraPulse main) {
-         super(main);
--        main().plugin().getServer().getPluginManager().registerEvents(this, main().plugin());
-+        mira().plugin().getServer().getPluginManager().registerEvents(this, mira().plugin());
-         this.votes = new HashMap<>();
-     }
- 
-     @EventHandler
-     public void onServerList(ServerListPingEvent event) {
--        Map map = (Map) main().cache().getCurrentMap();
-+        Map map = (Map) mira().cache().getCurrentMap();
-         String state;
--        switch (main().match().getStatus()) {
-+        switch (mira().match().getStatus()) {
-             case CYCLE:
-                 state = map.getMapName() + GRAY + " (cycling)";
-                 break;
-@@ -65,7 +66,7 @@ public class StatsListener extends WarModule implements Listener {
-                     state = map.getMapName() + GRAY + " (waiting for players)";
-                 break;
-             case PLAYING:
--                state = map.getMapName() + GRAY + " (" + main().strings().getDigitalTime((int) (map.getMatchDuration() - main().match().getCurrentMode().getTimeElapsed())) + ") (" + main().match().getCurrentMode().getName() + ")";
-+                state = map.getMapName() + GRAY + " (" + mira().strings().getDigitalTime((int) (map.getMatchDuration() - mira().match().getCurrentMode().getTimeElapsed())) + ") (" + mira().match().getCurrentMode().getName() + ")";
-                 break;
-             default:
-                 state = RED + "Server is non-functional";
-@@ -87,19 +88,19 @@ public class StatsListener extends WarModule implements Listener {
-         try {
- 
-             // Checks if the player has stats recorded already.
--            PreparedStatement stats = ((Manager) main()).query().prepare("SELECT * FROM `WarStats` WHERE `player_uuid`=?");
-+            PreparedStatement stats = ((MiraPvpMaster) mira()).query().prepare("SELECT * FROM `WarStats` WHERE `player_uuid`=?");
-             stats.setString(1, event.getUniqueId().toString());
-             ResultSet check = stats.executeQuery(); // Execute the check and get our result.
- 
-             if (check.next()) {
--                main().plugin().log(event.getName() + " had previous stats, retrieving...");
--                ((Manager) main()).putTempStats(event.getUniqueId(), new WarStats((Manager) main(), event.getUniqueId(),
-+                mira().plugin().log(event.getName() + " had previous stats, retrieving...");
-+                ((MiraPvpMaster) mira()).putTempStats(event.getUniqueId(), new WarStats((MiraPvpMaster) mira(), event.getUniqueId(),
-                         check.getInt("kills"), check.getInt("deaths"),
-                         check.getInt("highestStreak"), check.getInt("matchesPlayed"),
-                         check.getInt("revives")));
-             } else {
--                main().plugin().log("Creating statistics record for " + event.getName());
--                PreparedStatement newStats = ((Manager) main()).query().prepare("INSERT INTO `WarStats` (`player_uuid`) VALUES (?)");
-+                mira().plugin().log("Creating statistics record for " + event.getName());
-+                PreparedStatement newStats = ((MiraPvpMaster) mira()).query().prepare("INSERT INTO `WarStats` (`player_uuid`) VALUES (?)");
-                 newStats.setString(1, event.getUniqueId().toString());
-                 newStats.executeUpdate(); // Execute our insertion query.
-                 newStats.close(); // Close the prepared statement.
-@@ -108,8 +109,8 @@ public class StatsListener extends WarModule implements Listener {
-             check.close(); // Close this one too.
-         } catch (SQLException e) {
-             event.setLoginResult(AsyncPlayerPreLoginEvent.Result.KICK_OTHER);
--            event.setKickMessage(main()._("prelogin.error"));
--            main().plugin().log("Unable to generate statistics for " + event.getUniqueId() + "!");
-+            event.setKickMessage(mira().message("prelogin.error"));
-+            mira().plugin().log("Unable to generate statistics for " + event.getUniqueId() + "!");
-             e.printStackTrace();
-         }
-     }
-@@ -124,25 +125,25 @@ public class StatsListener extends WarModule implements Listener {
-     public void onJoin(PlayerJoinEvent event) {
-         Player target = event.getPlayer(); // Get the player who connected.
-         target.getAttribute(Attribute.GENERIC_ATTACK_SPEED).setBaseValue(16); // 1.9 PVP
--        WarPlayer wp = main().craftWarPlayer(target); // Creates their needed WarPlayer record.
-+        MiraPlayer wp = mira().craftWarPlayer(target); // Creates their needed WarPlayer record.
-         wp.update(); // Update prefix n' shit.
- 
--        WarMatch.Status status = main().match().getStatus(); // Get the status of the match.
-+        WarMatch.Status status = mira().match().getStatus(); // Get the status of the match.
-         // Clear the player's inventory and give them the spectator kit.
--        main().items().clear(wp);
--        main().giveSpectatorKit(wp);
-+        mira().items().clear(wp);
-+        mira().giveSpectatorKit(wp);
- 
-         if (status == WarMatch.Status.STARTING || status == WarMatch.Status.PLAYING || status == WarMatch.Status.CYCLE)
--            target.teleport(main().cache().getCurrentMap().getSpectatorSpawn()); // Spawn them in the current defined map.
-+            target.teleport(mira().cache().getCurrentMap().getSpectatorSpawn()); // Spawn them in the current defined map.
-         else if (status == WarMatch.Status.VOTING)
--            target.teleport(((Map) main().cache().getMap(main().match().getPreviousMap())).getSpectatorSpawn_()); // Spawn them in the previous defined map.
-+            target.teleport(((Map) mira().cache().getMap(mira().match().getPreviousMap())).getSpectatorSpawn_()); // Spawn them in the previous defined map.
- 
-         if (status != WarMatch.Status.PLAYING) {
--            event.getPlayer().setScoreboard(((Match) main().match()).s()); // Show the default scoreboard.
--            ((Match) main().match()).s().getTeam("PostSpectators").addEntry(event.getPlayer().getName()); // Add them to this scoreboard.
-+            event.getPlayer().setScoreboard(((Match) mira().match()).s()); // Show the default scoreboard.
-+            ((Match) mira().match()).s().getTeam("PostSpectators").addEntry(event.getPlayer().getName()); // Add them to this scoreboard.
-             //TODO: Add them as spectators???
-         } else
--            event.getPlayer().setScoreboard(main().match().getCurrentMode().s()); // Show the gamemode's scoreboard.
-+            event.getPlayer().setScoreboard(mira().match().getCurrentMode().s()); // Show the gamemode's scoreboard.
-         target.setGameMode(GameMode.CREATIVE);
-     }
- 
-@@ -155,29 +156,29 @@ public class StatsListener extends WarModule implements Listener {
-     @EventHandler
-     public void onQuit(PlayerQuitEvent event) {
-         event.getPlayer().performCommand("leave"); // Act as if they were using the leave command.
--        main().destroyWarPlayer(event.getPlayer().getUniqueId()); // Remove their WarPlayer record.
-+        mira().destroyWarPlayer(event.getPlayer().getUniqueId()); // Remove their WarPlayer record.
-     }
- 
-     /* War event handling */
- 
-     @EventHandler
-     public void onDeath(MatchPlayerDeathEvent event) {
--        WarStats dead = ((WarPlayerPlus) event.getPlayer()).stats();
-+        WarStats dead = ((MiraPvpPlayer) event.getPlayer()).stats();
-         dead.addDeath();
- 
-         if (event.getKiller() != null) {
--            WarStats killer = ((WarPlayerPlus) event.getKiller()).stats();
-+            WarStats killer = ((MiraPvpPlayer) event.getKiller()).stats();
-             killer.addKill();
--            Player target = event.getKiller().getPlayer();
-+            Player target = event.getKiller().crafter();
-             if (killer.getCurrentStreak() % 5 == 0) {
-                 target.playSound(target.getLocation(), Sound.ENTITY_VEX_CHARGE, 1F, 1F);
--                target.sendMessage(main()._("killstreaks.status", killer.getCurrentStreak()));
-+                target.sendMessage(mira().message("killstreaks.status", killer.getCurrentStreak()));
-             }
-             if (killer.getCurrentStreak() == 10) {
-                 target.playSound(target.getLocation(), Sound.ENTITY_PARROT_IMITATE_ENDERDRAGON, 1F, 1F);
-                 target.addPotionEffect(new PotionEffect(PotionEffectType.FIRE_RESISTANCE, 5 * 20, 0));
-                 target.setFireTicks(100);
--                target.sendMessage(main()._("killstreaks.onfire", target.getDisplayName()));
-+                target.sendMessage(mira().message("killstreaks.onfire", target.getDisplayName()));
-             }
-             target.getWorld().spawnParticle(Particle.TOTEM, target.getLocation(), 70);
-         }
-@@ -185,9 +186,9 @@ public class StatsListener extends WarModule implements Listener {
- 
-     @EventHandler
-     public void onMatchEnd(MatchEndEvent event) {
--        for (WarPlayer pl : main().getWarPlayers().values())
--            if (pl.isPlaying())
--                ((WarPlayerPlus) pl).stats().addMatchPlayed();
-+        for (MiraPlayer pl : mira().getWarPlayers().values())
-+            if (pl.is_member_of_team())
-+                ((MiraPvpPlayer) pl).stats().addMatchPlayed();
-     }
- 
-     /* Voting storage and rewards. */
-@@ -210,7 +211,7 @@ public class StatsListener extends WarModule implements Listener {
-     public void onVoteJoin(PlayerJoinEvent event) {
-         if (votes.containsKey(event.getPlayer().getUniqueId()))
-             // Delay the task so the MoTD runs first.
--            Bukkit.getScheduler().runTaskLater(main().plugin(), () -> {
-+            Bukkit.getScheduler().runTaskLater(mira().plugin(), () -> {
-                 // Run the amount of times they voted.
-                 for (int i = 0; i < votes.get(event.getPlayer().getUniqueId()); i++)
-                     awardVote(event.getPlayer()); // Perform voting task now.
-@@ -225,12 +226,12 @@ public class StatsListener extends WarModule implements Listener {
-         // Do the broadcast. Don't broadcast how many times they voted, though.
-         for (Player online : Bukkit.getOnlinePlayers())
-             if (!online.equals(target))
--                online.sendMessage(main()._("votifier.others", target.getDisplayName()));
-+                online.sendMessage(mira().message("votifier.others", target.getDisplayName()));
-             else
--                online.sendMessage(main()._("votifier.self"));
-+                online.sendMessage(mira().message("votifier.self"));
- 
-         // Spawn a congratulatory firework.
--        ((Manager) main()).entity().spawnFirework(target.getLocation());
--        ((WarPlayerPlus) main().getWarPlayer(target)).stats().addRevive();
-+        ((MiraPvpMaster) mira()).entity().spawnFirework(target.getLocation());
-+        ((MiraPvpPlayer) mira().getWarPlayer(target)).stats().addRevive();
-     }
- }
-\ No newline at end of file
-diff --git a/src/au/edu/swin/war/util/WoolColor.java b/src/sbs/mira/pvp/util/WoolColor.java
-similarity index 98%
-rename from src/au/edu/swin/war/util/WoolColor.java
-rename to src/sbs/mira/pvp/util/WoolColor.java
-index 813a2c8..7699964 100644
---- a/src/au/edu/swin/war/util/WoolColor.java
-+++ b/src/sbs/mira/pvp/util/WoolColor.java
-@@ -1,4 +1,4 @@
--package au.edu.swin.war.util;
-+package sbs.mira.pvp.util;
- 
- import org.bukkit.ChatColor;
- 
-diff --git a/src/au/edu/swin/war/util/modules/ChatUtility.java b/src/sbs/mira/pvp/util/modules/ChatUtility.java
-similarity index 95%
-rename from src/au/edu/swin/war/util/modules/ChatUtility.java
-rename to src/sbs/mira/pvp/util/modules/ChatUtility.java
-index b65d9d9..7b38fbc 100644
---- a/src/au/edu/swin/war/util/modules/ChatUtility.java
-+++ b/src/sbs/mira/pvp/util/modules/ChatUtility.java
-@@ -1,7 +1,7 @@
--package au.edu.swin.war.util.modules;
-+package sbs.mira.pvp.util.modules;
- 
--import au.edu.swin.war.framework.util.WarManager;
--import au.edu.swin.war.framework.util.WarModule;
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.framework.MiraModule;
- import org.bukkit.ChatColor;
- import org.bukkit.entity.Player;
- import org.bukkit.inventory.ItemStack;
-@@ -16,11 +16,11 @@ import org.bukkit.inventory.ItemStack;
-  * @see ItemStack
-  * @since 1.2
-  */
--public class ChatUtility extends WarModule {
-+public class ChatUtility extends MiraModule {
- 
-     private final int CENTER_PX = 154;
- 
--    protected ChatUtility(WarManager main) {
-+    protected ChatUtility(MiraPulse main) {
-         super(main);
-     }
- 
-diff --git a/src/au/edu/swin/war/util/modules/CommandUtility.java b/src/sbs/mira/pvp/util/modules/CommandUtility.java
-similarity index 84%
-rename from src/au/edu/swin/war/util/modules/CommandUtility.java
-rename to src/sbs/mira/pvp/util/modules/CommandUtility.java
-index 692abc9..034be9d 100644
---- a/src/au/edu/swin/war/util/modules/CommandUtility.java
-+++ b/src/sbs/mira/pvp/util/modules/CommandUtility.java
-@@ -1,14 +1,14 @@
--package au.edu.swin.war.util.modules;
-+package sbs.mira.pvp.util.modules;
- 
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.game.WarMap;
--import au.edu.swin.war.framework.game.WarTeam;
--import au.edu.swin.war.framework.util.WarMatch;
--import au.edu.swin.war.framework.util.WarModule;
--import au.edu.swin.war.game.Gamemode;
--import au.edu.swin.war.util.Cache;
--import au.edu.swin.war.util.Manager;
--import au.edu.swin.war.util.Match;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.game.WarMap;
-+import sbs.mira.pvp.framework.game.WarTeam;
-+import sbs.mira.pvp.framework.util.WarMatch;
-+import sbs.mira.pvp.framework.MiraModule;
-+import sbs.mira.pvp.game.Gamemode;
-+import sbs.mira.pvp.util.Cache;
-+import sbs.mira.pvp.MiraPvpMaster;
-+import sbs.mira.pvp.util.Match;
- import com.sk89q.minecraft.util.commands.*;
- import net.md_5.bungee.api.chat.TextComponent;
- import org.bukkit.Bukkit;
-@@ -26,10 +26,10 @@ import org.bukkit.entity.Player;
-  * Created by Josh on 21/04/2017.
-  * @since 1.0
-  */
--public class CommandUtility extends WarModule {
-+public class CommandUtility extends MiraModule {
- 
-     @SuppressWarnings("unused") // This is used, just not directly.
--    public CommandUtility(Manager main) {
-+    public CommandUtility(MiraPvpMaster main) {
-         super(main);
-     }
- 
-@@ -48,7 +48,7 @@ public class CommandUtility extends WarModule {
-             usage = "<preference>")
-     public void join(CommandContext args, CommandSender sender) {
-         if (!(sender instanceof Player)) return; // Only players can join. Console can also execute modules.
--        WarPlayer wp = main().getWarPlayer(((Player) sender).getUniqueId());
-+        MiraPlayer wp = mira().getWarPlayer(((Player) sender).getUniqueId());
-         if (wp.isJoined()) {
-             // Don't re-execute join logic if they are already joined.
-             sender.sendMessage("You are already joined!");
-@@ -58,11 +58,11 @@ public class CommandUtility extends WarModule {
-         // Does the player have a team preference?
-         WarTeam preference = null;
-         if (args.argsLength() > 0) {
--            if (!main().plugin().hasPermission(sender, "war.preference")) {
-+            if (!mira().plugin().hasPermission(sender, "war.preference")) {
-                 sender.sendMessage(ChatColor.RED + "You may not pick your team preference.");
-                 return;
-             }
--            preference = main().cache().matchTeam(args.getJoinedStrings(0));
-+            preference = mira().cache().matchTeam(args.getJoinedStrings(0));
-             if (preference == null) {
-                 sender.sendMessage(ChatColor.RED + "That team does not exist.");
-                 return;
-@@ -70,13 +70,13 @@ public class CommandUtility extends WarModule {
-         }
- 
-         wp.setJoined(true); // Set them as joined.
--        if (main().match().getStatus() != WarMatch.Status.PLAYING)
-+        if (mira().match().getStatus() != WarMatch.Status.PLAYING)
-             // If there is no match playing, notify the player that they will automatically join when there is
-             sender.sendMessage("You will automatically join the next round.");
-         else {
-             if (preference == null)
--                main().match().getCurrentMode().entryHandle(wp); // Handle entry onto smallest team.
--            else main().match().getCurrentMode().entryHandle(wp, preference); // Otherwise handle entry of preference.
-+                mira().match().getCurrentMode().entryHandle(wp); // Handle entry onto smallest team.
-+            else mira().match().getCurrentMode().entryHandle(wp, preference); // Otherwise handle entry of preference.
-         }
-     }
- 
-@@ -95,19 +95,19 @@ public class CommandUtility extends WarModule {
-             max = 0)
-     public void leave(CommandContext args, CommandSender sender) {
-         if (!(sender instanceof Player)) return; // Only players can leave. Console can also execute modules.
--        WarPlayer wp = main().getWarPlayer(((Player) sender).getUniqueId());
-+        MiraPlayer wp = mira().getWarPlayer(((Player) sender).getUniqueId());
-         if (!wp.isJoined()) {
-             // Don't re-execute leave logic if they are not joined.
-             sender.sendMessage("You are not marked as joined!");
-             return;
-         }
-         wp.setJoined(false); // Set them as joined.
--        if (main().match().getStatus() != WarMatch.Status.PLAYING)
-+        if (mira().match().getStatus() != WarMatch.Status.PLAYING)
-             // If there is no match playing, notify the player that they will automatically join when there is.
-             sender.sendMessage("You will no longer automatically join the next round.");
-         else {
--            main().match().getCurrentMode().entryHandle(wp); // If applicable, handle their entry.
--            ((Manager) main()).respawn().clearFor(wp); // Clear their respawning info if they have any.
-+            mira().match().getCurrentMode().entryHandle(wp); // If applicable, handle their entry.
-+            ((MiraPvpMaster) mira()).respawn().clearFor(wp); // Clear their respawning info if they have any.
-         }
-     }
- 
-@@ -125,18 +125,18 @@ public class CommandUtility extends WarModule {
-             desc = "View the current rotation",
-             max = 0)
-     public void rotation(CommandContext args, CommandSender sender) {
--        int currentPos = main().match().rotationPoint;
--        int nextPos = currentPos == main().match().getRotationList().size() - 1 ? 0 : currentPos + 1;
--        Match match = (Match) main().match();
-+        int currentPos = mira().match().rotationPoint;
-+        int nextPos = currentPos == mira().match().getRotationList().size() - 1 ? 0 : currentPos + 1;
-+        Match match = (Match) mira().match();
- 
-         sender.sendMessage("Current rotation:");
--        for (int i = 0; i < main().match().getRotationList().size(); i++) {
-+        for (int i = 0; i < mira().match().getRotationList().size(); i++) {
-             if (currentPos == i) {
-                 // Is this the current map playing?
-                 if (match.wasSet()) {
-                     // Is a /setnext map playing? Show that one instead.
-                     sender.sendMessage((i + 1) + ". " + ChatColor.WHITE + match.getRotationList().get(i));
--                    sender.sendMessage(ChatColor.YELLOW + "» " + ChatColor.WHITE + main().cache().getCurrentMap().getMapName());
-+                    sender.sendMessage(ChatColor.YELLOW + "» " + ChatColor.WHITE + mira().cache().getCurrentMap().getMapName());
-                 } else
-                     // Otherwise just show the regular rotation map playing.
-                     sender.sendMessage(ChatColor.YELLOW + "" + (i + 1) + ". " + ChatColor.WHITE + match.getRotationList().get(i));
-@@ -208,12 +208,12 @@ public class CommandUtility extends WarModule {
-             min = 1)
-     @CommandPermissions("war.admin")
-     public void settime(CommandContext args, CommandSender sender) throws CommandNumberFormatException {
--        if (main().match().getStatus() != WarMatch.Status.PLAYING) {
-+        if (mira().match().getStatus() != WarMatch.Status.PLAYING) {
-             sender.sendMessage(ChatColor.RED + "There is no match playing.");
-             return;
-         }
--        Gamemode currentMode = (Gamemode) main().match().getCurrentMode();
--        long duration = main().cache().getCurrentMap().getMatchDuration();
-+        Gamemode currentMode = (Gamemode) mira().match().getCurrentMode();
-+        long duration = mira().cache().getCurrentMap().getMatchDuration();
- 
-         String time = args.getString(0);
-         int result;
-@@ -257,10 +257,10 @@ public class CommandUtility extends WarModule {
-             max = 0)
-     @CommandPermissions("war.mod") // Give this a special permission so only administrators can use it
-     public void end(CommandContext args, CommandSender sender) {
--        if (main().match().getStatus() == WarMatch.Status.PLAYING) {
-+        if (mira().match().getStatus() == WarMatch.Status.PLAYING) {
-             Bukkit.broadcastMessage(sender.getName() + " called an end to this match early");
--            ((Gamemode) main().match().getCurrentMode()).logEvent(sender.getName() + " ended this match early..");
--            main().match().getCurrentMode().onEnd(); // Calls onEnd() forcibly.
-+            ((Gamemode) mira().match().getCurrentMode()).logEvent(sender.getName() + " ended this match early..");
-+            mira().match().getCurrentMode().onEnd(); // Calls onEnd() forcibly.
-         }
-     }
- 
-@@ -280,12 +280,12 @@ public class CommandUtility extends WarModule {
-             min = 1)
-     @CommandPermissions("war.mod")
-     public void set(CommandContext args, CommandSender sender) {
--        WarMap found = main().cache().matchMap(args.getJoinedStrings(0));
-+        WarMap found = mira().cache().matchMap(args.getJoinedStrings(0));
-         if (found == null) {
-             sender.sendMessage(ChatColor.RED + "Error: Unknown map.");
-             return;
-         }
--        ((Match) main().match()).setNext(found);
-+        ((Match) mira().match()).setNext(found);
-         Bukkit.broadcastMessage(sender.getName() + " has set the next map to be " + found.getMapName());
-     }
- 
-@@ -298,20 +298,20 @@ public class CommandUtility extends WarModule {
-      * @param silent    If it is rigged, is it silent?
-      */
-     private void tryVote(CommandSender sender, String votingFor, boolean rig, boolean silent) {
--        if (main().match().getStatus() != WarMatch.Status.VOTING) {
-+        if (mira().match().getStatus() != WarMatch.Status.VOTING) {
-             // Notify the player there is no vote being held and ignore all other logic.
-             sender.sendMessage("There is no vote being held at the moment.");
-             return;
-         }
- 
--        Match match = (Match) main().match(); // Since this procedure contains non-WarMatch functions, use Match instead.
-+        Match match = (Match) mira().match(); // Since this procedure contains non-WarMatch functions, use Match instead.
-         if (!rig && match.getVoted().contains(((Player) sender).getUniqueId())) {
-             // Do not allow a player to vote twice. Das cheating. Kindof like real elections.
-             sender.sendMessage("You have already voted!");
-             return;
-         }
- 
--        Gamemode.Mode selection = ((Cache) main().cache()).matchMode(votingFor); // Match to the selected mode.
-+        Gamemode.Mode selection = ((Cache) mira().cache()).matchMode(votingFor); // Match to the selected mode.
-         if (selection != null) {
-             // Increment the votes for this gamemode by 1, or 1337 if rigging.
-             match.getVotes().put(selection, match.getVotes().get(selection) + (rig ? 1337 : 1));
-@@ -320,8 +320,8 @@ public class CommandUtility extends WarModule {
-             if (!rig) {
-                 match.getVoted().add(((Player) sender).getUniqueId());
-                 TextComponent comp = new TextComponent(((Player) sender).getName() + " voted for the gamemode ");
--                comp.addExtra(selection.getDescriptionComponent(main(), true));
--                main().broadcastSpigotMessage(comp);
-+                comp.addExtra(selection.getDescriptionComponent(mira(), true));
-+                mira().broadcastSpigotMessage(comp);
-             } else {
-                 // Warn staff and players(?) that vote was rigged.
-                 warnStaff(selection.getActualShortName() + " was rigged by " + sender.getName());
-@@ -342,7 +342,7 @@ public class CommandUtility extends WarModule {
-      */
-     private void warnStaff(String message) {
-         for (Player online : Bukkit.getOnlinePlayers())
--            if (main().plugin().hasPermission(online, "war.staff"))
-+            if (mira().plugin().hasPermission(online, "war.staff"))
-                 online.sendMessage(ChatColor.YELLOW + "Staff: " + message);
-         Bukkit.getConsoleSender().sendMessage(message);
-     }
-@@ -357,7 +357,7 @@ public class CommandUtility extends WarModule {
-      */
-     private void warnNonStaff(String message) {
-         for (Player online : Bukkit.getOnlinePlayers())
--            if (!main().plugin().hasPermission(online, "war.staff"))
-+            if (!mira().plugin().hasPermission(online, "war.staff"))
-                 online.sendMessage(ChatColor.YELLOW + "Warning: " + message);
-         Bukkit.getConsoleSender().sendMessage(message); // Also writes message to console as well.
-     }
-diff --git a/src/au/edu/swin/war/util/modules/ConfigUtility.java b/src/sbs/mira/pvp/util/modules/ConfigUtility.java
-similarity index 88%
-rename from src/au/edu/swin/war/util/modules/ConfigUtility.java
-rename to src/sbs/mira/pvp/util/modules/ConfigUtility.java
-index bd60301..58c3f00 100644
---- a/src/au/edu/swin/war/util/modules/ConfigUtility.java
-+++ b/src/sbs/mira/pvp/util/modules/ConfigUtility.java
-@@ -1,8 +1,8 @@
--package au.edu.swin.war.util.modules;
-+package sbs.mira.pvp.util.modules;
- 
- 
--import au.edu.swin.war.framework.util.WarManager;
--import au.edu.swin.war.framework.util.WarModule;
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.framework.MiraModule;
- import org.bukkit.Bukkit;
- import org.bukkit.configuration.file.FileConfiguration;
- import org.bukkit.configuration.file.YamlConfiguration;
-@@ -22,7 +22,7 @@ import java.io.InputStreamReader;
-  * @see org.bukkit.configuration.Configuration
-  * @since 1.0
-  */
--public class ConfigUtility extends WarModule {
-+public class ConfigUtility extends MiraModule {
- 
-     private final FileConfiguration config; // The configuration of config.yml in YAML.
-     private FileConfiguration messages; // The internal messages.yml file.
-@@ -38,7 +38,7 @@ public class ConfigUtility extends WarModule {
-      *
-      * @param main The supercontroller.
-      */
--    public ConfigUtility(WarManager main) {
-+    public ConfigUtility(MiraPulse main) {
-         super(main);
- 
-         // Save the default config in case it has never existed before.
-@@ -49,7 +49,7 @@ public class ConfigUtility extends WarModule {
-         config = main.plugin().getConfig();
- 
-         try {
--            messages = YamlConfiguration.loadConfiguration(new InputStreamReader(main().plugin().getResource("messages.yml"), "UTF8"));
-+            messages = YamlConfiguration.loadConfiguration(new InputStreamReader(mira().plugin().getResource("messages.yml"), "UTF8"));
-         } catch (Exception any) {
-             main.plugin().log("The messages were not able to be loaded.");
-             Bukkit.shutdown();
-@@ -75,7 +75,7 @@ public class ConfigUtility extends WarModule {
-     public void incrementPosition() {
-         WEBSTATS_POS++; // Increment the local value.
-         config.set("webstats.position", WEBSTATS_POS); // Set the new position in the config.
--        main().plugin().saveConfig(); // Save the config.
-+        mira().plugin().saveConfig(); // Save the config.
-     }
- 
-     /**
-diff --git a/src/au/edu/swin/war/util/modules/EntityUtility.java b/src/sbs/mira/pvp/util/modules/EntityUtility.java
-similarity index 93%
-rename from src/au/edu/swin/war/util/modules/EntityUtility.java
-rename to src/sbs/mira/pvp/util/modules/EntityUtility.java
-index eb994f2..f2e227d 100644
---- a/src/au/edu/swin/war/util/modules/EntityUtility.java
-+++ b/src/sbs/mira/pvp/util/modules/EntityUtility.java
-@@ -1,8 +1,8 @@
--package au.edu.swin.war.util.modules;
-+package sbs.mira.pvp.util.modules;
- 
- 
--import au.edu.swin.war.framework.util.WarManager;
--import au.edu.swin.war.framework.util.WarModule;
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.framework.MiraModule;
- import org.bukkit.ChatColor;
- import org.bukkit.Color;
- import org.bukkit.FireworkEffect;
-@@ -26,7 +26,7 @@ import java.util.Random;
-  * @see Entity
-  * @since 1.0
-  */
--public class EntityUtility extends WarModule {
-+public class EntityUtility extends MiraModule {
- 
-     private final Random rng; // Provided random number generator.
- 
-@@ -36,7 +36,7 @@ public class EntityUtility extends WarModule {
-      *
-      * @param main The supercontroller.
-      */
--    public EntityUtility(WarManager main) {
-+    public EntityUtility(MiraPulse main) {
-         super(main);
-         this.rng = new Random();
-     }
-@@ -81,7 +81,7 @@ public class EntityUtility extends WarModule {
-                 type = FireworkEffect.Type.STAR;
-         }
-         Color fade = getColor(rng.nextInt(17) + 1);
--        fwm.addEffect(FireworkEffect.builder().flicker(rng.nextBoolean()).withColor(main().strings().convertChatToDye(color)).withFade(fade).with(type).trail(rng.nextBoolean()).build());
-+        fwm.addEffect(FireworkEffect.builder().flicker(rng.nextBoolean()).withColor(mira().strings().convertChatToDye(color)).withFade(fade).with(type).trail(rng.nextBoolean()).build());
-         fwm.setPower(rng.nextInt(2) + 1);
-         fw.setFireworkMeta(fwm);
-     }
-diff --git a/src/au/edu/swin/war/util/modules/QueryUtility.java b/src/sbs/mira/pvp/util/modules/QueryUtility.java
-similarity index 81%
-rename from src/au/edu/swin/war/util/modules/QueryUtility.java
-rename to src/sbs/mira/pvp/util/modules/QueryUtility.java
-index 01383de..566d0ca 100644
---- a/src/au/edu/swin/war/util/modules/QueryUtility.java
-+++ b/src/sbs/mira/pvp/util/modules/QueryUtility.java
-@@ -1,10 +1,10 @@
--package au.edu.swin.war.util.modules;
-+package sbs.mira.pvp.util.modules;
- 
--import au.edu.swin.war.framework.WarPlugin;
--import au.edu.swin.war.framework.util.WarManager;
--import au.edu.swin.war.framework.util.WarModule;
--import au.edu.swin.war.stats.Database;
--import au.edu.swin.war.stats.Preparable;
-+import sbs.mira.pvp.framework.MiraPlugin;
-+import sbs.mira.pvp.framework.MiraPulse;
-+import sbs.mira.pvp.framework.MiraModule;
-+import sbs.mira.pvp.stats.Database;
-+import sbs.mira.pvp.stats.Preparable;
- import org.bukkit.scheduler.BukkitRunnable;
- import org.bukkit.scheduler.BukkitTask;
- 
-@@ -24,21 +24,21 @@ import java.util.concurrent.ConcurrentLinkedQueue;
-  * @see Preparable
-  * @since 1.1
-  */
--public class QueryUtility extends WarModule {
-+public class QueryUtility extends MiraModule {
- 
-     private final ConcurrentLinkedQueue<Preparable> queries;
-     private final Database db;
-     private BukkitTask thread;
- 
--    public QueryUtility(WarManager main, boolean enabled) {
-+    public QueryUtility(MiraPulse main, boolean enabled) {
-         super(main);
-         queries = new ConcurrentLinkedQueue<>();
- 
-         // Only create database connection if database is enabled.
-         if (enabled) {
--            db = new Database(main().plugin());
-+            db = new Database(mira().plugin());
-             //Leave it open, or?
--            saveThread(main().plugin());
-+            saveThread(mira().plugin());
-         } else db = null;
-     }
- 
-@@ -75,7 +75,7 @@ public class QueryUtility extends WarModule {
-      *
-      * @param plugin The plugin to execute the BukkitRunnable with.
-      */
--    private void saveThread(WarPlugin plugin) {
-+    private void saveThread(MiraPlugin plugin) {
-         thread = new BukkitRunnable() {
-             int counter = 2000;
- 
-diff --git a/src/au/edu/swin/war/util/modules/RespawnUtility.java b/src/sbs/mira/pvp/util/modules/RespawnUtility.java
-similarity index 64%
-rename from src/au/edu/swin/war/util/modules/RespawnUtility.java
-rename to src/sbs/mira/pvp/util/modules/RespawnUtility.java
-index ab8cf49..02067c1 100644
---- a/src/au/edu/swin/war/util/modules/RespawnUtility.java
-+++ b/src/sbs/mira/pvp/util/modules/RespawnUtility.java
-@@ -1,16 +1,16 @@
--package au.edu.swin.war.util.modules;
--
--import au.edu.swin.war.WarPlayerPlus;
--import au.edu.swin.war.event.MatchPlayerRespawnEvent;
--import au.edu.swin.war.framework.WarPlayer;
--import au.edu.swin.war.framework.util.WarMatch;
--import au.edu.swin.war.framework.util.WarModule;
--import au.edu.swin.war.util.Manager;
-+package sbs.mira.pvp.util.modules;
-+
-+import sbs.mira.pvp.MiraPvpPlayer;
-+import sbs.mira.pvp.event.MatchPlayerRespawnEvent;
-+import sbs.mira.pvp.framework.MiraPlayer;
-+import sbs.mira.pvp.framework.util.WarMatch;
-+import sbs.mira.pvp.framework.MiraModule;
-+import sbs.mira.pvp.MiraPvpMaster;
- import net.minecraft.server.v1_12_R1.DataWatcherObject;
- import net.minecraft.server.v1_12_R1.DataWatcherRegistry;
- import org.bukkit.Bukkit;
- import org.bukkit.GameMode;
--import org.bukkit.craftbukkit.v1_12_R1.entity.CraftPlayer;
-+import org.bukkit.craftbukkit.v1_21_R5.entity.CraftPlayer;
- import org.bukkit.event.EventHandler;
- import org.bukkit.event.Listener;
- import org.bukkit.event.player.PlayerQuitEvent;
-@@ -31,7 +31,7 @@ import java.util.UUID;
-  * @version 1.0
-  * @since 1.0
-  */
--public class RespawnUtility extends WarModule implements Listener {
-+public class RespawnUtility extends MiraModule implements Listener {
- 
-     private final HashMap<UUID, DeathInfo> info;
- 
-@@ -43,7 +43,8 @@ public class RespawnUtility extends WarModule implements Listener {
-      *
-      * @param main Running instance of Manager.
-      */
--    public RespawnUtility(Manager main) {
-+
-+    public RespawnUtility(MiraPvpMaster main) {
-         super(main);
-         main.plugin().getServer().getPluginManager().registerEvents(this, main.plugin());
- 
-@@ -58,20 +59,20 @@ public class RespawnUtility extends WarModule implements Listener {
-      *
-      * @param pl The player who died.
-      */
--    public void onDeath(WarPlayer pl) {
--        if (pl.getPlayer().getGameMode() != GameMode.SURVIVAL) return; // Ignore non-match deaths.
--        pl.getPlayer().setHealth(20); // Revive them, since they don't technically "die".
--        main().items().clear(pl); // Clear their inventory.
--        pl.getPlayer().setGameMode(GameMode.SPECTATOR); // Temporarily make them a spectator.
--        pl.getPlayer().addPotionEffect(new PotionEffect(PotionEffectType.CONFUSION, 400, 1)); // Death effect.
-+    public void onDeath(MiraPlayer pl) {
-+        if (pl.crafter().getGameMode() != GameMode.SURVIVAL) return; // Ignore non-match deaths.
-+        pl.crafter().setHealth(20); // Revive them, since they don't technically "die".
-+        mira().items().clear(pl); // Clear their inventory.
-+        pl.crafter().setGameMode(GameMode.SPECTATOR); // Temporarily make them a spectator.
-+        pl.crafter().addPotionEffect(new PotionEffect(PotionEffectType.CONFUSION, 400, 1)); // Death effect.
- 
-         // Create and store their death information.
--        DeathInfo inf = new DeathInfo((WarPlayerPlus) pl);
--        info.put(pl.getPlayer().getUniqueId(), inf);
--        if (!main().match().getCurrentMode().isPermaDeath())
--            pl.getPlayer().sendMessage("You died! Respawning in " + inf.timeUntilRespawn + " second" + main().strings().plural(inf.timeUntilRespawn));
-+        DeathInfo inf = new DeathInfo((MiraPvpPlayer) pl);
-+        info.put(pl.crafter().getUniqueId(), inf);
-+        if (!mira().match().getCurrentMode().isPermaDeath())
-+            pl.crafter().sendMessage("You died! Respawning in " + inf.timeUntilRespawn + " second" + mira().strings().plural(inf.timeUntilRespawn));
-         else
--            pl.getPlayer().sendMessage("You have been ejected from the round.");
-+            pl.crafter().sendMessage("You have been ejected from the round.");
- 
-     }
- 
-@@ -83,18 +84,18 @@ public class RespawnUtility extends WarModule implements Listener {
-      * If it's more than 0 seconds, subtract one second.
-      */
-     private void startTask() {
--        Bukkit.getScheduler().runTaskTimer(main().plugin(), () -> {
-+        Bukkit.getScheduler().runTaskTimer(mira().plugin(), () -> {
-             HashMap<UUID, DeathInfo> inf = new HashMap<>(info);
-             // Temporarily duplicate this key/value set to avoid concurrent errors.
-             for (Map.Entry<UUID, DeathInfo> entry : inf.entrySet()) {
-                 info.get(entry.getKey()).timeUntilRespawn--; // Decrement the player's respawn time.
-                 if (info.get(entry.getKey()).timeUntilRespawn == 0) { // Time to respawn?
-                     info.remove(entry.getKey());
--                    if (main().match().getStatus() == WarMatch.Status.PLAYING) {
-+                    if (mira().match().getStatus() == WarMatch.Status.PLAYING) {
-                         // Respawn them if the match is still playing.
--                        WarPlayer respawn = main().getWarPlayer(entry.getKey());
-+                        MiraPlayer respawn = mira().getWarPlayer(entry.getKey());
-                         Bukkit.getPluginManager().callEvent(new MatchPlayerRespawnEvent(respawn));
--                        ((CraftPlayer) respawn.getPlayer()).getHandle().getDataWatcher().set(new DataWatcherObject<>(10, DataWatcherRegistry.b),0);
-+                        ((CraftPlayer) respawn.crafter()).getHandle().getDataWatcher().set(new DataWatcherObject<>(10, DataWatcherRegistry.b),0);
-                     }
-                     break;
-                 }
-@@ -116,8 +117,8 @@ public class RespawnUtility extends WarModule implements Listener {
-      *
-      * @param toClear The player to get their info removed.
-      */
--    void clearFor(WarPlayer toClear) {
--        info.remove(toClear.getPlayer().getUniqueId());
-+    void clearFor(MiraPlayer toClear) {
-+        info.remove(toClear.crafter().getUniqueId());
-     }
- 
-     @EventHandler
-@@ -133,7 +134,7 @@ public class RespawnUtility extends WarModule implements Listener {
-      */
-     private class DeathInfo {
- 
--        DeathInfo(WarPlayerPlus wpp) {
-+        DeathInfo(MiraPvpPlayer wpp) {
-             timeUntilRespawn = 6 + (int) Math.ceil(wpp.stats().getCurrentStreak() / 2);
-         }
- 
-diff --git a/src/au/edu/swin/war/util/modules/StatsCommandUtility.java b/src/sbs/mira/pvp/util/modules/StatsCommandUtility.java
-similarity index 90%
-rename from src/au/edu/swin/war/util/modules/StatsCommandUtility.java
-rename to src/sbs/mira/pvp/util/modules/StatsCommandUtility.java
-index a358640..6ab8ea9 100644
---- a/src/au/edu/swin/war/util/modules/StatsCommandUtility.java
-+++ b/src/sbs/mira/pvp/util/modules/StatsCommandUtility.java
-@@ -1,9 +1,9 @@
--package au.edu.swin.war.util.modules;
-+package sbs.mira.pvp.util.modules;
- 
--import au.edu.swin.war.WarPlayerPlus;
--import au.edu.swin.war.framework.util.WarModule;
--import au.edu.swin.war.stats.WarStats;
--import au.edu.swin.war.util.Manager;
-+import sbs.mira.pvp.MiraPvpPlayer;
-+import sbs.mira.pvp.framework.MiraModule;
-+import sbs.mira.pvp.stats.WarStats;
-+import sbs.mira.pvp.MiraPvpMaster;
- import com.sk89q.minecraft.util.commands.Command;
- import com.sk89q.minecraft.util.commands.CommandContext;
- import com.sk89q.minecraft.util.commands.CommandNumberFormatException;
-@@ -36,10 +36,10 @@ import java.util.List;
-  * Created by Josh on 26/09/2017.
-  * @since 1.0
-  */
--public class StatsCommandUtility extends WarModule {
-+public class StatsCommandUtility extends MiraModule {
- 
-     @SuppressWarnings("unused") // This is used, just not directly.
--    public StatsCommandUtility(Manager main) {
-+    public StatsCommandUtility(MiraPvpMaster main) {
-         super(main);
-     }
- 
-@@ -69,7 +69,7 @@ public class StatsCommandUtility extends WarModule {
- 
-         if (finalTarget.isOnline()) {
-             Player target = Bukkit.getPlayer(finalTarget.getUniqueId());
--            WarStats stats = ((WarPlayerPlus) main().getWarPlayer(finalTarget.getUniqueId())).stats();
-+            WarStats stats = ((MiraPvpPlayer) mira().getWarPlayer(finalTarget.getUniqueId())).stats();
-             displayStats(sender, target.getDisplayName() + ChatColor.GREEN, stats.getKills(), stats.getDeaths(), stats.getCurrentStreak(), stats.getHighestStreak(), stats.getMatchesPlayed());
-         } else {
-             if (waiting.contains(sender.getName())) {
-@@ -77,9 +77,9 @@ public class StatsCommandUtility extends WarModule {
-                 return;
-             }
-             waiting.add(sender.getName());
--            Bukkit.getScheduler().runTaskAsynchronously(main().plugin(), () -> {
-+            Bukkit.getScheduler().runTaskAsynchronously(mira().plugin(), () -> {
-                 try {
--                    PreparedStatement stmt = ((Manager) main()).query().prepare("SELECT * FROM `WarStats` NATURAL JOIN `Players` WHERE `player_uuid`=?");
-+                    PreparedStatement stmt = ((MiraPvpMaster) mira()).query().prepare("SELECT * FROM `WarStats` NATURAL JOIN `Players` WHERE `player_uuid`=?");
-                     stmt.setString(1, finalTarget.getUniqueId().toString());
-                     ResultSet stats = stmt.executeQuery();
-                     if (stats.next())
-@@ -88,7 +88,7 @@ public class StatsCommandUtility extends WarModule {
-                     stats.close();
-                 } catch (SQLException e) {
-                     sender.sendMessage(ChatColor.RED + "An error occurred. Please try again later.");
--                    main().plugin().log("Unable to retrieve stats for " + finalTarget.getUniqueId());
-+                    mira().plugin().log("Unable to retrieve stats for " + finalTarget.getUniqueId());
-                     e.printStackTrace();
-                 } finally {
-                     waiting.remove(sender.getName());
-@@ -119,10 +119,10 @@ public class StatsCommandUtility extends WarModule {
-         waiting.add(sender.getName());
-         int page = args.argsLength() == 1 ? args.getInteger(0) : 1;
-         int offset = (page * 10) - 10;
--        Bukkit.getScheduler().runTaskAsynchronously(main().plugin(), () -> {
-+        Bukkit.getScheduler().runTaskAsynchronously(mira().plugin(), () -> {
-             StringBuilder msg = new StringBuilder("\n--- Leaderboard Page " + page + " ---\n");
-             try {
--                ResultSet lb = ((Manager) main()).query().prepare("SELECT * FROM `WarStats` NATURAL JOIN `Players` ORDER BY `kills` DESC LIMIT 10 OFFSET " + offset).executeQuery();
-+                ResultSet lb = ((MiraPvpMaster) mira()).query().prepare("SELECT * FROM `WarStats` NATURAL JOIN `Players` ORDER BY `kills` DESC LIMIT 10 OFFSET " + offset).executeQuery();
-                 for (int i = 0; i < 10; i++) {
-                     if (!lb.next()) {
-                         if (i != 9) msg.append(ChatColor.RED).append("No more results to display.\n");
diff --git a/src/sbs/mira/pvp/MiraPvpMaster.java b/src/sbs/mira/pvp/MiraPvpMaster.java
index af977e6..dbfc58c 100644
--- a/src/sbs/mira/pvp/MiraPvpMaster.java
+++ b/src/sbs/mira/pvp/MiraPvpMaster.java
@@ -1,9 +1,17 @@
 package sbs.mira.pvp;
 
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.Material;
 import org.bukkit.craftbukkit.v1_21_R5.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.meta.BookMeta;
+import org.bukkit.inventory.meta.ItemMeta;
+import org.bukkit.potion.PotionEffectType;
 import org.jetbrains.annotations.NotNull;
-import sbs.mira.pvp.framework.MiraPluginMaster;
 import sbs.mira.pvp.framework.MiraPlayer;
+import sbs.mira.pvp.framework.MiraPluginMaster;
 import sbs.mira.pvp.stats.WarStats;
 import sbs.mira.pvp.util.Cache;
 import sbs.mira.pvp.util.Match;
@@ -11,160 +19,182 @@ import sbs.mira.pvp.util.modules.ConfigUtility;
 import sbs.mira.pvp.util.modules.EntityUtility;
 import sbs.mira.pvp.util.modules.QueryUtility;
 import sbs.mira.pvp.util.modules.RespawnUtility;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.Material;
-import org.bukkit.entity.Player;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.inventory.meta.BookMeta;
-import org.bukkit.inventory.meta.ItemMeta;
-import org.bukkit.potion.PotionEffectType;
 
-import java.util.*;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.UUID;
 
 /**
  * [wit.]
  * created on 2017-03-20.
  *
  * @author jj.mira.sbs
+ * @author jd.mira.sbs
  * @version 1.0.1
  * @see sbs.mira.pvp.framework.MiraPluginMaster
  * @since 1.0.0
  */
-public class MiraPvpMaster extends MiraPluginMaster<MiraPvpPulse, MiraPvpPlayer> {
-  
+public
+class MiraPvpMaster
+  extends MiraPluginMaster<MiraPvpPulse, MiraPvpPlayer>
+{
   
-  /*private final Match matchutil; // An instance of the match controller.
-  private final Cache cacheutil; // An instance of the cache.
-  private final RespawnUtility respawnutil; // An instance of the respawning utility.
-  private final EntityUtility entiutil; // An instance of the entity utility.
-  private final ConfigUtility confutil; // An instance of the configuration utility.
-  private final QueryUtility qryutil; // An instance of the database utility.
+  private final Match match;
+  private final Cache cache;
+  private final RespawnUtility respawn;
+  private final EntityUtility entities;
+  private final ConfigUtility config;
+  private final QueryUtility db;
   
   private final ArrayList<UUID> warned; // Keeps track of warning messages for players.
-  private final HashMap<UUID, WarStats> tempStats; // Holds statistics for a player until they log in.
+  private final HashMap<UUID, WarStats> tempStats;
   
-  private ItemStack HANDBOOK; // Needs to be created in its own function because it's HELLA huge.
+  private ItemStack HANDBOOK;
   ItemStack VOTE;
-  ItemStack SKYBLOCK;*/
+  ItemStack SKYBLOCK;
   
-  public MiraPvpMaster(MiraPvpPlugin plugin) {
-    super(plugin);
-    /*this.cacheutil = new Cache(this);
-    this.matchutil = new Match(this);
+  public
+  MiraPvpMaster(MiraPvpPlugin plugin)
+  {
+    this.match = new Match(this);
+    this.cacheutil = new Cache(this);
     this.respawnutil = new RespawnUtility(this);
     this.entiutil = new EntityUtility(this);
     this.confutil = new ConfigUtility(this);
     this.qryutil = new QueryUtility(this, plugin.getConfig().getBoolean("database.enabled"));
-    new Guard(this); // Guard does not need a reference so just initialize it.
-    new StatsListener(this); // Stats Listener does not need a reference so just initialize it.*/
+    new Guard(this);
+    new StatsListener(this);
     
     warned = new ArrayList<>();
     tempStats = new HashMap<>();
-    // Task that allows players to receive a warning message every 3 seconds.
-    // Clear warnings.
     Bukkit.getScheduler().runTaskTimer(plugin, warned::clear, 0L, 60L);
     createItems();
   }
   
   /**
-   * Returns a running instance of the extended Match manager.
+   * returns a running instance of the extended Match manager.
    *
-   * @return Match manager.
+   * @return match manager.
    */
-  public Match match() {
+  public
+  Match match()
+  {
     return matchutil;
   }
   
   /**
-   * Returns a running instance of the extended Cache.
+   * returns a running instance of the extended Cache.
    *
-   * @return Cache.
+   * @return cache.
    */
-  public Cache cache() {
+  public
+  Cache cache()
+  {
     return cacheutil;
   }
   
   /**
-   * Returns a running instance of the respawn utility.
+   * returns a running instance of the respawn utility.
    *
-   * @return Respawn utility.
+   * @return respawn utility.
    */
-  public RespawnUtility respawn() {
+  public
+  RespawnUtility respawn()
+  {
     return respawnutil;
   }
   
   /**
-   * Returns a running instance of the entity utility.
+   * returns a running instance of the entity utility.
    *
-   * @return Entity utility.
+   * @return entity utility.
    */
-  public EntityUtility entity() {
+  public
+  EntityUtility entity()
+  {
     return entiutil;
   }
   
   /**
-   * Returns a running instance of the configuration utility.
+   * returns a running instance of the configuration utility.
    *
-   * @return Configuration utility.
+   * @return configuration utility.
    */
-  public ConfigUtility conf() {
+  public
+  ConfigUtility conf()
+  {
     return confutil;
   }
   
   /**
-   * Returns a running instance of the query utility.
+   * returns a running instance of the query utility.
    *
-   * @return Query utility.
+   * @return query utility.
    */
-  public QueryUtility query() {
+  public
+  QueryUtility query()
+  {
     return qryutil;
   }
   
   /**
-   * Temporarily holds onto a player's statistics
+   * temporarily holds onto a player's statistics
    * without necessarily having a WarPlayerPlus
    * instance created yet. (pre login)
    *
-   * @param uuid      UUID associated with the stats.
-   * @param tempStats Actual stats.
+   * @param uuid      uuid associated with the stats.
+   * @param tempStats actual stats.
    */
-  void putTempStats(UUID uuid, WarStats tempStats) {
+  void putTempStats(UUID uuid, WarStats tempStats)
+  {
     this.tempStats.put(uuid, tempStats);
   }
   
   /**
-   * Creates an instance of a WarPlayer for a player.
+   * creates an instance of a WarPlayer for a player.
    *
-   * @param target The target to base the WarPlayer object on.
+   * @param target the target to base the WarPlayer object on.
    */
-  public MiraPvpPlayer declares(Player target) {
-    WarStats stats = tempStats.getOrDefault(target.getUniqueId(), new WarStats(this, target.getUniqueId())); // Get their stats, or create new ones.
+  public
+  MiraPvpPlayer declares(Player target)
+  {
+    WarStats stats = tempStats.getOrDefault(
+      target.getUniqueId(),
+      new WarStats(this, target.getUniqueId())
+    );
     tempStats.remove(target.getUniqueId()); // Remove their pre-login storage stats.
-    MiraPlayer result = new MiraPvpPlayer(target, this, stats); // Create their instance.
+    MiraPlayer result = new MiraPvpPlayer(target.getHan, this, stats); // Create their instance.
     players().put(target.getUniqueId(), result); // Put it in the key/value set!
     return result;
   }
   
   /**
-   * Checks if a player can be warned, and then warns them.
+   * checks if a player can be warned, and then warns them.
    *
-   * @param whoWasWarned Who was warned. (lol)
+   * @param whoWasWarned who was warned.
    */
-  public void warn(Player whoWasWarned, String warning) {
-    if (warned.contains(whoWasWarned.getPlayer().getUniqueId())) return;
+  public
+  void warn(Player whoWasWarned, String warning)
+  {
+    if (warned.contains(whoWasWarned.getPlayer().getUniqueId()))
+    {
+      return;
+    }
     warned.add(whoWasWarned.getPlayer().getUniqueId());
     whoWasWarned.sendMessage("TIP: " + warning);
   }
   
   /**
-   * Gives a targeted player the spectator kit.
-   * This isn't needed, but it might be later.
+   * gives a targeted player the spectator kit.
+   * this isn't needed, but it might be later.
    *
-   * @param wp The target player.
+   * @param wp the target player.
    * @since 1.0
    */
-  public void spectating(MiraPlayer wp) {
+  public
+  void spectating(MiraPlayer wp)
+  {
     wp.crafter().getInventory().setHeldItemSlot(4);
     wp.crafter().getInventory().setItem(4, HANDBOOK);
     wp.crafter().getInventory().setItem(0, SKYBLOCK);
@@ -172,11 +202,13 @@ public class MiraPvpMaster extends MiraPluginMaster<MiraPvpPulse, MiraPvpPlayer>
   }
   
   /**
-   * Creates the handbook because the process of
+   * creates the handbook because the process of
    * doing so consumes lines like no tomorrow.
-   * All other items too why not.
+   * all other items too why not.
    */
-  private void createItems() {
+  private
+  void createItems()
+  {
     HANDBOOK = new ItemStack(Material.WRITTEN_BOOK);
     BookMeta bookMeta = (BookMeta) HANDBOOK.getItemMeta();
     bookMeta.setTitle(ChatColor.BOLD + "War: The Basics");
@@ -184,12 +216,30 @@ public class MiraPvpMaster extends MiraPluginMaster<MiraPvpPulse, MiraPvpPlayer>
     bookMeta.setGeneration(BookMeta.Generation.TATTERED);
     
     List<String> pages = new ArrayList<>();
-    pages.add(ChatColor.translateAlternateColorCodes('&', "&lWar: The Basics\n&0Hey there, player!\n\nBook Contents:\n&ci.&0 Overview\n&9ii.&0 Commands\n&6iii.&0 Players\n&aiv.&0 Rules\n\nIf you're &cnew&0, read through me and then\n       &nHAVE FUN!\n\n&0  »»»"));
-    pages.add(ChatColor.translateAlternateColorCodes('&', "&oPart I. An Overview\n&0Welcome to War!\n\nThis is a &5team-based &0strategy PvP server!\nWork with your &4team mates &0to win matches.\n\nThere's a &agamemode &0tosuit everyone's play style!\n\n\n&0     »»»"));
-    pages.add(ChatColor.translateAlternateColorCodes('&', "&oPart II. Commands\n\nStart Playing!\n&c/join &0- &9/leave\n&0What's up next?\n&4/rotation\n&0Have your say!\n&a/vote &0<gamemode>\nStatistics!\n&6/stats &0+ &7/leaderboard\n\n&0Or, &n/? War\n\n&0        »»»"));
-    pages.add(ChatColor.translateAlternateColorCodes('&', "&oPart III. Players\n&0You'll see these people online!\n\n&oStaff:\n&6@&8Administrator\n&5@&8Moderator\n\n&0&oOther Ranks:\n&a#&8Donator\n&e#&8DonatorPlus\n&4#&8MapCreator\n\n&0           »»»"));
-    pages.add(ChatColor.translateAlternateColorCodes('&', "&oPart IV. Rules\n&0Follow these!\n\n&ci. &0Don't be a dick.\n&9ii. &0Play the game.\n&4iii. &0Don't cheat.\n&6iv. &0Don't combat log.\n&2v. &0Be a good sport.\n&5vi. &0Don't spawncamp.\n&8vii. &0Listen to @Staff\n&7viii. &0Have fun!\n\n\n&0              »»»"));
-    pages.add(ChatColor.translateAlternateColorCodes('&', "&oNow, go get 'em!\n\n&0We encourage players to use &4common sense &0whilst playing. Have a safe, sensible, and &dfun &cWar!\n\n&0- Administration\n\n\n\n\n                  X"));
+    pages.add(ChatColor.translateAlternateColorCodes(
+      '&',
+      "&lWar: The Basics\n&0Hey there, player!\n\nBook Contents:\n&ci.&0 Overview\n&9ii.&0 Commands\n&6iii.&0 Players\n&aiv.&0 Rules\n\nIf you're &cnew&0, read through me and then\n       &nHAVE FUN!\n\n&0  »»»"
+    ));
+    pages.add(ChatColor.translateAlternateColorCodes(
+      '&',
+      "&oPart I. An Overview\n&0Welcome to War!\n\nThis is a &5team-based &0strategy PvP server!\nWork with your &4team mates &0to win matches.\n\nThere's a &agamemode &0tosuit everyone's play style!\n\n\n&0     »»»"
+    ));
+    pages.add(ChatColor.translateAlternateColorCodes(
+      '&',
+      "&oPart II. Commands\n\nStart Playing!\n&c/join &0- &9/leave\n&0What's up next?\n&4/rotation\n&0Have your say!\n&a/vote &0<gamemode>\nStatistics!\n&6/stats &0+ &7/leaderboard\n\n&0Or, &n/? War\n\n&0        »»»"
+    ));
+    pages.add(ChatColor.translateAlternateColorCodes(
+      '&',
+      "&oPart III. Players\n&0You'll see these people online!\n\n&oStaff:\n&6@&8Administrator\n&5@&8Moderator\n\n&0&oOther Ranks:\n&a#&8Donator\n&e#&8DonatorPlus\n&4#&8MapCreator\n\n&0           »»»"
+    ));
+    pages.add(ChatColor.translateAlternateColorCodes(
+      '&',
+      "&oPart IV. Rules\n&0Follow these!\n\n&ci. &0Don't be a dick.\n&9ii. &0Play the game.\n&4iii. &0Don't cheat.\n&6iv. &0Don't combat log.\n&2v. &0Be a good sport.\n&5vi. &0Don't spawncamp.\n&8vii. &0Listen to @Staff\n&7viii. &0Have fun!\n\n\n&0              »»»"
+    ));
+    pages.add(ChatColor.translateAlternateColorCodes(
+      '&',
+      "&oNow, go get 'em!\n\n&0We encourage players to use &4common sense &0whilst playing. Have a safe, sensible, and &dfun &cWar!\n\n&0- Administration\n\n\n\n\n                  X"
+    ));
     bookMeta.setPages(pages);
     HANDBOOK.setItemMeta(bookMeta);
     
@@ -213,7 +263,9 @@ public class MiraPvpMaster extends MiraPluginMaster<MiraPvpPulse, MiraPvpPlayer>
   }
   
   @Override
-  public @NotNull Cache observe() {
+  public @NotNull
+  Cache observe()
+  {
     return cacheutil;
   }
   
diff --git a/src/sbs/mira/pvp/MiraPvpPlayer.java b/src/sbs/mira/pvp/MiraPvpPlayer.java
index 705aa0a..2aeac94 100644
--- a/src/sbs/mira/pvp/MiraPvpPlayer.java
+++ b/src/sbs/mira/pvp/MiraPvpPlayer.java
@@ -1,23 +1,27 @@
 package sbs.mira.pvp;
 
+import org.bukkit.ChatColor;
 import org.bukkit.craftbukkit.v1_21_R5.entity.CraftPlayer;
 import org.jetbrains.annotations.Nullable;
 import sbs.mira.pvp.framework.MiraPlayer;
 import sbs.mira.pvp.framework.game.WarTeam;
 import sbs.mira.pvp.stats.WarStats;
-import org.bukkit.ChatColor;
 
 /**
- * An extension to WarPlayer that contains non-framework fields.
- * Mostly used for statistics tracking.
+ * an extension to WarPlayer that contains non-framework fields.
+ * mostly used for statistics tracking.
  * created on 2025-08-17.
  *
- * @author jj.mira.sbs, jd.mira.sbs
+ * @author jj.mira.sbs
+ * @author jd.mira.sbs
  * @version 1.0.1
  * @see org.bukkit.plugin.java.JavaPlugin
  * @since 1.0.0
  */
-public final class MiraPvpPlayer extends MiraPlayer<MiraPvp> {
+public final
+class MiraPvpPlayer
+  extends MiraPlayer<MiraPvpPulse>
+{
   
   /**
    * @see sbs.mira.pvp.stats.WarStats
@@ -33,8 +37,10 @@ public final class MiraPvpPlayer extends MiraPlayer<MiraPvp> {
    */
   private WarTeam team;
   
-  public MiraPvpPlayer(WarStats stats, CraftPlayer player, MiraPvp mira) {
-    super(player, mira);
+  public
+  MiraPvpPlayer(WarStats stats, CraftPlayer player, MiraPvpPulse pulse)
+  {
+    super(player, pulse);
     
     this.stats = stats;
     this.joined = false;
@@ -46,45 +52,57 @@ public final class MiraPvpPlayer extends MiraPlayer<MiraPvp> {
   /**
    * @see #stats
    */
-  public WarStats stats() {
+  public
+  WarStats stats()
+  {
     return stats;
   }
   
   /**
    * @see #joined
    */
-  public boolean joined() {
+  public
+  boolean joined()
+  {
     return joined;
   }
   
   /**
    * @see #joined
    */
-  public void joined(boolean joined) {
+  public
+  void joined(boolean joined)
+  {
     this.joined = joined;
   }
   
   /**
    * @return true if the mira pvp stan has an [sic, lol] designated team.
    */
-  public boolean has_team() {
+  public
+  boolean has_team()
+  {
     return team != null;
   }
   
   /**
-   * Returns the team that the player is currently associated with.
-   * This is the team that the player currently on during a match.
+   * returns the team that the player is currently associated with.
+   * this is the team that the player currently on during a match.
    *
    * @return Player's associated team.
    */
-  public @Nullable WarTeam team() {
+  public @Nullable
+  WarTeam team()
+  {
     return team;
   }
   
   /**
    * @param new_team the player is joining this team (consensually).
    */
-  public void joins(WarTeam new_team) {
+  public
+  void joins(WarTeam new_team)
+  {
     this.team = new_team;
     
     changes_visibility();
@@ -98,66 +116,86 @@ public final class MiraPvpPlayer extends MiraPlayer<MiraPvp> {
    *   <li>`setCollidable(false)` ensures spectators cannot bump match participants around.</li>
    * </ul>
    */
-  private void changes_visibility() {
-    if (has_team()) {
-      player.setCollidable(true);
-      // If they are playing, everyone can see this player.
-      // They however, cannot see spectators.
-      for (MiraPvpPlayer dp : mira.master().players().values())
-        if (dp.equals(this)) continue;
-        else if (dp.is_member_of_team()) {
-          // They are both playing, so they can both see each other.
-          dp.crafter().showPlayer(player);
-          player.showPlayer(dp.crafter());
-        } else {
-          // The other player is spectating, so this player cannot see them.
-          dp.crafter().showPlayer(player);
-          player.hidePlayer(dp.crafter());
+  private
+  void changes_visibility()
+  {
+    if (has_team())
+    {
+      this.crafter().setCollidable(true);
+      for (MiraPvpPlayer player : pulse().master().players().values())
+      {
+        if (!player.equals(this))
+        {
+          if (player.has_team())
+          {
+            player.crafter().showPlayer(this.player);
+            this.player.showPlayer(player.crafter());
+          }
+          else
+          {
+            player.crafter().showPlayer(this.player);
+            this.player.hidePlayer(player.crafter());
+          }
         }
-    } else {
+      }
+    }
+    else
+    {
       player.setCollidable(false);
-      // If they are spectating, only spectators can see this player.
-      // They can see others playing as well.
-      for (MiraPvpPlayer dp : manager.getWarPlayers().values())
-        if (dp.equals(this)) continue;
-        else if (dp.is_member_of_team()) {
-          // The other player is playing, so they cannot see this player.
-          dp.crafter().hidePlayer(player);
-          player.showPlayer(dp.crafter());
-        } else {
-          // The other player is spectating, so they can see each other.
-          dp.crafter().showPlayer(player);
-          player.showPlayer(dp.crafter());
+      for (MiraPvpPlayer player : pulse().master().players().values())
+      {
+        if (!player.equals(this))
+        {
+          if (player.has_team())
+          {
+            player.crafter().hidePlayer(this.player);
+            this.player.showPlayer(player.crafter());
+          }
+          else
+          {
+            player.crafter().showPlayer(this.player);
+            this.player.showPlayer(player.crafter());
+          }
         }
+      }
     }
   }
   
   /**
-   * Updates this player's display name.
-   * This should be called whenever their
+   * updates this player's display name.
+   * this should be called whenever their
    * team changes or rank changes.
    */
-  public void changes_name() {
+  public
+  void changes_name()
+  {
     String prefix = "";
-    if (manager.plugin().hasPermission(crafter(), "war.admin"))
-      // Admins do not have any other prefixes, except map builder.
+    if (pulse().plugin().has_permission(crafter(), "war.admin"))
+    {
       prefix = ChatColor.GOLD + "@";
-    else {
-      if (manager.plugin().hasPermission(crafter(), "war.mod"))
-        // Give mod prefixes priority too.
+    }
+    else
+    {
+      if (pulse().plugin().has_permission(crafter(), "war.mod"))
+      {
         prefix = ChatColor.DARK_PURPLE + "@";
+      }
       
-      if (manager.plugin().hasPermission(crafter(), "war.donatorplus"))
-        // DonatorPlus takes priority over Donator.
+      if (pulse().plugin().has_permission(crafter(), "war.donatorplus"))
+      {
         prefix = ChatColor.YELLOW + "#" + prefix;
-      else if (manager.plugin().hasPermission(crafter(), "war.donator"))
-        // Otherwise do donator if they only have that.
+      }
+      else if (pulse().plugin().has_permission(crafter(), "war.donator"))
+      {
         prefix = ChatColor.GREEN + "#" + prefix;
+      }
     }
-    if (manager.cache().getCurrentMap().isCreator(crafter().getUniqueId()))
+    if (pulse().cache().getCurrentMap().isCreator(crafter().getUniqueId()))
+    {
       prefix = ChatColor.DARK_RED + "#" + prefix;
+    }
     
-    ChatColor teamColor = has_team() ? joins_team().getTeamColor() : ChatColor.LIGHT_PURPLE;
+    ChatColor teamColor = has_team() ? team().getTeamColor() : ChatColor.LIGHT_PURPLE;
     crafter().setDisplayName(prefix + teamColor + name() + ChatColor.WHITE);
   }
 }
diff --git a/src/sbs/mira/pvp/framework/MiraPlayer.java b/src/sbs/mira/pvp/framework/MiraPlayer.java
index 75ee78f..f14c3a3 100644
--- a/src/sbs/mira/pvp/framework/MiraPlayer.java
+++ b/src/sbs/mira/pvp/framework/MiraPlayer.java
@@ -2,6 +2,8 @@ package sbs.mira.pvp.framework;
 
 import org.bukkit.craftbukkit.v1_21_R5.entity.CraftPlayer;
 import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 
 /**
  * oh look another mira stan.
@@ -12,24 +14,59 @@ import org.bukkit.entity.Player;
  * @version 1.0.1
  * @since 1.0.0
  */
-public abstract class MiraPlayer<M extends MiraPulse> {
+public abstract
+class MiraPlayer<Pulse extends MiraPulse<?, ?>>
+  implements Breather<Pulse>
+{
   
-  protected final M mira;
-  protected final CraftPlayer player;
+  private @Nullable Pulse pulse;
+  protected final @NotNull CraftPlayer player;
   
   /**
    * @param player is for me?
-   * @param mira   anchorrr.
+   * @param pulse  anchorrr.
    */
-  public MiraPlayer(CraftPlayer player, M mira) {
-    this.mira = mira;
+  public
+  MiraPlayer(@NotNull CraftPlayer player, @NotNull Pulse pulse)
+  {
+    this.pulse = pulse;
     this.player = player;
   }
   
+  @Override
+  public @NotNull
+  Pulse pulse() throws FlatlineException
+  {
+    if (this.pulse != null)
+    {
+      return pulse;
+    }
+    else
+    {
+      throw new FlatlineException();
+    }
+  }
+  
+  @Override
+  public
+  void breathe(@NotNull Pulse pulse) throws IllegalStateException
+  {
+    if (this.pulse == null)
+    {
+      this.pulse = pulse;
+    }
+    else
+    {
+      throw new IllegalStateException("a breather may not have two pulses.");
+    }
+  }
+  
   /**
    * @see org.bukkit.craftbukkit.v1_21_R5.entity.CraftPlayer
    */
-  public CraftPlayer crafter() {
+  public @NotNull
+  CraftPlayer crafter()
+  {
     return player;
   }
   
@@ -37,7 +74,9 @@ public abstract class MiraPlayer<M extends MiraPulse> {
    * @param message The message to send to the player.
    * @see Player#sendMessage(String)
    */
-  public void dm(String message) {
+  public
+  void dm(String message)
+  {
     player.sendMessage(message);
   }
   
@@ -45,7 +84,9 @@ public abstract class MiraPlayer<M extends MiraPulse> {
    * @return the current in game name of this mira stan.
    * @see Player#getName()
    */
-  public String name() {
+  public
+  String name()
+  {
     return player.getName();
   }
   
@@ -53,7 +94,9 @@ public abstract class MiraPlayer<M extends MiraPulse> {
    * @return formatted "display" name with formatting enabled+encouraged.
    * @see org.bukkit.entity.Player#getName()
    */
-  public String display_name() {
+  public
+  String display_name()
+  {
     return player.getDisplayName();
   }
 }
diff --git a/src/sbs/mira/pvp/framework/MiraPlugin.java b/src/sbs/mira/pvp/framework/MiraPlugin.java
index 489bd3e..6974c6b 100644
--- a/src/sbs/mira/pvp/framework/MiraPlugin.java
+++ b/src/sbs/mira/pvp/framework/MiraPlugin.java
@@ -1,6 +1,5 @@
 package sbs.mira.pvp.framework;
 
-import org.jetbrains.annotations.NotNull;
 import com.sk89q.bukkit.util.CommandsManagerRegistration;
 import com.sk89q.minecraft.util.commands.*;
 import org.bukkit.command.Command;
@@ -9,10 +8,8 @@ import org.bukkit.command.ConsoleCommandSender;
 import org.bukkit.permissions.Permission;
 import org.bukkit.permissions.PermissionDefault;
 import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
-import sbs.mira.pvp.MiraPvpMaster;
-import sbs.mira.pvp.MiraPvpPlugin;
-import sbs.mira.pvp.MiraPvpPulse;
 
 import java.util.ArrayList;
 import java.util.logging.Level;
@@ -179,4 +176,10 @@ class MiraPlugin<Pulse extends MiraPulse<?, ?>>
     }
     return true;
   }
+  
+  public
+  boolean has_permission(@NotNull CommandSender sender, @NotNull String perm)
+  {
+    return commands_manager.hasPermission(sender, perm);
+  }
 }
diff --git a/src/sbs/mira/pvp/framework/MiraPulse.java b/src/sbs/mira/pvp/framework/MiraPulse.java
index 33c8a13..f8e2c59 100644
--- a/src/sbs/mira/pvp/framework/MiraPulse.java
+++ b/src/sbs/mira/pvp/framework/MiraPulse.java
@@ -13,7 +13,7 @@ import org.jetbrains.annotations.NotNull;
  * @since 1.0.0
  */
 public
-class MiraPulse<Plugin extends MiraPlugin, Master extends MiraPluginMaster>
+class MiraPulse<Plugin extends MiraPlugin<MiraPulse<?, ?>>, Master extends MiraPluginMaster<?, ?>>
 {
   @NotNull
   private final Plugin plugin;
diff --git a/src/sbs/mira/pvp/framework/util/WarMatch.java b/src/sbs/mira/pvp/framework/util/WarMatch.java
index 053f9bf..b756530 100644
--- a/src/sbs/mira/pvp/framework/util/WarMatch.java
+++ b/src/sbs/mira/pvp/framework/util/WarMatch.java
@@ -104,7 +104,7 @@ public abstract class WarMatch extends MiraModule {
      */
     public boolean canInteract(Entity pl, boolean adminBypass) {
         MiraPlayer wp = mira().getWarPlayer(pl.getUniqueId());
-        return wp == null || (wp.is_member_of_team() || adminBypass && mira().plugin().hasPermission(pl, "war.admin"));
+        return wp == null || (wp.is_member_of_team() || adminBypass && mira().plugin().has_permission(pl, "war.admin"));
     }
 
     /**
diff --git a/src/sbs/mira/pvp/util/modules/CommandUtility.java b/src/sbs/mira/pvp/util/modules/CommandUtility.java
index 034be9d..c1cebcd 100644
--- a/src/sbs/mira/pvp/util/modules/CommandUtility.java
+++ b/src/sbs/mira/pvp/util/modules/CommandUtility.java
@@ -58,7 +58,7 @@ public class CommandUtility extends MiraModule {
         // Does the player have a team preference?
         WarTeam preference = null;
         if (args.argsLength() > 0) {
-            if (!mira().plugin().hasPermission(sender, "war.preference")) {
+            if (!mira().plugin().has_permission(sender, "war.preference")) {
                 sender.sendMessage(ChatColor.RED + "You may not pick your team preference.");
                 return;
             }
@@ -342,7 +342,7 @@ public class CommandUtility extends MiraModule {
      */
     private void warnStaff(String message) {
         for (Player online : Bukkit.getOnlinePlayers())
-            if (mira().plugin().hasPermission(online, "war.staff"))
+            if (mira().plugin().has_permission(online, "war.staff"))
                 online.sendMessage(ChatColor.YELLOW + "Staff: " + message);
         Bukkit.getConsoleSender().sendMessage(message);
     }
@@ -357,7 +357,7 @@ public class CommandUtility extends MiraModule {
      */
     private void warnNonStaff(String message) {
         for (Player online : Bukkit.getOnlinePlayers())
-            if (!mira().plugin().hasPermission(online, "war.staff"))
+            if (!mira().plugin().has_permission(online, "war.staff"))
                 online.sendMessage(ChatColor.YELLOW + "Warning: " + message);
         Bukkit.getConsoleSender().sendMessage(message); // Also writes message to console as well.
     }
